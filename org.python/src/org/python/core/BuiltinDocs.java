// generated by make_pydocs.py

package org.python.core;

public class BuiltinDocs {

    // Docs for <module 'builtins' (built-in)>
    public final static String builtins_ArithmeticError_doc = 
        "Base class for arithmetic errors.";

    public final static String builtins_AssertionError_doc = 
        "Assertion failed.";

    public final static String builtins_AttributeError_doc = 
        "Attribute not found.";

    public final static String builtins_BaseException_doc = 
        "Common base class for all exceptions";

    public final static String builtins_BlockingIOError_doc = 
        "I/O operation would block.";

    public final static String builtins_BrokenPipeError_doc = 
        "Broken pipe.";

    public final static String builtins_BufferError_doc = 
        "Buffer error.";

    public final static String builtins_BytesWarning_doc = 
        "Base class for warnings about bytes and buffer related problems, mostly\n" + 
        "related to conversion from str or comparing to str.";

    public final static String builtins_ChildProcessError_doc = 
        "Child process error.";

    public final static String builtins_ConnectionAbortedError_doc = 
        "Connection aborted.";

    public final static String builtins_ConnectionError_doc = 
        "Connection error.";

    public final static String builtins_ConnectionRefusedError_doc = 
        "Connection refused.";

    public final static String builtins_ConnectionResetError_doc = 
        "Connection reset.";

    public final static String builtins_DeprecationWarning_doc = 
        "Base class for warnings about deprecated features.";

    public final static String builtins_EOFError_doc = 
        "Read beyond end of file.";

    public final static String builtins_EnvironmentError_doc = 
        "Base class for I/O related errors.";

    public final static String builtins_Exception_doc = 
        "Common base class for all non-exit exceptions.";

    public final static String builtins_FileExistsError_doc = 
        "File already exists.";

    public final static String builtins_FileNotFoundError_doc = 
        "File not found.";

    public final static String builtins_FloatingPointError_doc = 
        "Floating point operation failed.";

    public final static String builtins_FutureWarning_doc = 
        "Base class for warnings about constructs that will change semantically\n" + 
        "in the future.";

    public final static String builtins_GeneratorExit_doc = 
        "Request that a generator exit.";

    public final static String builtins_IOError_doc = 
        "Base class for I/O related errors.";

    public final static String builtins_ImportError_doc = 
        "Import can't find module, or can't find name in module.";

    public final static String builtins_ImportWarning_doc = 
        "Base class for warnings about probable mistakes in module imports";

    public final static String builtins_IndentationError_doc = 
        "Improper indentation.";

    public final static String builtins_IndexError_doc = 
        "Sequence index out of range.";

    public final static String builtins_InterruptedError_doc = 
        "Interrupted by signal.";

    public final static String builtins_IsADirectoryError_doc = 
        "Operation doesn't work on directories.";

    public final static String builtins_KeyError_doc = 
        "Mapping key not found.";

    public final static String builtins_KeyboardInterrupt_doc = 
        "Program interrupted by user.";

    public final static String builtins_LookupError_doc = 
        "Base class for lookup errors.";

    public final static String builtins_MemoryError_doc = 
        "Out of memory.";

    public final static String builtins_ModuleNotFoundError_doc = 
        "Module not found.";

    public final static String builtins_NameError_doc = 
        "Name not found globally.";

    public final static String builtins_NotADirectoryError_doc = 
        "Operation only works on directories.";

    public final static String builtins_NotImplementedError_doc = 
        "Method or function hasn't been implemented yet.";

    public final static String builtins_OSError_doc = 
        "Base class for I/O related errors.";

    public final static String builtins_OverflowError_doc = 
        "Result too large to be represented.";

    public final static String builtins_PendingDeprecationWarning_doc = 
        "Base class for warnings about features which will be deprecated\n" + 
        "in the future.";

    public final static String builtins_PermissionError_doc = 
        "Not enough permissions.";

    public final static String builtins_ProcessLookupError_doc = 
        "Process not found.";

    public final static String builtins_RecursionError_doc = 
        "Recursion limit exceeded.";

    public final static String builtins_ReferenceError_doc = 
        "Weak ref proxy used after referent went away.";

    public final static String builtins_ResourceWarning_doc = 
        "Base class for warnings about resource usage.";

    public final static String builtins_RuntimeError_doc = 
        "Unspecified run-time error.";

    public final static String builtins_RuntimeWarning_doc = 
        "Base class for warnings about dubious runtime behavior.";

    public final static String builtins_StopAsyncIteration_doc = 
        "Signal the end from iterator.__anext__().";

    public final static String builtins_StopIteration_doc = 
        "Signal the end from iterator.__next__().";

    public final static String builtins_SyntaxError_doc = 
        "Invalid syntax.";

    public final static String builtins_SyntaxWarning_doc = 
        "Base class for warnings about dubious syntax.";

    public final static String builtins_SystemError_doc = 
        "Internal error in the Python interpreter.\n" + 
        "\n" + 
        "Please report this to the Python maintainer, along with the traceback,\n" + 
        "the Python version, and the hardware/OS platform and version.";

    public final static String builtins_SystemExit_doc = 
        "Request to exit from the interpreter.";

    public final static String builtins_TabError_doc = 
        "Improper mixture of spaces and tabs.";

    public final static String builtins_TimeoutError_doc = 
        "Timeout expired.";

    public final static String builtins_TypeError_doc = 
        "Inappropriate argument type.";

    public final static String builtins_UnboundLocalError_doc = 
        "Local name referenced but not bound to a value.";

    public final static String builtins_UnicodeDecodeError_doc = 
        "Unicode decoding error.";

    public final static String builtins_UnicodeEncodeError_doc = 
        "Unicode encoding error.";

    public final static String builtins_UnicodeError_doc = 
        "Unicode related error.";

    public final static String builtins_UnicodeTranslateError_doc = 
        "Unicode translation error.";

    public final static String builtins_UnicodeWarning_doc = 
        "Base class for warnings about Unicode related problems, mostly\n" + 
        "related to conversion problems.";

    public final static String builtins_UserWarning_doc = 
        "Base class for warnings generated by user code.";

    public final static String builtins_ValueError_doc = 
        "Inappropriate argument value (of correct type).";

    public final static String builtins_Warning_doc = 
        "Base class for warning categories.";

    public final static String builtins_ZeroDivisionError_doc = 
        "Second argument to a division or modulo operation was zero.";

    public final static String builtins___build_class___doc = 
        "__build_class__(func, name, *bases, metaclass=None, **kwds) -> class\n" + 
        "\n" + 
        "Internal helper function used by the class statement.";

    public final static String builtins_doc = 
        "Built-in functions, exceptions, and other objects.\n" + 
        "\n" + 
        "Noteworthy: None is the `nil' object; Ellipsis represents `...' in slices.";

    public final static String builtins___import___doc = 
        "__import__(name, globals=None, locals=None, fromlist=(), level=0) -> module\n" + 
        "\n" + 
        "Import a module. Because this function is meant for use by the Python\n" + 
        "interpreter and not for general use, it is better to use\n" + 
        "importlib.import_module() to programmatically import a module.\n" + 
        "\n" + 
        "The globals argument is only used to determine the context;\n" + 
        "they are not modified.  The locals argument is unused.  The fromlist\n" + 
        "should be a list of names to emulate ``from name import ...'', or an\n" + 
        "empty list to emulate ``import name''.\n" + 
        "When importing a module from a package, note that __import__('A.B', ...)\n" + 
        "returns package A when fromlist is empty, but its submodule B when\n" + 
        "fromlist is not empty.  The level argument is used to determine whether to\n" + 
        "perform absolute or relative imports: 0 is absolute, while a positive number\n" + 
        "is the number of parent directories to search relative to the current module.";

    public final static String builtins___loader___doc = 
        "Meta path import for built-in modules.\n" + 
        "\n" + 
        "    All methods are either class or static methods to avoid the need to\n" + 
        "    instantiate the class.\n" + 
        "\n" + 
        "    ";

    public final static String builtins_abs_doc = 
        "Return the absolute value of the argument.";

    public final static String builtins_abs_sig = 
        "($module, x, /)";

    public final static String builtins_all_doc = 
        "Return True if bool(x) is True for all values x in the iterable.\n" + 
        "\n" + 
        "If the iterable is empty, return True.";

    public final static String builtins_all_sig = 
        "($module, iterable, /)";

    public final static String builtins_any_doc = 
        "Return True if bool(x) is True for any x in the iterable.\n" + 
        "\n" + 
        "If the iterable is empty, return False.";

    public final static String builtins_any_sig = 
        "($module, iterable, /)";

    public final static String builtins_ascii_doc = 
        "Return an ASCII-only representation of an object.\n" + 
        "\n" + 
        "As repr(), return a string containing a printable representation of an\n" + 
        "object, but escape the non-ASCII characters in the string returned by\n" + 
        "repr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\n" + 
        "to that returned by repr() in Python 2.";

    public final static String builtins_ascii_sig = 
        "($module, obj, /)";

    public final static String builtins_bin_doc = 
        "Return the binary representation of an integer.\n" + 
        "\n" + 
        "   >>> bin(2796202)\n" + 
        "   '0b1010101010101010101010'";

    public final static String builtins_bin_sig = 
        "($module, number, /)";

    public final static String builtins_bool_doc = 
        "bool(x) -> bool\n" + 
        "\n" + 
        "Returns True when the argument x is true, False otherwise.\n" + 
        "The builtins True and False are the only two instances of the class bool.\n" + 
        "The class bool is a subclass of the class int, and cannot be subclassed.";

    public final static String builtins_breakpoint_doc = 
        "breakpoint(*args, **kws)\n" + 
        "\n" + 
        "Call sys.breakpointhook(*args, **kws).  sys.breakpointhook() must accept\n" + 
        "whatever arguments are passed.\n" + 
        "\n" + 
        "By default, this drops you into the pdb debugger.";

    public final static String builtins_bytearray_doc = 
        "bytearray(iterable_of_ints) -> bytearray\n" + 
        "bytearray(string, encoding[, errors]) -> bytearray\n" + 
        "bytearray(bytes_or_buffer) -> mutable copy of bytes_or_buffer\n" + 
        "bytearray(int) -> bytes array of size given by the parameter initialized with null bytes\n" + 
        "bytearray() -> empty bytes array\n" + 
        "\n" + 
        "Construct a mutable bytearray object from:\n" + 
        "  - an iterable yielding integers in range(256)\n" + 
        "  - a text string encoded using the specified encoding\n" + 
        "  - a bytes or a buffer object\n" + 
        "  - any object implementing the buffer API.\n" + 
        "  - an integer";

    public final static String builtins_bytes_doc = 
        "bytes(iterable_of_ints) -> bytes\n" + 
        "bytes(string, encoding[, errors]) -> bytes\n" + 
        "bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\n" + 
        "bytes(int) -> bytes object of size given by the parameter initialized with null bytes\n" + 
        "bytes() -> empty bytes object\n" + 
        "\n" + 
        "Construct an immutable array of bytes from:\n" + 
        "  - an iterable yielding integers in range(256)\n" + 
        "  - a text string encoded using the specified encoding\n" + 
        "  - any object implementing the buffer API.\n" + 
        "  - an integer";

    public final static String builtins_callable_doc = 
        "Return whether the object is callable (i.e., some kind of function).\n" + 
        "\n" + 
        "Note that classes are callable, as are instances of classes with a\n" + 
        "__call__() method.";

    public final static String builtins_callable_sig = 
        "($module, obj, /)";

    public final static String builtins_chr_doc = 
        "Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff.";

    public final static String builtins_chr_sig = 
        "($module, i, /)";

    public final static String builtins_classmethod_doc = 
        "classmethod(function) -> method\n" + 
        "\n" + 
        "Convert a function to be a class method.\n" + 
        "\n" + 
        "A class method receives the class as implicit first argument,\n" + 
        "just like an instance method receives the instance.\n" + 
        "To declare a class method, use this idiom:\n" + 
        "\n" + 
        "  class C:\n" + 
        "      @classmethod\n" + 
        "      def f(cls, arg1, arg2, ...):\n" + 
        "          ...\n" + 
        "\n" + 
        "It can be called either on the class (e.g. C.f()) or on an instance\n" + 
        "(e.g. C().f()).  The instance is ignored except for its class.\n" + 
        "If a class method is called for a derived class, the derived class\n" + 
        "object is passed as the implied first argument.\n" + 
        "\n" + 
        "Class methods are different than C++ or Java static methods.\n" + 
        "If you want those, see the staticmethod builtin.";

    public final static String builtins_compile_doc = 
        "Compile source into a code object that can be executed by exec() or eval().\n" + 
        "\n" + 
        "The source code may represent a Python module, statement or expression.\n" + 
        "The filename will be used for run-time error messages.\n" + 
        "The mode must be 'exec' to compile a module, 'single' to compile a\n" + 
        "single (interactive) statement, or 'eval' to compile an expression.\n" + 
        "The flags argument, if present, controls which future statements influence\n" + 
        "the compilation of the code.\n" + 
        "The dont_inherit argument, if true, stops the compilation inheriting\n" + 
        "the effects of any future statements in effect in the code calling\n" + 
        "compile; if absent or false these statements do influence the compilation,\n" + 
        "in addition to any features explicitly specified.";

    public final static String builtins_compile_sig = 
        "($module, /, source, filename, mode, flags=0,\n" + 
        "        dont_inherit=False, optimize=-1)";

    public final static String builtins_complex_doc = 
        "Create a complex number from a real part and an optional imaginary part.\n" + 
        "\n" + 
        "This is equivalent to (real + imag*1j) where imag defaults to 0.";

    public final static String builtins_complex_sig = 
        "(real=0, imag=0)";

    public final static String builtins_copyright_doc = 
        "interactive prompt objects for printing the license text, a list of\n" + 
        "    contributors and the copyright notice.";

    public final static String builtins_credits_doc = 
        "interactive prompt objects for printing the license text, a list of\n" + 
        "    contributors and the copyright notice.";

    public final static String builtins_delattr_doc = 
        "Deletes the named attribute from the given object.\n" + 
        "\n" + 
        "delattr(x, 'y') is equivalent to ``del x.y''";

    public final static String builtins_delattr_sig = 
        "($module, obj, name, /)";

    public final static String builtins_dict_doc = 
        "dict() -> new empty dictionary\n" + 
        "dict(mapping) -> new dictionary initialized from a mapping object's\n" + 
        "    (key, value) pairs\n" + 
        "dict(iterable) -> new dictionary initialized as if via:\n" + 
        "    d = {}\n" + 
        "    for k, v in iterable:\n" + 
        "        d[k] = v\n" + 
        "dict(**kwargs) -> new dictionary initialized with the name=value pairs\n" + 
        "    in the keyword argument list.  For example:  dict(one=1, two=2)";

    public final static String builtins_dir_doc = 
        "dir([object]) -> list of strings\n" + 
        "\n" + 
        "If called without an argument, return the names in the current scope.\n" + 
        "Else, return an alphabetized list of names comprising (some of) the attributes\n" + 
        "of the given object, and of attributes reachable from it.\n" + 
        "If the object supplies a method named __dir__, it will be used; otherwise\n" + 
        "the default dir() logic is used and returns:\n" + 
        "  for a module object: the module's attributes.\n" + 
        "  for a class object:  its attributes, and recursively the attributes\n" + 
        "    of its bases.\n" + 
        "  for any other object: its attributes, its class's attributes, and\n" + 
        "    recursively the attributes of its class's base classes.";

    public final static String builtins_divmod_doc = 
        "Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.";

    public final static String builtins_divmod_sig = 
        "($module, x, y, /)";

    public final static String builtins_enumerate_doc = 
        "Return an enumerate object.\n" + 
        "\n" + 
        "  iterable\n" + 
        "    an object supporting iteration\n" + 
        "\n" + 
        "The enumerate object yields pairs containing a count (from start, which\n" + 
        "defaults to zero) and a value yielded by the iterable argument.\n" + 
        "\n" + 
        "enumerate is useful for obtaining an indexed list:\n" + 
        "    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...";

    public final static String builtins_enumerate_sig = 
        "(iterable, start=0)";

    public final static String builtins_eval_doc = 
        "Evaluate the given source in the context of globals and locals.\n" + 
        "\n" + 
        "The source may be a string representing a Python expression\n" + 
        "or a code object as returned by compile().\n" + 
        "The globals must be a dictionary and locals can be any mapping,\n" + 
        "defaulting to the current globals and locals.\n" + 
        "If only globals is given, locals defaults to it.";

    public final static String builtins_eval_sig = 
        "($module, source, globals=None, locals=None, /)";

    public final static String builtins_exec_doc = 
        "Execute the given source in the context of globals and locals.\n" + 
        "\n" + 
        "The source may be a string representing one or more Python statements\n" + 
        "or a code object as returned by compile().\n" + 
        "The globals must be a dictionary and locals can be any mapping,\n" + 
        "defaulting to the current globals and locals.\n" + 
        "If only globals is given, locals defaults to it.";

    public final static String builtins_exec_sig = 
        "($module, source, globals=None, locals=None, /)";

    public final static String builtins_exit_doc = 
        "";

    public final static String builtins_filter_doc = 
        "filter(function or None, iterable) --> filter object\n" + 
        "\n" + 
        "Return an iterator yielding those items of iterable for which function(item)\n" + 
        "is true. If function is None, return the items that are true.";

    public final static String builtins_float_doc = 
        "Convert a string or number to a floating point number, if possible.";

    public final static String builtins_float_sig = 
        "(x=0, /)";

    public final static String builtins_format_doc = 
        "Return value.__format__(format_spec)\n" + 
        "\n" + 
        "format_spec defaults to the empty string.\n" + 
        "See the Format Specification Mini-Language section of help('FORMATTING') for\n" + 
        "details.";

    public final static String builtins_format_sig = 
        "($module, value, format_spec='', /)";

    public final static String builtins_frozenset_doc = 
        "frozenset() -> empty frozenset object\n" + 
        "frozenset(iterable) -> frozenset object\n" + 
        "\n" + 
        "Build an immutable unordered collection of unique elements.";

    public final static String builtins_getattr_doc = 
        "getattr(object, name[, default]) -> value\n" + 
        "\n" + 
        "Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\n" + 
        "When a default argument is given, it is returned when the attribute doesn't\n" + 
        "exist; without it, an exception is raised in that case.";

    public final static String builtins_globals_doc = 
        "Return the dictionary containing the current scope's global variables.\n" + 
        "\n" + 
        "NOTE: Updates to this dictionary *will* affect name lookups in the current\n" + 
        "global scope and vice-versa.";

    public final static String builtins_globals_sig = 
        "($module, /)";

    public final static String builtins_hasattr_doc = 
        "Return whether the object has an attribute with the given name.\n" + 
        "\n" + 
        "This is done by calling getattr(obj, name) and catching AttributeError.";

    public final static String builtins_hasattr_sig = 
        "($module, obj, name, /)";

    public final static String builtins_hash_doc = 
        "Return the hash value for the given object.\n" + 
        "\n" + 
        "Two objects that compare equal must also have the same hash value, but the\n" + 
        "reverse is not necessarily true.";

    public final static String builtins_hash_sig = 
        "($module, obj, /)";

    public final static String builtins_help_doc = 
        "Define the builtin 'help'.\n" + 
        "\n" + 
        "    This is a wrapper around pydoc.help that provides a helpful message\n" + 
        "    when 'help' is typed at the Python interactive prompt.\n" + 
        "\n" + 
        "    Calling help() at the Python prompt starts an interactive help session.\n" + 
        "    Calling help(thing) prints help for the python object 'thing'.\n" + 
        "    ";

    public final static String builtins_hex_doc = 
        "Return the hexadecimal representation of an integer.\n" + 
        "\n" + 
        "   >>> hex(12648430)\n" + 
        "   '0xc0ffee'";

    public final static String builtins_hex_sig = 
        "($module, number, /)";

    public final static String builtins_id_doc = 
        "Return the identity of an object.\n" + 
        "\n" + 
        "This is guaranteed to be unique among simultaneously existing objects.\n" + 
        "(CPython uses the object's memory address.)";

    public final static String builtins_id_sig = 
        "($module, obj, /)";

    public final static String builtins_input_doc = 
        "Read a string from standard input.  The trailing newline is stripped.\n" + 
        "\n" + 
        "The prompt string, if given, is printed to standard output without a\n" + 
        "trailing newline before reading input.\n" + 
        "\n" + 
        "If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.\n" + 
        "On *nix systems, readline is used if available.";

    public final static String builtins_input_sig = 
        "($module, prompt=None, /)";

    public final static String builtins_int_doc = 
        "int([x]) -> integer\n" + 
        "int(x, base=10) -> integer\n" + 
        "\n" + 
        "Convert a number or string to an integer, or return 0 if no arguments\n" + 
        "are given.  If x is a number, return x.__int__().  For floating point\n" + 
        "numbers, this truncates towards zero.\n" + 
        "\n" + 
        "If x is not a number or if base is given, then x must be a string,\n" + 
        "bytes, or bytearray instance representing an integer literal in the\n" + 
        "given base.  The literal can be preceded by '+' or '-' and be surrounded\n" + 
        "by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n" + 
        "Base 0 means to interpret the base from the string as an integer literal.\n" + 
        ">>> int('0b100', base=0)\n" + 
        "4";

    public final static String builtins_isinstance_doc = 
        "Return whether an object is an instance of a class or of a subclass thereof.\n" + 
        "\n" + 
        "A tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to\n" + 
        "check against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)\n" + 
        "or ...`` etc.";

    public final static String builtins_isinstance_sig = 
        "($module, obj, class_or_tuple, /)";

    public final static String builtins_issubclass_doc = 
        "Return whether 'cls' is a derived from another class or is the same class.\n" + 
        "\n" + 
        "A tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to\n" + 
        "check against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)\n" + 
        "or ...`` etc.";

    public final static String builtins_issubclass_sig = 
        "($module, cls, class_or_tuple, /)";

    public final static String builtins_iter_doc = 
        "iter(iterable) -> iterator\n" + 
        "iter(callable, sentinel) -> iterator\n" + 
        "\n" + 
        "Get an iterator from an object.  In the first form, the argument must\n" + 
        "supply its own iterator, or be a sequence.\n" + 
        "In the second form, the callable is called until it returns the sentinel.";

    public final static String builtins_len_doc = 
        "Return the number of items in a container.";

    public final static String builtins_len_sig = 
        "($module, obj, /)";

    public final static String builtins_license_doc = 
        "interactive prompt objects for printing the license text, a list of\n" + 
        "    contributors and the copyright notice.";

    public final static String builtins_list_doc = 
        "Built-in mutable sequence.\n" + 
        "\n" + 
        "If no argument is given, the constructor creates a new empty list.\n" + 
        "The argument must be an iterable if specified.";

    public final static String builtins_list_sig = 
        "(iterable=(), /)";

    public final static String builtins_locals_doc = 
        "Return a dictionary containing the current scope's local variables.\n" + 
        "\n" + 
        "NOTE: Whether or not updates to this dictionary will affect name lookups in\n" + 
        "the local scope and vice-versa is *implementation dependent* and not\n" + 
        "covered by any backwards compatibility guarantees.";

    public final static String builtins_locals_sig = 
        "($module, /)";

    public final static String builtins_map_doc = 
        "map(func, *iterables) --> map object\n" + 
        "\n" + 
        "Make an iterator that computes the function using arguments from\n" + 
        "each of the iterables.  Stops when the shortest iterable is exhausted.";

    public final static String builtins_max_doc = 
        "max(iterable, *[, default=obj, key=func]) -> value\n" + 
        "max(arg1, arg2, *args, *[, key=func]) -> value\n" + 
        "\n" + 
        "With a single iterable argument, return its biggest item. The\n" + 
        "default keyword-only argument specifies an object to return if\n" + 
        "the provided iterable is empty.\n" + 
        "With two or more arguments, return the largest argument.";

    public final static String builtins_memoryview_doc = 
        "Create a new memoryview object which references the given object.";

    public final static String builtins_memoryview_sig = 
        "(object)";

    public final static String builtins_min_doc = 
        "min(iterable, *[, default=obj, key=func]) -> value\n" + 
        "min(arg1, arg2, *args, *[, key=func]) -> value\n" + 
        "\n" + 
        "With a single iterable argument, return its smallest item. The\n" + 
        "default keyword-only argument specifies an object to return if\n" + 
        "the provided iterable is empty.\n" + 
        "With two or more arguments, return the smallest argument.";

    public final static String builtins_next_doc = 
        "next(iterator[, default])\n" + 
        "\n" + 
        "Return the next item from the iterator. If default is given and the iterator\n" + 
        "is exhausted, it is returned instead of raising StopIteration.";

    public final static String builtins_object_doc = 
        "The most base type";

    public final static String builtins_object_sig = 
        "()";

    public final static String builtins_oct_doc = 
        "Return the octal representation of an integer.\n" + 
        "\n" + 
        "   >>> oct(342391)\n" + 
        "   '0o1234567'";

    public final static String builtins_oct_sig = 
        "($module, number, /)";

    public final static String builtins_open_doc = 
        "Open file and return a stream.  Raise OSError upon failure.\n" + 
        "\n" + 
        "file is either a text or byte string giving the name (and the path\n" + 
        "if the file isn't in the current working directory) of the file to\n" + 
        "be opened or an integer file descriptor of the file to be\n" + 
        "wrapped. (If a file descriptor is given, it is closed when the\n" + 
        "returned I/O object is closed, unless closefd is set to False.)\n" + 
        "\n" + 
        "mode is an optional string that specifies the mode in which the file\n" + 
        "is opened. It defaults to 'r' which means open for reading in text\n" + 
        "mode.  Other common values are 'w' for writing (truncating the file if\n" + 
        "it already exists), 'x' for creating and writing to a new file, and\n" + 
        "'a' for appending (which on some Unix systems, means that all writes\n" + 
        "append to the end of the file regardless of the current seek position).\n" + 
        "In text mode, if encoding is not specified the encoding used is platform\n" + 
        "dependent: locale.getpreferredencoding(False) is called to get the\n" + 
        "current locale encoding. (For reading and writing raw bytes use binary\n" + 
        "mode and leave encoding unspecified.) The available modes are:\n" + 
        "\n" + 
        "========= ===============================================================\n" + 
        "Character Meaning\n" + 
        "--------- ---------------------------------------------------------------\n" + 
        "'r'       open for reading (default)\n" + 
        "'w'       open for writing, truncating the file first\n" + 
        "'x'       create a new file and open it for writing\n" + 
        "'a'       open for writing, appending to the end of the file if it exists\n" + 
        "'b'       binary mode\n" + 
        "'t'       text mode (default)\n" + 
        "'+'       open a disk file for updating (reading and writing)\n" + 
        "'U'       universal newline mode (deprecated)\n" + 
        "========= ===============================================================\n" + 
        "\n" + 
        "The default mode is 'rt' (open for reading text). For binary random\n" + 
        "access, the mode 'w+b' opens and truncates the file to 0 bytes, while\n" + 
        "'r+b' opens the file without truncation. The 'x' mode implies 'w' and\n" + 
        "raises an `FileExistsError` if the file already exists.\n" + 
        "\n" + 
        "Python distinguishes between files opened in binary and text modes,\n" + 
        "even when the underlying operating system doesn't. Files opened in\n" + 
        "binary mode (appending 'b' to the mode argument) return contents as\n" + 
        "bytes objects without any decoding. In text mode (the default, or when\n" + 
        "'t' is appended to the mode argument), the contents of the file are\n" + 
        "returned as strings, the bytes having been first decoded using a\n" + 
        "platform-dependent encoding or using the specified encoding if given.\n" + 
        "\n" + 
        "'U' mode is deprecated and will raise an exception in future versions\n" + 
        "of Python.  It has no effect in Python 3.  Use newline to control\n" + 
        "universal newlines mode.\n" + 
        "\n" + 
        "buffering is an optional integer used to set the buffering policy.\n" + 
        "Pass 0 to switch buffering off (only allowed in binary mode), 1 to select\n" + 
        "line buffering (only usable in text mode), and an integer > 1 to indicate\n" + 
        "the size of a fixed-size chunk buffer.  When no buffering argument is\n" + 
        "given, the default buffering policy works as follows:\n" + 
        "\n" + 
        "* Binary files are buffered in fixed-size chunks; the size of the buffer\n" + 
        "  is chosen using a heuristic trying to determine the underlying device's\n" + 
        "  \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n" + 
        "  On many systems, the buffer will typically be 4096 or 8192 bytes long.\n" + 
        "\n" + 
        "* \"Interactive\" text files (files for which isatty() returns True)\n" + 
        "  use line buffering.  Other text files use the policy described above\n" + 
        "  for binary files.\n" + 
        "\n" + 
        "encoding is the name of the encoding used to decode or encode the\n" + 
        "file. This should only be used in text mode. The default encoding is\n" + 
        "platform dependent, but any encoding supported by Python can be\n" + 
        "passed.  See the codecs module for the list of supported encodings.\n" + 
        "\n" + 
        "errors is an optional string that specifies how encoding errors are to\n" + 
        "be handled---this argument should not be used in binary mode. Pass\n" + 
        "'strict' to raise a ValueError exception if there is an encoding error\n" + 
        "(the default of None has the same effect), or pass 'ignore' to ignore\n" + 
        "errors. (Note that ignoring encoding errors can lead to data loss.)\n" + 
        "See the documentation for codecs.register or run 'help(codecs.Codec)'\n" + 
        "for a list of the permitted encoding error strings.\n" + 
        "\n" + 
        "newline controls how universal newlines works (it only applies to text\n" + 
        "mode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works as\n" + 
        "follows:\n" + 
        "\n" + 
        "* On input, if newline is None, universal newlines mode is\n" + 
        "  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n" + 
        "  these are translated into '\\n' before being returned to the\n" + 
        "  caller. If it is '', universal newline mode is enabled, but line\n" + 
        "  endings are returned to the caller untranslated. If it has any of\n" + 
        "  the other legal values, input lines are only terminated by the given\n" + 
        "  string, and the line ending is returned to the caller untranslated.\n" + 
        "\n" + 
        "* On output, if newline is None, any '\\n' characters written are\n" + 
        "  translated to the system default line separator, os.linesep. If\n" + 
        "  newline is '' or '\\n', no translation takes place. If newline is any\n" + 
        "  of the other legal values, any '\\n' characters written are translated\n" + 
        "  to the given string.\n" + 
        "\n" + 
        "If closefd is False, the underlying file descriptor will be kept open\n" + 
        "when the file is closed. This does not work when a file name is given\n" + 
        "and must be True in that case.\n" + 
        "\n" + 
        "A custom opener can be used by passing a callable as *opener*. The\n" + 
        "underlying file descriptor for the file object is then obtained by\n" + 
        "calling *opener* with (*file*, *flags*). *opener* must return an open\n" + 
        "file descriptor (passing os.open as *opener* results in functionality\n" + 
        "similar to passing None).\n" + 
        "\n" + 
        "open() returns a file object whose type depends on the mode, and\n" + 
        "through which the standard file operations such as reading and writing\n" + 
        "are performed. When open() is used to open a file in a text mode ('w',\n" + 
        "'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\n" + 
        "a file in a binary mode, the returned class varies: in read binary\n" + 
        "mode, it returns a BufferedReader; in write binary and append binary\n" + 
        "modes, it returns a BufferedWriter, and in read/write mode, it returns\n" + 
        "a BufferedRandom.\n" + 
        "\n" + 
        "It is also possible to use a string or bytearray as a file for both\n" + 
        "reading and writing. For strings StringIO can be used like a file\n" + 
        "opened in a text mode, and for bytes a BytesIO can be used like a file\n" + 
        "opened in a binary mode.";

    public final static String builtins_open_sig = 
        "($module, /, file, mode='r', buffering=-1, encoding=None,\n" + 
        "     errors=None, newline=None, closefd=True, opener=None)";

    public final static String builtins_ord_doc = 
        "Return the Unicode code point for a one-character string.";

    public final static String builtins_ord_sig = 
        "($module, c, /)";

    public final static String builtins_pow_doc = 
        "Equivalent to x**y (with two arguments) or x**y % z (with three arguments)\n" + 
        "\n" + 
        "Some types, such as ints, are able to use a more efficient algorithm when\n" + 
        "invoked using the three argument form.";

    public final static String builtins_pow_sig = 
        "($module, x, y, z=None, /)";

    public final static String builtins_print_doc = 
        "print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n" + 
        "\n" + 
        "Prints the values to a stream, or to sys.stdout by default.\n" + 
        "Optional keyword arguments:\n" + 
        "file:  a file-like object (stream); defaults to the current sys.stdout.\n" + 
        "sep:   string inserted between values, default a space.\n" + 
        "end:   string appended after the last value, default a newline.\n" + 
        "flush: whether to forcibly flush the stream.";

    public final static String builtins_property_doc = 
        "Property attribute.\n" + 
        "\n" + 
        "  fget\n" + 
        "    function to be used for getting an attribute value\n" + 
        "  fset\n" + 
        "    function to be used for setting an attribute value\n" + 
        "  fdel\n" + 
        "    function to be used for del'ing an attribute\n" + 
        "  doc\n" + 
        "    docstring\n" + 
        "\n" + 
        "Typical use is to define a managed attribute x:\n" + 
        "\n" + 
        "class C(object):\n" + 
        "    def getx(self): return self._x\n" + 
        "    def setx(self, value): self._x = value\n" + 
        "    def delx(self): del self._x\n" + 
        "    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n" + 
        "\n" + 
        "Decorators make defining new properties or modifying existing ones easy:\n" + 
        "\n" + 
        "class C(object):\n" + 
        "    @property\n" + 
        "    def x(self):\n" + 
        "        \"I am the 'x' property.\"\n" + 
        "        return self._x\n" + 
        "    @x.setter\n" + 
        "    def x(self, value):\n" + 
        "        self._x = value\n" + 
        "    @x.deleter\n" + 
        "    def x(self):\n" + 
        "        del self._x";

    public final static String builtins_property_sig = 
        "(fget=None, fset=None, fdel=None, doc=None)";

    public final static String builtins_quit_doc = 
        "";

    public final static String builtins_range_doc = 
        "range(stop) -> range object\n" + 
        "range(start, stop[, step]) -> range object\n" + 
        "\n" + 
        "Return an object that produces a sequence of integers from start (inclusive)\n" + 
        "to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\n" + 
        "start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\n" + 
        "These are exactly the valid indices for a list of 4 elements.\n" + 
        "When step is given, it specifies the increment (or decrement).";

    public final static String builtins_repr_doc = 
        "Return the canonical string representation of the object.\n" + 
        "\n" + 
        "For many object types, including most builtins, eval(repr(obj)) == obj.";

    public final static String builtins_repr_sig = 
        "($module, obj, /)";

    public final static String builtins_reversed_doc = 
        "Return a reverse iterator over the values of the given sequence.";

    public final static String builtins_reversed_sig = 
        "(sequence, /)";

    public final static String builtins_round_doc = 
        "Round a number to a given precision in decimal digits.\n" + 
        "\n" + 
        "The return value is an integer if ndigits is omitted or None.  Otherwise\n" + 
        "the return value has the same type as the number.  ndigits may be negative.";

    public final static String builtins_round_sig = 
        "($module, /, number, ndigits=None)";

    public final static String builtins_set_doc = 
        "set() -> new empty set object\n" + 
        "set(iterable) -> new set object\n" + 
        "\n" + 
        "Build an unordered collection of unique elements.";

    public final static String builtins_setattr_doc = 
        "Sets the named attribute on the given object to the specified value.\n" + 
        "\n" + 
        "setattr(x, 'y', v) is equivalent to ``x.y = v''";

    public final static String builtins_setattr_sig = 
        "($module, obj, name, value, /)";

    public final static String builtins_slice_doc = 
        "slice(stop)\n" + 
        "slice(start, stop[, step])\n" + 
        "\n" + 
        "Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).";

    public final static String builtins_sorted_doc = 
        "Return a new list containing all items from the iterable in ascending order.\n" + 
        "\n" + 
        "A custom key function can be supplied to customize the sort order, and the\n" + 
        "reverse flag can be set to request the result in descending order.";

    public final static String builtins_sorted_sig = 
        "($module, iterable, /, *, key=None, reverse=False)";

    public final static String builtins_staticmethod_doc = 
        "staticmethod(function) -> method\n" + 
        "\n" + 
        "Convert a function to be a static method.\n" + 
        "\n" + 
        "A static method does not receive an implicit first argument.\n" + 
        "To declare a static method, use this idiom:\n" + 
        "\n" + 
        "     class C:\n" + 
        "         @staticmethod\n" + 
        "         def f(arg1, arg2, ...):\n" + 
        "             ...\n" + 
        "\n" + 
        "It can be called either on the class (e.g. C.f()) or on an instance\n" + 
        "(e.g. C().f()).  The instance is ignored except for its class.\n" + 
        "\n" + 
        "Static methods in Python are similar to those found in Java or C++.\n" + 
        "For a more advanced concept, see the classmethod builtin.";

    public final static String builtins_str_doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String builtins_sum_doc = 
        "Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n" + 
        "\n" + 
        "When the iterable is empty, return the start value.\n" + 
        "This function is intended specifically for use with numeric values and may\n" + 
        "reject non-numeric types.";

    public final static String builtins_sum_sig = 
        "($module, iterable, start=0, /)";

    public final static String builtins_super_doc = 
        "super() -> same as super(__class__, <first argument>)\n" + 
        "super(type) -> unbound super object\n" + 
        "super(type, obj) -> bound super object; requires isinstance(obj, type)\n" + 
        "super(type, type2) -> bound super object; requires issubclass(type2, type)\n" + 
        "Typical use to call a cooperative superclass method:\n" + 
        "class C(B):\n" + 
        "    def meth(self, arg):\n" + 
        "        super().meth(arg)\n" + 
        "This works for class methods too:\n" + 
        "class C(B):\n" + 
        "    @classmethod\n" + 
        "    def cmeth(cls, arg):\n" + 
        "        super().cmeth(arg)\n" + 
        "";

    public final static String builtins_tuple_doc = 
        "Built-in immutable sequence.\n" + 
        "\n" + 
        "If no argument is given, the constructor returns an empty tuple.\n" + 
        "If iterable is specified the tuple is initialized from iterable's items.\n" + 
        "\n" + 
        "If the argument is a tuple, the return value is the same object.";

    public final static String builtins_tuple_sig = 
        "(iterable=(), /)";

    public final static String builtins_type_doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String builtins_vars_doc = 
        "vars([object]) -> dictionary\n" + 
        "\n" + 
        "Without arguments, equivalent to locals().\n" + 
        "With an argument, equivalent to object.__dict__.";

    public final static String builtins_zip_doc = 
        "zip(iter1 [,iter2 [...]]) --> zip object\n" + 
        "\n" + 
        "Return a zip object whose .__next__() method returns a tuple where\n" + 
        "the i-th element comes from the i-th iterable argument.  The .__next__()\n" + 
        "method continues until the shortest iterable in the argument sequence\n" + 
        "is exhausted and then it raises StopIteration.";

    // Docs for <class 'object'>
    public final static String object___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String object___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String object___delattr___sig = 
        "($self, name, /)";

    public final static String object___dir___doc = 
        "Default dir() implementation.";

    public final static String object___dir___sig = 
        "($self, /)";

    public final static String object_doc = 
        "The most base type";

    public final static String object___eq___doc = 
        "Return self==value.";

    public final static String object___eq___sig = 
        "($self, value, /)";

    public final static String object___format___doc = 
        "Default object formatter.";

    public final static String object___format___sig = 
        "($self, format_spec, /)";

    public final static String object___ge___doc = 
        "Return self>=value.";

    public final static String object___ge___sig = 
        "($self, value, /)";

    public final static String object___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String object___getattribute___sig = 
        "($self, name, /)";

    public final static String object___gt___doc = 
        "Return self>value.";

    public final static String object___gt___sig = 
        "($self, value, /)";

    public final static String object___hash___doc = 
        "Return hash(self).";

    public final static String object___hash___sig = 
        "($self, /)";

    public final static String object___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String object___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String object___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String object___le___doc = 
        "Return self<=value.";

    public final static String object___le___sig = 
        "($self, value, /)";

    public final static String object___lt___doc = 
        "Return self<value.";

    public final static String object___lt___sig = 
        "($self, value, /)";

    public final static String object___ne___doc = 
        "Return self!=value.";

    public final static String object___ne___sig = 
        "($self, value, /)";

    public final static String object___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String object___new___sig = 
        "($type, *args, **kwargs)";

    public final static String object___reduce___doc = 
        "Helper for pickle.";

    public final static String object___reduce___sig = 
        "($self, /)";

    public final static String object___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String object___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String object___repr___doc = 
        "Return repr(self).";

    public final static String object___repr___sig = 
        "($self, /)";

    public final static String object___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String object___setattr___sig = 
        "($self, name, value, /)";

    public final static String object___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String object___sizeof___sig = 
        "($self, /)";

    public final static String object___str___doc = 
        "Return str(self).";

    public final static String object___str___sig = 
        "($self, /)";

    public final static String object___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'type'>
    public final static String type___base___doc = 
        "The most base type";

    public final static String type___base___sig = 
        "()";

    public final static String type___call___doc = 
        "Call self as a function.";

    public final static String type___call___sig = 
        "($self, /, *args, **kwargs)";

    public final static String type___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String type___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String type___delattr___sig = 
        "($self, name, /)";

    public final static String type___dir___doc = 
        "Specialized __dir__ implementation for types.";

    public final static String type___dir___sig = 
        "($self, /)";

    public final static String type_doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String type___eq___doc = 
        "Return self==value.";

    public final static String type___eq___sig = 
        "($self, value, /)";

    public final static String type___format___doc = 
        "Default object formatter.";

    public final static String type___format___sig = 
        "($self, format_spec, /)";

    public final static String type___ge___doc = 
        "Return self>=value.";

    public final static String type___ge___sig = 
        "($self, value, /)";

    public final static String type___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String type___getattribute___sig = 
        "($self, name, /)";

    public final static String type___gt___doc = 
        "Return self>value.";

    public final static String type___gt___sig = 
        "($self, value, /)";

    public final static String type___hash___doc = 
        "Return hash(self).";

    public final static String type___hash___sig = 
        "($self, /)";

    public final static String type___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String type___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String type___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String type___instancecheck___doc = 
        "Check if an object is an instance.";

    public final static String type___instancecheck___sig = 
        "($self, instance, /)";

    public final static String type___le___doc = 
        "Return self<=value.";

    public final static String type___le___sig = 
        "($self, value, /)";

    public final static String type___lt___doc = 
        "Return self<value.";

    public final static String type___lt___sig = 
        "($self, value, /)";

    public final static String type___ne___doc = 
        "Return self!=value.";

    public final static String type___ne___sig = 
        "($self, value, /)";

    public final static String type___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String type___new___sig = 
        "($type, *args, **kwargs)";

    public final static String type___prepare___doc = 
        "__prepare__() -> dict\n" + 
        "used to create the namespace for the class statement";

    public final static String type___reduce___doc = 
        "Helper for pickle.";

    public final static String type___reduce___sig = 
        "($self, /)";

    public final static String type___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String type___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String type___repr___doc = 
        "Return repr(self).";

    public final static String type___repr___sig = 
        "($self, /)";

    public final static String type___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String type___setattr___sig = 
        "($self, name, value, /)";

    public final static String type___sizeof___doc = 
        "Return memory consumption of the type object.";

    public final static String type___sizeof___sig = 
        "($self, /)";

    public final static String type___str___doc = 
        "Return str(self).";

    public final static String type___str___sig = 
        "($self, /)";

    public final static String type___subclasscheck___doc = 
        "Check if a class is a subclass.";

    public final static String type___subclasscheck___sig = 
        "($self, subclass, /)";

    public final static String type___subclasses___doc = 
        "Return a list of immediate subclasses.";

    public final static String type___subclasses___sig = 
        "($self, /)";

    public final static String type___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String type_mro_doc = 
        "Return a type's method resolution order.";

    public final static String type_mro_sig = 
        "($self, /)";

    // Docs for <class 'bytes'>
    public final static String bytes___add___doc = 
        "Return self+value.";

    public final static String bytes___add___sig = 
        "($self, value, /)";

    public final static String bytes___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String bytes___contains___doc = 
        "Return key in self.";

    public final static String bytes___contains___sig = 
        "($self, key, /)";

    public final static String bytes___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String bytes___delattr___sig = 
        "($self, name, /)";

    public final static String bytes___dir___doc = 
        "Default dir() implementation.";

    public final static String bytes___dir___sig = 
        "($self, /)";

    public final static String bytes_doc = 
        "bytes(iterable_of_ints) -> bytes\n" + 
        "bytes(string, encoding[, errors]) -> bytes\n" + 
        "bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\n" + 
        "bytes(int) -> bytes object of size given by the parameter initialized with null bytes\n" + 
        "bytes() -> empty bytes object\n" + 
        "\n" + 
        "Construct an immutable array of bytes from:\n" + 
        "  - an iterable yielding integers in range(256)\n" + 
        "  - a text string encoded using the specified encoding\n" + 
        "  - any object implementing the buffer API.\n" + 
        "  - an integer";

    public final static String bytes___eq___doc = 
        "Return self==value.";

    public final static String bytes___eq___sig = 
        "($self, value, /)";

    public final static String bytes___format___doc = 
        "Default object formatter.";

    public final static String bytes___format___sig = 
        "($self, format_spec, /)";

    public final static String bytes___ge___doc = 
        "Return self>=value.";

    public final static String bytes___ge___sig = 
        "($self, value, /)";

    public final static String bytes___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String bytes___getattribute___sig = 
        "($self, name, /)";

    public final static String bytes___getitem___doc = 
        "Return self[key].";

    public final static String bytes___getitem___sig = 
        "($self, key, /)";

    public final static String bytes___getnewargs___doc = 
        "";

    public final static String bytes___gt___doc = 
        "Return self>value.";

    public final static String bytes___gt___sig = 
        "($self, value, /)";

    public final static String bytes___hash___doc = 
        "Return hash(self).";

    public final static String bytes___hash___sig = 
        "($self, /)";

    public final static String bytes___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String bytes___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String bytes___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String bytes___iter___doc = 
        "Implement iter(self).";

    public final static String bytes___iter___sig = 
        "($self, /)";

    public final static String bytes___le___doc = 
        "Return self<=value.";

    public final static String bytes___le___sig = 
        "($self, value, /)";

    public final static String bytes___len___doc = 
        "Return len(self).";

    public final static String bytes___len___sig = 
        "($self, /)";

    public final static String bytes___lt___doc = 
        "Return self<value.";

    public final static String bytes___lt___sig = 
        "($self, value, /)";

    public final static String bytes___mod___doc = 
        "Return self%value.";

    public final static String bytes___mod___sig = 
        "($self, value, /)";

    public final static String bytes___mul___doc = 
        "Return self*value.n";

    public final static String bytes___mul___sig = 
        "($self, value, /)";

    public final static String bytes___ne___doc = 
        "Return self!=value.";

    public final static String bytes___ne___sig = 
        "($self, value, /)";

    public final static String bytes___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String bytes___new___sig = 
        "($type, *args, **kwargs)";

    public final static String bytes___reduce___doc = 
        "Helper for pickle.";

    public final static String bytes___reduce___sig = 
        "($self, /)";

    public final static String bytes___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String bytes___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String bytes___repr___doc = 
        "Return repr(self).";

    public final static String bytes___repr___sig = 
        "($self, /)";

    public final static String bytes___rmod___doc = 
        "Return value%self.";

    public final static String bytes___rmod___sig = 
        "($self, value, /)";

    public final static String bytes___rmul___doc = 
        "Return self*value.";

    public final static String bytes___rmul___sig = 
        "($self, value, /)";

    public final static String bytes___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String bytes___setattr___sig = 
        "($self, name, value, /)";

    public final static String bytes___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String bytes___sizeof___sig = 
        "($self, /)";

    public final static String bytes___str___doc = 
        "Return str(self).";

    public final static String bytes___str___sig = 
        "($self, /)";

    public final static String bytes___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String bytes_capitalize_doc = 
        "B.capitalize() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with only its first character capitalized (ASCII)\n" + 
        "and the rest lower-cased.";

    public final static String bytes_center_doc = 
        "B.center(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B centered in a string of length width.  Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String bytes_count_doc = 
        "B.count(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the number of non-overlapping occurrences of subsection sub in\n" + 
        "bytes B[start:end].  Optional arguments start and end are interpreted\n" + 
        "as in slice notation.";

    public final static String bytes_decode_doc = 
        "Decode the bytes using the codec registered for encoding.\n" + 
        "\n" + 
        "  encoding\n" + 
        "    The encoding with which to decode the bytes.\n" + 
        "  errors\n" + 
        "    The error handling scheme to use for the handling of decoding errors.\n" + 
        "    The default is 'strict' meaning that decoding errors raise a\n" + 
        "    UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n" + 
        "    as well as any other name registered with codecs.register_error that\n" + 
        "    can handle UnicodeDecodeErrors.";

    public final static String bytes_decode_sig = 
        "($self, /, encoding='utf-8', errors='strict')";

    public final static String bytes_endswith_doc = 
        "B.endswith(suffix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if B ends with the specified suffix, False otherwise.\n" + 
        "With optional start, test B beginning at that position.\n" + 
        "With optional end, stop comparing B at that position.\n" + 
        "suffix can also be a tuple of bytes to try.";

    public final static String bytes_expandtabs_doc = 
        "B.expandtabs(tabsize=8) -> copy of B\n" + 
        "\n" + 
        "Return a copy of B where all tab characters are expanded using spaces.\n" + 
        "If tabsize is not given, a tab size of 8 characters is assumed.";

    public final static String bytes_find_doc = 
        "B.find(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in B where subsection sub is found,\n" + 
        "such that sub is contained within B[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String bytes_fromhex_doc = 
        "Create a bytes object from a string of hexadecimal numbers.\n" + 
        "\n" + 
        "Spaces between two numbers are accepted.\n" + 
        "Example: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'.";

    public final static String bytes_fromhex_sig = 
        "($type, string, /)";

    public final static String bytes_hex_doc = 
        "B.hex() -> string\n" + 
        "\n" + 
        "Create a string of hexadecimal numbers from a bytes object.\n" + 
        "Example: b'\\xb9\\x01\\xef'.hex() -> 'b901ef'.";

    public final static String bytes_index_doc = 
        "B.index(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in B where subsection sub is found,\n" + 
        "such that sub is contained within B[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Raises ValueError when the subsection is not found.";

    public final static String bytes_isalnum_doc = 
        "B.isalnum() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are alphanumeric\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytes_isalpha_doc = 
        "B.isalpha() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are alphabetic\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytes_isascii_doc = 
        "B.isascii() -> bool\n" + 
        "\n" + 
        "Return True if B is empty or all characters in B are ASCII,\n" + 
        "False otherwise.";

    public final static String bytes_isdigit_doc = 
        "B.isdigit() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are digits\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytes_islower_doc = 
        "B.islower() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in B are lowercase and there is\n" + 
        "at least one cased character in B, False otherwise.";

    public final static String bytes_isspace_doc = 
        "B.isspace() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are whitespace\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytes_istitle_doc = 
        "B.istitle() -> bool\n" + 
        "\n" + 
        "Return True if B is a titlecased string and there is at least one\n" + 
        "character in B, i.e. uppercase characters may only follow uncased\n" + 
        "characters and lowercase characters only cased ones. Return False\n" + 
        "otherwise.";

    public final static String bytes_isupper_doc = 
        "B.isupper() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in B are uppercase and there is\n" + 
        "at least one cased character in B, False otherwise.";

    public final static String bytes_join_doc = 
        "Concatenate any number of bytes objects.\n" + 
        "\n" + 
        "The bytes whose method is called is inserted in between each pair.\n" + 
        "\n" + 
        "The result is returned as a new bytes object.\n" + 
        "\n" + 
        "Example: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.";

    public final static String bytes_join_sig = 
        "($self, iterable_of_bytes, /)";

    public final static String bytes_ljust_doc = 
        "B.ljust(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B left justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String bytes_lower_doc = 
        "B.lower() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with all ASCII characters converted to lowercase.";

    public final static String bytes_lstrip_doc = 
        "Strip leading bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip leading  ASCII whitespace.";

    public final static String bytes_lstrip_sig = 
        "($self, bytes=None, /)";

    public final static String bytes_maketrans_doc = 
        "Return a translation table useable for the bytes or bytearray translate method.\n" + 
        "\n" + 
        "The returned table will be one where each byte in frm is mapped to the byte at\n" + 
        "the same position in to.\n" + 
        "\n" + 
        "The bytes objects frm and to must be of the same length.";

    public final static String bytes_maketrans_sig = 
        "(frm, to, /)";

    public final static String bytes_partition_doc = 
        "Partition the bytes into three parts using the given separator.\n" + 
        "\n" + 
        "This will search for the separator sep in the bytes. If the separator is found,\n" + 
        "returns a 3-tuple containing the part before the separator, the separator\n" + 
        "itself, and the part after it.\n" + 
        "\n" + 
        "If the separator is not found, returns a 3-tuple containing the original bytes\n" + 
        "object and two empty bytes objects.";

    public final static String bytes_partition_sig = 
        "($self, sep, /)";

    public final static String bytes_replace_doc = 
        "Return a copy with all occurrences of substring old replaced by new.\n" + 
        "\n" + 
        "  count\n" + 
        "    Maximum number of occurrences to replace.\n" + 
        "    -1 (the default value) means replace all occurrences.\n" + 
        "\n" + 
        "If the optional argument count is given, only the first count occurrences are\n" + 
        "replaced.";

    public final static String bytes_replace_sig = 
        "($self, old, new, count=-1, /)";

    public final static String bytes_rfind_doc = 
        "B.rfind(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in B where subsection sub is found,\n" + 
        "such that sub is contained within B[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String bytes_rindex_doc = 
        "B.rindex(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in B where subsection sub is found,\n" + 
        "such that sub is contained within B[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Raise ValueError when the subsection is not found.";

    public final static String bytes_rjust_doc = 
        "B.rjust(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B right justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String bytes_rpartition_doc = 
        "Partition the bytes into three parts using the given separator.\n" + 
        "\n" + 
        "This will search for the separator sep in the bytes, starting at the end. If\n" + 
        "the separator is found, returns a 3-tuple containing the part before the\n" + 
        "separator, the separator itself, and the part after it.\n" + 
        "\n" + 
        "If the separator is not found, returns a 3-tuple containing two empty bytes\n" + 
        "objects and the original bytes object.";

    public final static String bytes_rpartition_sig = 
        "($self, sep, /)";

    public final static String bytes_rsplit_doc = 
        "Return a list of the sections in the bytes, using sep as the delimiter.\n" + 
        "\n" + 
        "  sep\n" + 
        "    The delimiter according which to split the bytes.\n" + 
        "    None (the default value) means split on ASCII whitespace characters\n" + 
        "    (space, tab, return, newline, formfeed, vertical tab).\n" + 
        "  maxsplit\n" + 
        "    Maximum number of splits to do.\n" + 
        "    -1 (the default value) means no limit.\n" + 
        "\n" + 
        "Splitting is done starting at the end of the bytes and working to the front.";

    public final static String bytes_rsplit_sig = 
        "($self, /, sep=None, maxsplit=-1)";

    public final static String bytes_rstrip_doc = 
        "Strip trailing bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip trailing ASCII whitespace.";

    public final static String bytes_rstrip_sig = 
        "($self, bytes=None, /)";

    public final static String bytes_split_doc = 
        "Return a list of the sections in the bytes, using sep as the delimiter.\n" + 
        "\n" + 
        "  sep\n" + 
        "    The delimiter according which to split the bytes.\n" + 
        "    None (the default value) means split on ASCII whitespace characters\n" + 
        "    (space, tab, return, newline, formfeed, vertical tab).\n" + 
        "  maxsplit\n" + 
        "    Maximum number of splits to do.\n" + 
        "    -1 (the default value) means no limit.";

    public final static String bytes_split_sig = 
        "($self, /, sep=None, maxsplit=-1)";

    public final static String bytes_splitlines_doc = 
        "Return a list of the lines in the bytes, breaking at line boundaries.\n" + 
        "\n" + 
        "Line breaks are not included in the resulting list unless keepends is given and\n" + 
        "true.";

    public final static String bytes_splitlines_sig = 
        "($self, /, keepends=False)";

    public final static String bytes_startswith_doc = 
        "B.startswith(prefix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if B starts with the specified prefix, False otherwise.\n" + 
        "With optional start, test B beginning at that position.\n" + 
        "With optional end, stop comparing B at that position.\n" + 
        "prefix can also be a tuple of bytes to try.";

    public final static String bytes_strip_doc = 
        "Strip leading and trailing bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip leading and trailing ASCII whitespace.";

    public final static String bytes_strip_sig = 
        "($self, bytes=None, /)";

    public final static String bytes_swapcase_doc = 
        "B.swapcase() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with uppercase ASCII characters converted\n" + 
        "to lowercase ASCII and vice versa.";

    public final static String bytes_title_doc = 
        "B.title() -> copy of B\n" + 
        "\n" + 
        "Return a titlecased version of B, i.e. ASCII words start with uppercase\n" + 
        "characters, all remaining cased characters have lowercase.";

    public final static String bytes_translate_doc = 
        "Return a copy with each character mapped by the given translation table.\n" + 
        "\n" + 
        "  table\n" + 
        "    Translation table, which must be a bytes object of length 256.\n" + 
        "\n" + 
        "All characters occurring in the optional argument delete are removed.\n" + 
        "The remaining characters are mapped through the given translation table.";

    public final static String bytes_translate_sig = 
        "($self, table, /, delete=b'')";

    public final static String bytes_upper_doc = 
        "B.upper() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with all ASCII characters converted to uppercase.";

    public final static String bytes_zfill_doc = 
        "B.zfill(width) -> copy of B\n" + 
        "\n" + 
        "Pad a numeric string B with zeros on the left, to fill a field\n" + 
        "of the specified width.  B is never truncated.";

    // Docs for <class 'dict'>
    public final static String dict___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String dict___contains___doc = 
        "True if the dictionary has the specified key, else False.";

    public final static String dict___contains___sig = 
        "($self, key, /)";

    public final static String dict___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String dict___delattr___sig = 
        "($self, name, /)";

    public final static String dict___delitem___doc = 
        "Delete self[key].";

    public final static String dict___delitem___sig = 
        "($self, key, /)";

    public final static String dict___dir___doc = 
        "Default dir() implementation.";

    public final static String dict___dir___sig = 
        "($self, /)";

    public final static String dict_doc = 
        "dict() -> new empty dictionary\n" + 
        "dict(mapping) -> new dictionary initialized from a mapping object's\n" + 
        "    (key, value) pairs\n" + 
        "dict(iterable) -> new dictionary initialized as if via:\n" + 
        "    d = {}\n" + 
        "    for k, v in iterable:\n" + 
        "        d[k] = v\n" + 
        "dict(**kwargs) -> new dictionary initialized with the name=value pairs\n" + 
        "    in the keyword argument list.  For example:  dict(one=1, two=2)";

    public final static String dict___eq___doc = 
        "Return self==value.";

    public final static String dict___eq___sig = 
        "($self, value, /)";

    public final static String dict___format___doc = 
        "Default object formatter.";

    public final static String dict___format___sig = 
        "($self, format_spec, /)";

    public final static String dict___ge___doc = 
        "Return self>=value.";

    public final static String dict___ge___sig = 
        "($self, value, /)";

    public final static String dict___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String dict___getattribute___sig = 
        "($self, name, /)";

    public final static String dict___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String dict___gt___doc = 
        "Return self>value.";

    public final static String dict___gt___sig = 
        "($self, value, /)";

    public final static String dict___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String dict___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String dict___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String dict___iter___doc = 
        "Implement iter(self).";

    public final static String dict___iter___sig = 
        "($self, /)";

    public final static String dict___le___doc = 
        "Return self<=value.";

    public final static String dict___le___sig = 
        "($self, value, /)";

    public final static String dict___len___doc = 
        "Return len(self).";

    public final static String dict___len___sig = 
        "($self, /)";

    public final static String dict___lt___doc = 
        "Return self<value.";

    public final static String dict___lt___sig = 
        "($self, value, /)";

    public final static String dict___ne___doc = 
        "Return self!=value.";

    public final static String dict___ne___sig = 
        "($self, value, /)";

    public final static String dict___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String dict___new___sig = 
        "($type, *args, **kwargs)";

    public final static String dict___reduce___doc = 
        "Helper for pickle.";

    public final static String dict___reduce___sig = 
        "($self, /)";

    public final static String dict___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String dict___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String dict___repr___doc = 
        "Return repr(self).";

    public final static String dict___repr___sig = 
        "($self, /)";

    public final static String dict___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String dict___setattr___sig = 
        "($self, name, value, /)";

    public final static String dict___setitem___doc = 
        "Set self[key] to value.";

    public final static String dict___setitem___sig = 
        "($self, key, value, /)";

    public final static String dict___sizeof___doc = 
        "D.__sizeof__() -> size of D in memory, in bytes";

    public final static String dict___str___doc = 
        "Return str(self).";

    public final static String dict___str___sig = 
        "($self, /)";

    public final static String dict___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String dict_clear_doc = 
        "D.clear() -> None.  Remove all items from D.";

    public final static String dict_copy_doc = 
        "D.copy() -> a shallow copy of D";

    public final static String dict_fromkeys_doc = 
        "Create a new dictionary with keys from iterable and values set to value.";

    public final static String dict_fromkeys_sig = 
        "($type, iterable, value=None, /)";

    public final static String dict_get_doc = 
        "Return the value for key if key is in the dictionary, else default.";

    public final static String dict_get_sig = 
        "($self, key, default=None, /)";

    public final static String dict_items_doc = 
        "D.items() -> a set-like object providing a view on D's items";

    public final static String dict_keys_doc = 
        "D.keys() -> a set-like object providing a view on D's keys";

    public final static String dict_pop_doc = 
        "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n" + 
        "If key is not found, d is returned if given, otherwise KeyError is raised";

    public final static String dict_popitem_doc = 
        "D.popitem() -> (k, v), remove and return some (key, value) pair as a\n" + 
        "2-tuple; but raise KeyError if D is empty.";

    public final static String dict_setdefault_doc = 
        "Insert key with a value of default if key is not in the dictionary.\n" + 
        "\n" + 
        "Return the value for key if key is in the dictionary, else default.";

    public final static String dict_setdefault_sig = 
        "($self, key, default=None, /)";

    public final static String dict_update_doc = 
        "D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\n" + 
        "If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\n" + 
        "If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\n" + 
        "In either case, this is followed by: for k in F:  D[k] = F[k]";

    public final static String dict_values_doc = 
        "D.values() -> an object providing a view on D's values";

    // Docs for <class 'list'>
    public final static String list___add___doc = 
        "Return self+value.";

    public final static String list___add___sig = 
        "($self, value, /)";

    public final static String list___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String list___contains___doc = 
        "Return key in self.";

    public final static String list___contains___sig = 
        "($self, key, /)";

    public final static String list___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String list___delattr___sig = 
        "($self, name, /)";

    public final static String list___delitem___doc = 
        "Delete self[key].";

    public final static String list___delitem___sig = 
        "($self, key, /)";

    public final static String list___dir___doc = 
        "Default dir() implementation.";

    public final static String list___dir___sig = 
        "($self, /)";

    public final static String list_doc = 
        "Built-in mutable sequence.\n" + 
        "\n" + 
        "If no argument is given, the constructor creates a new empty list.\n" + 
        "The argument must be an iterable if specified.";

    public final static String list___eq___doc = 
        "Return self==value.";

    public final static String list___eq___sig = 
        "($self, value, /)";

    public final static String list___format___doc = 
        "Default object formatter.";

    public final static String list___format___sig = 
        "($self, format_spec, /)";

    public final static String list___ge___doc = 
        "Return self>=value.";

    public final static String list___ge___sig = 
        "($self, value, /)";

    public final static String list___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String list___getattribute___sig = 
        "($self, name, /)";

    public final static String list___getitem___doc = 
        "x.__getitem__(y) <==> x[y]";

    public final static String list___gt___doc = 
        "Return self>value.";

    public final static String list___gt___sig = 
        "($self, value, /)";

    public final static String list___iadd___doc = 
        "Implement self+=value.";

    public final static String list___iadd___sig = 
        "($self, value, /)";

    public final static String list___imul___doc = 
        "Implement self*=value.";

    public final static String list___imul___sig = 
        "($self, value, /)";

    public final static String list___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String list___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String list___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String list___iter___doc = 
        "Implement iter(self).";

    public final static String list___iter___sig = 
        "($self, /)";

    public final static String list___le___doc = 
        "Return self<=value.";

    public final static String list___le___sig = 
        "($self, value, /)";

    public final static String list___len___doc = 
        "Return len(self).";

    public final static String list___len___sig = 
        "($self, /)";

    public final static String list___lt___doc = 
        "Return self<value.";

    public final static String list___lt___sig = 
        "($self, value, /)";

    public final static String list___mul___doc = 
        "Return self*value.n";

    public final static String list___mul___sig = 
        "($self, value, /)";

    public final static String list___ne___doc = 
        "Return self!=value.";

    public final static String list___ne___sig = 
        "($self, value, /)";

    public final static String list___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String list___new___sig = 
        "($type, *args, **kwargs)";

    public final static String list___reduce___doc = 
        "Helper for pickle.";

    public final static String list___reduce___sig = 
        "($self, /)";

    public final static String list___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String list___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String list___repr___doc = 
        "Return repr(self).";

    public final static String list___repr___sig = 
        "($self, /)";

    public final static String list___reversed___doc = 
        "Return a reverse iterator over the list.";

    public final static String list___reversed___sig = 
        "($self, /)";

    public final static String list___rmul___doc = 
        "Return self*value.";

    public final static String list___rmul___sig = 
        "($self, value, /)";

    public final static String list___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String list___setattr___sig = 
        "($self, name, value, /)";

    public final static String list___setitem___doc = 
        "Set self[key] to value.";

    public final static String list___setitem___sig = 
        "($self, key, value, /)";

    public final static String list___sizeof___doc = 
        "Return the size of the list in memory, in bytes.";

    public final static String list___sizeof___sig = 
        "($self, /)";

    public final static String list___str___doc = 
        "Return str(self).";

    public final static String list___str___sig = 
        "($self, /)";

    public final static String list___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String list_append_doc = 
        "Append object to the end of the list.";

    public final static String list_append_sig = 
        "($self, object, /)";

    public final static String list_clear_doc = 
        "Remove all items from list.";

    public final static String list_clear_sig = 
        "($self, /)";

    public final static String list_copy_doc = 
        "Return a shallow copy of the list.";

    public final static String list_copy_sig = 
        "($self, /)";

    public final static String list_count_doc = 
        "Return number of occurrences of value.";

    public final static String list_count_sig = 
        "($self, value, /)";

    public final static String list_extend_doc = 
        "Extend list by appending elements from the iterable.";

    public final static String list_extend_sig = 
        "($self, iterable, /)";

    public final static String list_index_doc = 
        "Return first index of value.\n" + 
        "\n" + 
        "Raises ValueError if the value is not present.";

    public final static String list_index_sig = 
        "($self, value, start=0, stop=sys.maxsize, /)";

    public final static String list_insert_doc = 
        "Insert object before index.";

    public final static String list_insert_sig = 
        "($self, index, object, /)";

    public final static String list_pop_doc = 
        "Remove and return item at index (default last).\n" + 
        "\n" + 
        "Raises IndexError if list is empty or index is out of range.";

    public final static String list_pop_sig = 
        "($self, index=-1, /)";

    public final static String list_remove_doc = 
        "Remove first occurrence of value.\n" + 
        "\n" + 
        "Raises ValueError if the value is not present.";

    public final static String list_remove_sig = 
        "($self, value, /)";

    public final static String list_reverse_doc = 
        "Reverse *IN PLACE*.";

    public final static String list_reverse_sig = 
        "($self, /)";

    public final static String list_sort_doc = 
        "Stable sort *IN PLACE*.";

    public final static String list_sort_sig = 
        "($self, /, *, key=None, reverse=False)";

    // Docs for <class 'slice'>
    public final static String slice___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String slice___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String slice___delattr___sig = 
        "($self, name, /)";

    public final static String slice___dir___doc = 
        "Default dir() implementation.";

    public final static String slice___dir___sig = 
        "($self, /)";

    public final static String slice_doc = 
        "slice(stop)\n" + 
        "slice(start, stop[, step])\n" + 
        "\n" + 
        "Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).";

    public final static String slice___eq___doc = 
        "Return self==value.";

    public final static String slice___eq___sig = 
        "($self, value, /)";

    public final static String slice___format___doc = 
        "Default object formatter.";

    public final static String slice___format___sig = 
        "($self, format_spec, /)";

    public final static String slice___ge___doc = 
        "Return self>=value.";

    public final static String slice___ge___sig = 
        "($self, value, /)";

    public final static String slice___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String slice___getattribute___sig = 
        "($self, name, /)";

    public final static String slice___gt___doc = 
        "Return self>value.";

    public final static String slice___gt___sig = 
        "($self, value, /)";

    public final static String slice___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String slice___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String slice___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String slice___le___doc = 
        "Return self<=value.";

    public final static String slice___le___sig = 
        "($self, value, /)";

    public final static String slice___lt___doc = 
        "Return self<value.";

    public final static String slice___lt___sig = 
        "($self, value, /)";

    public final static String slice___ne___doc = 
        "Return self!=value.";

    public final static String slice___ne___sig = 
        "($self, value, /)";

    public final static String slice___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String slice___new___sig = 
        "($type, *args, **kwargs)";

    public final static String slice___reduce___doc = 
        "Return state information for pickling.";

    public final static String slice___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String slice___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String slice___repr___doc = 
        "Return repr(self).";

    public final static String slice___repr___sig = 
        "($self, /)";

    public final static String slice___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String slice___setattr___sig = 
        "($self, name, value, /)";

    public final static String slice___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String slice___sizeof___sig = 
        "($self, /)";

    public final static String slice___str___doc = 
        "Return str(self).";

    public final static String slice___str___sig = 
        "($self, /)";

    public final static String slice___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String slice_indices_doc = 
        "S.indices(len) -> (start, stop, stride)\n" + 
        "\n" + 
        "Assuming a sequence of length len, calculate the start and stop\n" + 
        "indices, and the stride length of the extended slice described by\n" + 
        "S. Out of bounds indices are clipped in a manner consistent with the\n" + 
        "handling of normal slices.";

    // Docs for <class 'super'>
    public final static String super___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String super___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String super___delattr___sig = 
        "($self, name, /)";

    public final static String super___dir___doc = 
        "Default dir() implementation.";

    public final static String super___dir___sig = 
        "($self, /)";

    public final static String super_doc = 
        "super() -> same as super(__class__, <first argument>)\n" + 
        "super(type) -> unbound super object\n" + 
        "super(type, obj) -> bound super object; requires isinstance(obj, type)\n" + 
        "super(type, type2) -> bound super object; requires issubclass(type2, type)\n" + 
        "Typical use to call a cooperative superclass method:\n" + 
        "class C(B):\n" + 
        "    def meth(self, arg):\n" + 
        "        super().meth(arg)\n" + 
        "This works for class methods too:\n" + 
        "class C(B):\n" + 
        "    @classmethod\n" + 
        "    def cmeth(cls, arg):\n" + 
        "        super().cmeth(arg)\n" + 
        "";

    public final static String super___eq___doc = 
        "Return self==value.";

    public final static String super___eq___sig = 
        "($self, value, /)";

    public final static String super___format___doc = 
        "Default object formatter.";

    public final static String super___format___sig = 
        "($self, format_spec, /)";

    public final static String super___ge___doc = 
        "Return self>=value.";

    public final static String super___ge___sig = 
        "($self, value, /)";

    public final static String super___get___doc = 
        "Return an attribute of instance, which is of type owner.";

    public final static String super___get___sig = 
        "($self, instance, owner, /)";

    public final static String super___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String super___getattribute___sig = 
        "($self, name, /)";

    public final static String super___gt___doc = 
        "Return self>value.";

    public final static String super___gt___sig = 
        "($self, value, /)";

    public final static String super___hash___doc = 
        "Return hash(self).";

    public final static String super___hash___sig = 
        "($self, /)";

    public final static String super___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String super___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String super___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String super___le___doc = 
        "Return self<=value.";

    public final static String super___le___sig = 
        "($self, value, /)";

    public final static String super___lt___doc = 
        "Return self<value.";

    public final static String super___lt___sig = 
        "($self, value, /)";

    public final static String super___ne___doc = 
        "Return self!=value.";

    public final static String super___ne___sig = 
        "($self, value, /)";

    public final static String super___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String super___new___sig = 
        "($type, *args, **kwargs)";

    public final static String super___reduce___doc = 
        "Helper for pickle.";

    public final static String super___reduce___sig = 
        "($self, /)";

    public final static String super___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String super___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String super___repr___doc = 
        "Return repr(self).";

    public final static String super___repr___sig = 
        "($self, /)";

    public final static String super___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String super___setattr___sig = 
        "($self, name, value, /)";

    public final static String super___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String super___sizeof___sig = 
        "($self, /)";

    public final static String super___str___doc = 
        "Return str(self).";

    public final static String super___str___sig = 
        "($self, /)";

    public final static String super___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'staticmethod'>
    public final static String staticmethod___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String staticmethod___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String staticmethod___delattr___sig = 
        "($self, name, /)";

    public final static String staticmethod___dir___doc = 
        "Default dir() implementation.";

    public final static String staticmethod___dir___sig = 
        "($self, /)";

    public final static String staticmethod_doc = 
        "staticmethod(function) -> method\n" + 
        "\n" + 
        "Convert a function to be a static method.\n" + 
        "\n" + 
        "A static method does not receive an implicit first argument.\n" + 
        "To declare a static method, use this idiom:\n" + 
        "\n" + 
        "     class C:\n" + 
        "         @staticmethod\n" + 
        "         def f(arg1, arg2, ...):\n" + 
        "             ...\n" + 
        "\n" + 
        "It can be called either on the class (e.g. C.f()) or on an instance\n" + 
        "(e.g. C().f()).  The instance is ignored except for its class.\n" + 
        "\n" + 
        "Static methods in Python are similar to those found in Java or C++.\n" + 
        "For a more advanced concept, see the classmethod builtin.";

    public final static String staticmethod___eq___doc = 
        "Return self==value.";

    public final static String staticmethod___eq___sig = 
        "($self, value, /)";

    public final static String staticmethod___format___doc = 
        "Default object formatter.";

    public final static String staticmethod___format___sig = 
        "($self, format_spec, /)";

    public final static String staticmethod___ge___doc = 
        "Return self>=value.";

    public final static String staticmethod___ge___sig = 
        "($self, value, /)";

    public final static String staticmethod___get___doc = 
        "Return an attribute of instance, which is of type owner.";

    public final static String staticmethod___get___sig = 
        "($self, instance, owner, /)";

    public final static String staticmethod___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String staticmethod___getattribute___sig = 
        "($self, name, /)";

    public final static String staticmethod___gt___doc = 
        "Return self>value.";

    public final static String staticmethod___gt___sig = 
        "($self, value, /)";

    public final static String staticmethod___hash___doc = 
        "Return hash(self).";

    public final static String staticmethod___hash___sig = 
        "($self, /)";

    public final static String staticmethod___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String staticmethod___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String staticmethod___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String staticmethod___le___doc = 
        "Return self<=value.";

    public final static String staticmethod___le___sig = 
        "($self, value, /)";

    public final static String staticmethod___lt___doc = 
        "Return self<value.";

    public final static String staticmethod___lt___sig = 
        "($self, value, /)";

    public final static String staticmethod___ne___doc = 
        "Return self!=value.";

    public final static String staticmethod___ne___sig = 
        "($self, value, /)";

    public final static String staticmethod___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String staticmethod___new___sig = 
        "($type, *args, **kwargs)";

    public final static String staticmethod___reduce___doc = 
        "Helper for pickle.";

    public final static String staticmethod___reduce___sig = 
        "($self, /)";

    public final static String staticmethod___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String staticmethod___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String staticmethod___repr___doc = 
        "Return repr(self).";

    public final static String staticmethod___repr___sig = 
        "($self, /)";

    public final static String staticmethod___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String staticmethod___setattr___sig = 
        "($self, name, value, /)";

    public final static String staticmethod___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String staticmethod___sizeof___sig = 
        "($self, /)";

    public final static String staticmethod___str___doc = 
        "Return str(self).";

    public final static String staticmethod___str___sig = 
        "($self, /)";

    public final static String staticmethod___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'float'>
    public final static String float___abs___doc = 
        "abs(self)";

    public final static String float___abs___sig = 
        "($self, /)";

    public final static String float___add___doc = 
        "Return self+value.";

    public final static String float___add___sig = 
        "($self, value, /)";

    public final static String float___bool___doc = 
        "self != 0";

    public final static String float___bool___sig = 
        "($self, /)";

    public final static String float___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String float___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String float___delattr___sig = 
        "($self, name, /)";

    public final static String float___dir___doc = 
        "Default dir() implementation.";

    public final static String float___dir___sig = 
        "($self, /)";

    public final static String float___divmod___doc = 
        "Return divmod(self, value).";

    public final static String float___divmod___sig = 
        "($self, value, /)";

    public final static String float_doc = 
        "Convert a string or number to a floating point number, if possible.";

    public final static String float___eq___doc = 
        "Return self==value.";

    public final static String float___eq___sig = 
        "($self, value, /)";

    public final static String float___float___doc = 
        "float(self)";

    public final static String float___float___sig = 
        "($self, /)";

    public final static String float___floordiv___doc = 
        "Return self//value.";

    public final static String float___floordiv___sig = 
        "($self, value, /)";

    public final static String float___format___doc = 
        "Formats the float according to format_spec.";

    public final static String float___format___sig = 
        "($self, format_spec, /)";

    public final static String float___ge___doc = 
        "Return self>=value.";

    public final static String float___ge___sig = 
        "($self, value, /)";

    public final static String float___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String float___getattribute___sig = 
        "($self, name, /)";

    public final static String float___getformat___doc = 
        "You probably don't want to use this function.\n" + 
        "\n" + 
        "  typestr\n" + 
        "    Must be 'double' or 'float'.\n" + 
        "\n" + 
        "It exists mainly to be used in Python's test suite.\n" + 
        "\n" + 
        "This function returns whichever of 'unknown', 'IEEE, big-endian' or 'IEEE,\n" + 
        "little-endian' best describes the format of floating point numbers used by the\n" + 
        "C type named by typestr.";

    public final static String float___getformat___sig = 
        "($type, typestr, /)";

    public final static String float___getnewargs___doc = 
        "";

    public final static String float___getnewargs___sig = 
        "($self, /)";

    public final static String float___gt___doc = 
        "Return self>value.";

    public final static String float___gt___sig = 
        "($self, value, /)";

    public final static String float___hash___doc = 
        "Return hash(self).";

    public final static String float___hash___sig = 
        "($self, /)";

    public final static String float___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String float___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String float___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String float___int___doc = 
        "int(self)";

    public final static String float___int___sig = 
        "($self, /)";

    public final static String float___le___doc = 
        "Return self<=value.";

    public final static String float___le___sig = 
        "($self, value, /)";

    public final static String float___lt___doc = 
        "Return self<value.";

    public final static String float___lt___sig = 
        "($self, value, /)";

    public final static String float___mod___doc = 
        "Return self%value.";

    public final static String float___mod___sig = 
        "($self, value, /)";

    public final static String float___mul___doc = 
        "Return self*value.";

    public final static String float___mul___sig = 
        "($self, value, /)";

    public final static String float___ne___doc = 
        "Return self!=value.";

    public final static String float___ne___sig = 
        "($self, value, /)";

    public final static String float___neg___doc = 
        "-self";

    public final static String float___neg___sig = 
        "($self, /)";

    public final static String float___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String float___new___sig = 
        "($type, *args, **kwargs)";

    public final static String float___pos___doc = 
        "+self";

    public final static String float___pos___sig = 
        "($self, /)";

    public final static String float___pow___doc = 
        "Return pow(self, value, mod).";

    public final static String float___pow___sig = 
        "($self, value, mod=None, /)";

    public final static String float___radd___doc = 
        "Return value+self.";

    public final static String float___radd___sig = 
        "($self, value, /)";

    public final static String float___rdivmod___doc = 
        "Return divmod(value, self).";

    public final static String float___rdivmod___sig = 
        "($self, value, /)";

    public final static String float___reduce___doc = 
        "Helper for pickle.";

    public final static String float___reduce___sig = 
        "($self, /)";

    public final static String float___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String float___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String float___repr___doc = 
        "Return repr(self).";

    public final static String float___repr___sig = 
        "($self, /)";

    public final static String float___rfloordiv___doc = 
        "Return value//self.";

    public final static String float___rfloordiv___sig = 
        "($self, value, /)";

    public final static String float___rmod___doc = 
        "Return value%self.";

    public final static String float___rmod___sig = 
        "($self, value, /)";

    public final static String float___rmul___doc = 
        "Return value*self.";

    public final static String float___rmul___sig = 
        "($self, value, /)";

    public final static String float___round___doc = 
        "Return the Integral closest to x, rounding half toward even.\n" + 
        "\n" + 
        "When an argument is passed, work like built-in round(x, ndigits).";

    public final static String float___round___sig = 
        "($self, ndigits=None, /)";

    public final static String float___rpow___doc = 
        "Return pow(value, self, mod).";

    public final static String float___rpow___sig = 
        "($self, value, mod=None, /)";

    public final static String float___rsub___doc = 
        "Return value-self.";

    public final static String float___rsub___sig = 
        "($self, value, /)";

    public final static String float___rtruediv___doc = 
        "Return value/self.";

    public final static String float___rtruediv___sig = 
        "($self, value, /)";

    public final static String float___set_format___doc = 
        "You probably don't want to use this function.\n" + 
        "\n" + 
        "  typestr\n" + 
        "    Must be 'double' or 'float'.\n" + 
        "  fmt\n" + 
        "    Must be one of 'unknown', 'IEEE, big-endian' or 'IEEE, little-endian',\n" + 
        "    and in addition can only be one of the latter two if it appears to\n" + 
        "    match the underlying C reality.\n" + 
        "\n" + 
        "It exists mainly to be used in Python's test suite.\n" + 
        "\n" + 
        "Override the automatic determination of C-level floating point type.\n" + 
        "This affects how floats are converted to and from binary strings.";

    public final static String float___set_format___sig = 
        "($type, typestr, fmt, /)";

    public final static String float___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String float___setattr___sig = 
        "($self, name, value, /)";

    public final static String float___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String float___sizeof___sig = 
        "($self, /)";

    public final static String float___str___doc = 
        "Return str(self).";

    public final static String float___str___sig = 
        "($self, /)";

    public final static String float___sub___doc = 
        "Return self-value.";

    public final static String float___sub___sig = 
        "($self, value, /)";

    public final static String float___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String float___truediv___doc = 
        "Return self/value.";

    public final static String float___truediv___sig = 
        "($self, value, /)";

    public final static String float___trunc___doc = 
        "Return the Integral closest to x between 0 and x.";

    public final static String float___trunc___sig = 
        "($self, /)";

    public final static String float_as_integer_ratio_doc = 
        "Return integer ratio.\n" + 
        "\n" + 
        "Return a pair of integers, whose ratio is exactly equal to the original float\n" + 
        "and with a positive denominator.\n" + 
        "\n" + 
        "Raise OverflowError on infinities and a ValueError on NaNs.\n" + 
        "\n" + 
        ">>> (10.0).as_integer_ratio()\n" + 
        "(10, 1)\n" + 
        ">>> (0.0).as_integer_ratio()\n" + 
        "(0, 1)\n" + 
        ">>> (-.25).as_integer_ratio()\n" + 
        "(-1, 4)";

    public final static String float_as_integer_ratio_sig = 
        "($self, /)";

    public final static String float_conjugate_doc = 
        "Return self, the complex conjugate of any float.";

    public final static String float_conjugate_sig = 
        "($self, /)";

    public final static String float_fromhex_doc = 
        "Create a floating-point number from a hexadecimal string.\n" + 
        "\n" + 
        ">>> float.fromhex('0x1.ffffp10')\n" + 
        "2047.984375\n" + 
        ">>> float.fromhex('-0x1p-1074')\n" + 
        "-5e-324";

    public final static String float_fromhex_sig = 
        "($type, string, /)";

    public final static String float_hex_doc = 
        "Return a hexadecimal representation of a floating-point number.\n" + 
        "\n" + 
        ">>> (-0.1).hex()\n" + 
        "'-0x1.999999999999ap-4'\n" + 
        ">>> 3.14159.hex()\n" + 
        "'0x1.921f9f01b866ep+1'";

    public final static String float_hex_sig = 
        "($self, /)";

    public final static String float_is_integer_doc = 
        "Return True if the float is an integer.";

    public final static String float_is_integer_sig = 
        "($self, /)";

    // Docs for <class 'enumerate'>
    public final static String enumerate___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String enumerate___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String enumerate___delattr___sig = 
        "($self, name, /)";

    public final static String enumerate___dir___doc = 
        "Default dir() implementation.";

    public final static String enumerate___dir___sig = 
        "($self, /)";

    public final static String enumerate_doc = 
        "Return an enumerate object.\n" + 
        "\n" + 
        "  iterable\n" + 
        "    an object supporting iteration\n" + 
        "\n" + 
        "The enumerate object yields pairs containing a count (from start, which\n" + 
        "defaults to zero) and a value yielded by the iterable argument.\n" + 
        "\n" + 
        "enumerate is useful for obtaining an indexed list:\n" + 
        "    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...";

    public final static String enumerate___eq___doc = 
        "Return self==value.";

    public final static String enumerate___eq___sig = 
        "($self, value, /)";

    public final static String enumerate___format___doc = 
        "Default object formatter.";

    public final static String enumerate___format___sig = 
        "($self, format_spec, /)";

    public final static String enumerate___ge___doc = 
        "Return self>=value.";

    public final static String enumerate___ge___sig = 
        "($self, value, /)";

    public final static String enumerate___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String enumerate___getattribute___sig = 
        "($self, name, /)";

    public final static String enumerate___gt___doc = 
        "Return self>value.";

    public final static String enumerate___gt___sig = 
        "($self, value, /)";

    public final static String enumerate___hash___doc = 
        "Return hash(self).";

    public final static String enumerate___hash___sig = 
        "($self, /)";

    public final static String enumerate___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String enumerate___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String enumerate___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String enumerate___iter___doc = 
        "Implement iter(self).";

    public final static String enumerate___iter___sig = 
        "($self, /)";

    public final static String enumerate___le___doc = 
        "Return self<=value.";

    public final static String enumerate___le___sig = 
        "($self, value, /)";

    public final static String enumerate___lt___doc = 
        "Return self<value.";

    public final static String enumerate___lt___sig = 
        "($self, value, /)";

    public final static String enumerate___ne___doc = 
        "Return self!=value.";

    public final static String enumerate___ne___sig = 
        "($self, value, /)";

    public final static String enumerate___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String enumerate___new___sig = 
        "($type, *args, **kwargs)";

    public final static String enumerate___next___doc = 
        "Implement next(self).";

    public final static String enumerate___next___sig = 
        "($self, /)";

    public final static String enumerate___reduce___doc = 
        "Return state information for pickling.";

    public final static String enumerate___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String enumerate___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String enumerate___repr___doc = 
        "Return repr(self).";

    public final static String enumerate___repr___sig = 
        "($self, /)";

    public final static String enumerate___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String enumerate___setattr___sig = 
        "($self, name, value, /)";

    public final static String enumerate___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String enumerate___sizeof___sig = 
        "($self, /)";

    public final static String enumerate___str___doc = 
        "Return str(self).";

    public final static String enumerate___str___sig = 
        "($self, /)";

    public final static String enumerate___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'int'>
    public final static String int___abs___doc = 
        "abs(self)";

    public final static String int___abs___sig = 
        "($self, /)";

    public final static String int___add___doc = 
        "Return self+value.";

    public final static String int___add___sig = 
        "($self, value, /)";

    public final static String int___and___doc = 
        "Return self&value.";

    public final static String int___and___sig = 
        "($self, value, /)";

    public final static String int___bool___doc = 
        "self != 0";

    public final static String int___bool___sig = 
        "($self, /)";

    public final static String int___ceil___doc = 
        "Ceiling of an Integral returns itself.";

    public final static String int___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String int___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String int___delattr___sig = 
        "($self, name, /)";

    public final static String int___dir___doc = 
        "Default dir() implementation.";

    public final static String int___dir___sig = 
        "($self, /)";

    public final static String int___divmod___doc = 
        "Return divmod(self, value).";

    public final static String int___divmod___sig = 
        "($self, value, /)";

    public final static String int_doc = 
        "int([x]) -> integer\n" + 
        "int(x, base=10) -> integer\n" + 
        "\n" + 
        "Convert a number or string to an integer, or return 0 if no arguments\n" + 
        "are given.  If x is a number, return x.__int__().  For floating point\n" + 
        "numbers, this truncates towards zero.\n" + 
        "\n" + 
        "If x is not a number or if base is given, then x must be a string,\n" + 
        "bytes, or bytearray instance representing an integer literal in the\n" + 
        "given base.  The literal can be preceded by '+' or '-' and be surrounded\n" + 
        "by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n" + 
        "Base 0 means to interpret the base from the string as an integer literal.\n" + 
        ">>> int('0b100', base=0)\n" + 
        "4";

    public final static String int___eq___doc = 
        "Return self==value.";

    public final static String int___eq___sig = 
        "($self, value, /)";

    public final static String int___float___doc = 
        "float(self)";

    public final static String int___float___sig = 
        "($self, /)";

    public final static String int___floor___doc = 
        "Flooring an Integral returns itself.";

    public final static String int___floordiv___doc = 
        "Return self//value.";

    public final static String int___floordiv___sig = 
        "($self, value, /)";

    public final static String int___format___doc = 
        "";

    public final static String int___format___sig = 
        "($self, format_spec, /)";

    public final static String int___ge___doc = 
        "Return self>=value.";

    public final static String int___ge___sig = 
        "($self, value, /)";

    public final static String int___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String int___getattribute___sig = 
        "($self, name, /)";

    public final static String int___getnewargs___doc = 
        "";

    public final static String int___getnewargs___sig = 
        "($self, /)";

    public final static String int___gt___doc = 
        "Return self>value.";

    public final static String int___gt___sig = 
        "($self, value, /)";

    public final static String int___hash___doc = 
        "Return hash(self).";

    public final static String int___hash___sig = 
        "($self, /)";

    public final static String int___index___doc = 
        "Return self converted to an integer, if self is suitable for use as an index into a list.";

    public final static String int___index___sig = 
        "($self, /)";

    public final static String int___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String int___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String int___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String int___int___doc = 
        "int(self)";

    public final static String int___int___sig = 
        "($self, /)";

    public final static String int___invert___doc = 
        "~self";

    public final static String int___invert___sig = 
        "($self, /)";

    public final static String int___le___doc = 
        "Return self<=value.";

    public final static String int___le___sig = 
        "($self, value, /)";

    public final static String int___lshift___doc = 
        "Return self<<value.";

    public final static String int___lshift___sig = 
        "($self, value, /)";

    public final static String int___lt___doc = 
        "Return self<value.";

    public final static String int___lt___sig = 
        "($self, value, /)";

    public final static String int___mod___doc = 
        "Return self%value.";

    public final static String int___mod___sig = 
        "($self, value, /)";

    public final static String int___mul___doc = 
        "Return self*value.";

    public final static String int___mul___sig = 
        "($self, value, /)";

    public final static String int___ne___doc = 
        "Return self!=value.";

    public final static String int___ne___sig = 
        "($self, value, /)";

    public final static String int___neg___doc = 
        "-self";

    public final static String int___neg___sig = 
        "($self, /)";

    public final static String int___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String int___new___sig = 
        "($type, *args, **kwargs)";

    public final static String int___or___doc = 
        "Return self|value.";

    public final static String int___or___sig = 
        "($self, value, /)";

    public final static String int___pos___doc = 
        "+self";

    public final static String int___pos___sig = 
        "($self, /)";

    public final static String int___pow___doc = 
        "Return pow(self, value, mod).";

    public final static String int___pow___sig = 
        "($self, value, mod=None, /)";

    public final static String int___radd___doc = 
        "Return value+self.";

    public final static String int___radd___sig = 
        "($self, value, /)";

    public final static String int___rand___doc = 
        "Return value&self.";

    public final static String int___rand___sig = 
        "($self, value, /)";

    public final static String int___rdivmod___doc = 
        "Return divmod(value, self).";

    public final static String int___rdivmod___sig = 
        "($self, value, /)";

    public final static String int___reduce___doc = 
        "Helper for pickle.";

    public final static String int___reduce___sig = 
        "($self, /)";

    public final static String int___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String int___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String int___repr___doc = 
        "Return repr(self).";

    public final static String int___repr___sig = 
        "($self, /)";

    public final static String int___rfloordiv___doc = 
        "Return value//self.";

    public final static String int___rfloordiv___sig = 
        "($self, value, /)";

    public final static String int___rlshift___doc = 
        "Return value<<self.";

    public final static String int___rlshift___sig = 
        "($self, value, /)";

    public final static String int___rmod___doc = 
        "Return value%self.";

    public final static String int___rmod___sig = 
        "($self, value, /)";

    public final static String int___rmul___doc = 
        "Return value*self.";

    public final static String int___rmul___sig = 
        "($self, value, /)";

    public final static String int___ror___doc = 
        "Return value|self.";

    public final static String int___ror___sig = 
        "($self, value, /)";

    public final static String int___round___doc = 
        "Rounding an Integral returns itself.\n" + 
        "Rounding with an ndigits argument also returns an integer.";

    public final static String int___rpow___doc = 
        "Return pow(value, self, mod).";

    public final static String int___rpow___sig = 
        "($self, value, mod=None, /)";

    public final static String int___rrshift___doc = 
        "Return value>>self.";

    public final static String int___rrshift___sig = 
        "($self, value, /)";

    public final static String int___rshift___doc = 
        "Return self>>value.";

    public final static String int___rshift___sig = 
        "($self, value, /)";

    public final static String int___rsub___doc = 
        "Return value-self.";

    public final static String int___rsub___sig = 
        "($self, value, /)";

    public final static String int___rtruediv___doc = 
        "Return value/self.";

    public final static String int___rtruediv___sig = 
        "($self, value, /)";

    public final static String int___rxor___doc = 
        "Return value^self.";

    public final static String int___rxor___sig = 
        "($self, value, /)";

    public final static String int___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String int___setattr___sig = 
        "($self, name, value, /)";

    public final static String int___sizeof___doc = 
        "Returns size in memory, in bytes.";

    public final static String int___sizeof___sig = 
        "($self, /)";

    public final static String int___str___doc = 
        "Return str(self).";

    public final static String int___str___sig = 
        "($self, /)";

    public final static String int___sub___doc = 
        "Return self-value.";

    public final static String int___sub___sig = 
        "($self, value, /)";

    public final static String int___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String int___truediv___doc = 
        "Return self/value.";

    public final static String int___truediv___sig = 
        "($self, value, /)";

    public final static String int___trunc___doc = 
        "Truncating an Integral returns itself.";

    public final static String int___xor___doc = 
        "Return self^value.";

    public final static String int___xor___sig = 
        "($self, value, /)";

    public final static String int_bit_length_doc = 
        "Number of bits necessary to represent self in binary.\n" + 
        "\n" + 
        ">>> bin(37)\n" + 
        "'0b100101'\n" + 
        ">>> (37).bit_length()\n" + 
        "6";

    public final static String int_bit_length_sig = 
        "($self, /)";

    public final static String int_conjugate_doc = 
        "Returns self, the complex conjugate of any int.";

    public final static String int_from_bytes_doc = 
        "Return the integer represented by the given array of bytes.\n" + 
        "\n" + 
        "  bytes\n" + 
        "    Holds the array of bytes to convert.  The argument must either\n" + 
        "    support the buffer protocol or be an iterable object producing bytes.\n" + 
        "    Bytes and bytearray are examples of built-in objects that support the\n" + 
        "    buffer protocol.\n" + 
        "  byteorder\n" + 
        "    The byte order used to represent the integer.  If byteorder is 'big',\n" + 
        "    the most significant byte is at the beginning of the byte array.  If\n" + 
        "    byteorder is 'little', the most significant byte is at the end of the\n" + 
        "    byte array.  To request the native byte order of the host system, use\n" + 
        "    `sys.byteorder' as the byte order value.\n" + 
        "  signed\n" + 
        "    Indicates whether two's complement is used to represent the integer.";

    public final static String int_from_bytes_sig = 
        "($type, /, bytes, byteorder, *, signed=False)";

    public final static String int_to_bytes_doc = 
        "Return an array of bytes representing an integer.\n" + 
        "\n" + 
        "  length\n" + 
        "    Length of bytes object to use.  An OverflowError is raised if the\n" + 
        "    integer is not representable with the given number of bytes.\n" + 
        "  byteorder\n" + 
        "    The byte order used to represent the integer.  If byteorder is 'big',\n" + 
        "    the most significant byte is at the beginning of the byte array.  If\n" + 
        "    byteorder is 'little', the most significant byte is at the end of the\n" + 
        "    byte array.  To request the native byte order of the host system, use\n" + 
        "    `sys.byteorder' as the byte order value.\n" + 
        "  signed\n" + 
        "    Determines whether two's complement is used to represent the integer.\n" + 
        "    If signed is False and a negative integer is given, an OverflowError\n" + 
        "    is raised.";

    public final static String int_to_bytes_sig = 
        "($self, /, length, byteorder, *, signed=False)";

    // Docs for <class 'tuple'>
    public final static String tuple___add___doc = 
        "Return self+value.";

    public final static String tuple___add___sig = 
        "($self, value, /)";

    public final static String tuple___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String tuple___contains___doc = 
        "Return key in self.";

    public final static String tuple___contains___sig = 
        "($self, key, /)";

    public final static String tuple___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String tuple___delattr___sig = 
        "($self, name, /)";

    public final static String tuple___dir___doc = 
        "Default dir() implementation.";

    public final static String tuple___dir___sig = 
        "($self, /)";

    public final static String tuple_doc = 
        "Built-in immutable sequence.\n" + 
        "\n" + 
        "If no argument is given, the constructor returns an empty tuple.\n" + 
        "If iterable is specified the tuple is initialized from iterable's items.\n" + 
        "\n" + 
        "If the argument is a tuple, the return value is the same object.";

    public final static String tuple___eq___doc = 
        "Return self==value.";

    public final static String tuple___eq___sig = 
        "($self, value, /)";

    public final static String tuple___format___doc = 
        "Default object formatter.";

    public final static String tuple___format___sig = 
        "($self, format_spec, /)";

    public final static String tuple___ge___doc = 
        "Return self>=value.";

    public final static String tuple___ge___sig = 
        "($self, value, /)";

    public final static String tuple___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String tuple___getattribute___sig = 
        "($self, name, /)";

    public final static String tuple___getitem___doc = 
        "Return self[key].";

    public final static String tuple___getitem___sig = 
        "($self, key, /)";

    public final static String tuple___getnewargs___doc = 
        "";

    public final static String tuple___getnewargs___sig = 
        "($self, /)";

    public final static String tuple___gt___doc = 
        "Return self>value.";

    public final static String tuple___gt___sig = 
        "($self, value, /)";

    public final static String tuple___hash___doc = 
        "Return hash(self).";

    public final static String tuple___hash___sig = 
        "($self, /)";

    public final static String tuple___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String tuple___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String tuple___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String tuple___iter___doc = 
        "Implement iter(self).";

    public final static String tuple___iter___sig = 
        "($self, /)";

    public final static String tuple___le___doc = 
        "Return self<=value.";

    public final static String tuple___le___sig = 
        "($self, value, /)";

    public final static String tuple___len___doc = 
        "Return len(self).";

    public final static String tuple___len___sig = 
        "($self, /)";

    public final static String tuple___lt___doc = 
        "Return self<value.";

    public final static String tuple___lt___sig = 
        "($self, value, /)";

    public final static String tuple___mul___doc = 
        "Return self*value.n";

    public final static String tuple___mul___sig = 
        "($self, value, /)";

    public final static String tuple___ne___doc = 
        "Return self!=value.";

    public final static String tuple___ne___sig = 
        "($self, value, /)";

    public final static String tuple___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String tuple___new___sig = 
        "($type, *args, **kwargs)";

    public final static String tuple___reduce___doc = 
        "Helper for pickle.";

    public final static String tuple___reduce___sig = 
        "($self, /)";

    public final static String tuple___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String tuple___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String tuple___repr___doc = 
        "Return repr(self).";

    public final static String tuple___repr___sig = 
        "($self, /)";

    public final static String tuple___rmul___doc = 
        "Return self*value.";

    public final static String tuple___rmul___sig = 
        "($self, value, /)";

    public final static String tuple___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String tuple___setattr___sig = 
        "($self, name, value, /)";

    public final static String tuple___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String tuple___sizeof___sig = 
        "($self, /)";

    public final static String tuple___str___doc = 
        "Return str(self).";

    public final static String tuple___str___sig = 
        "($self, /)";

    public final static String tuple___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String tuple_count_doc = 
        "Return number of occurrences of value.";

    public final static String tuple_count_sig = 
        "($self, value, /)";

    public final static String tuple_index_doc = 
        "Return first index of value.\n" + 
        "\n" + 
        "Raises ValueError if the value is not present.";

    public final static String tuple_index_sig = 
        "($self, value, start=0, stop=sys.maxsize, /)";

    // Docs for <class 'str'>
    public final static String str___add___doc = 
        "Return self+value.";

    public final static String str___add___sig = 
        "($self, value, /)";

    public final static String str___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String str___contains___doc = 
        "Return key in self.";

    public final static String str___contains___sig = 
        "($self, key, /)";

    public final static String str___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String str___delattr___sig = 
        "($self, name, /)";

    public final static String str___dir___doc = 
        "Default dir() implementation.";

    public final static String str___dir___sig = 
        "($self, /)";

    public final static String str_doc = 
        "str(object='') -> str\n" + 
        "str(bytes_or_buffer[, encoding[, errors]]) -> str\n" + 
        "\n" + 
        "Create a new string object from the given object. If encoding or\n" + 
        "errors is specified, then the object must expose a data buffer\n" + 
        "that will be decoded using the given encoding and error handler.\n" + 
        "Otherwise, returns the result of object.__str__() (if defined)\n" + 
        "or repr(object).\n" + 
        "encoding defaults to sys.getdefaultencoding().\n" + 
        "errors defaults to 'strict'.";

    public final static String str___eq___doc = 
        "Return self==value.";

    public final static String str___eq___sig = 
        "($self, value, /)";

    public final static String str___format___doc = 
        "Return a formatted version of the string as described by format_spec.";

    public final static String str___format___sig = 
        "($self, format_spec, /)";

    public final static String str___ge___doc = 
        "Return self>=value.";

    public final static String str___ge___sig = 
        "($self, value, /)";

    public final static String str___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String str___getattribute___sig = 
        "($self, name, /)";

    public final static String str___getitem___doc = 
        "Return self[key].";

    public final static String str___getitem___sig = 
        "($self, key, /)";

    public final static String str___getnewargs___doc = 
        "";

    public final static String str___gt___doc = 
        "Return self>value.";

    public final static String str___gt___sig = 
        "($self, value, /)";

    public final static String str___hash___doc = 
        "Return hash(self).";

    public final static String str___hash___sig = 
        "($self, /)";

    public final static String str___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String str___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String str___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String str___iter___doc = 
        "Implement iter(self).";

    public final static String str___iter___sig = 
        "($self, /)";

    public final static String str___le___doc = 
        "Return self<=value.";

    public final static String str___le___sig = 
        "($self, value, /)";

    public final static String str___len___doc = 
        "Return len(self).";

    public final static String str___len___sig = 
        "($self, /)";

    public final static String str___lt___doc = 
        "Return self<value.";

    public final static String str___lt___sig = 
        "($self, value, /)";

    public final static String str___mod___doc = 
        "Return self%value.";

    public final static String str___mod___sig = 
        "($self, value, /)";

    public final static String str___mul___doc = 
        "Return self*value.n";

    public final static String str___mul___sig = 
        "($self, value, /)";

    public final static String str___ne___doc = 
        "Return self!=value.";

    public final static String str___ne___sig = 
        "($self, value, /)";

    public final static String str___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String str___new___sig = 
        "($type, *args, **kwargs)";

    public final static String str___reduce___doc = 
        "Helper for pickle.";

    public final static String str___reduce___sig = 
        "($self, /)";

    public final static String str___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String str___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String str___repr___doc = 
        "Return repr(self).";

    public final static String str___repr___sig = 
        "($self, /)";

    public final static String str___rmod___doc = 
        "Return value%self.";

    public final static String str___rmod___sig = 
        "($self, value, /)";

    public final static String str___rmul___doc = 
        "Return self*value.";

    public final static String str___rmul___sig = 
        "($self, value, /)";

    public final static String str___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String str___setattr___sig = 
        "($self, name, value, /)";

    public final static String str___sizeof___doc = 
        "Return the size of the string in memory, in bytes.";

    public final static String str___sizeof___sig = 
        "($self, /)";

    public final static String str___str___doc = 
        "Return str(self).";

    public final static String str___str___sig = 
        "($self, /)";

    public final static String str___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String str_capitalize_doc = 
        "Return a capitalized version of the string.\n" + 
        "\n" + 
        "More specifically, make the first character have upper case and the rest lower\n" + 
        "case.";

    public final static String str_capitalize_sig = 
        "($self, /)";

    public final static String str_casefold_doc = 
        "Return a version of the string suitable for caseless comparisons.";

    public final static String str_casefold_sig = 
        "($self, /)";

    public final static String str_center_doc = 
        "Return a centered string of length width.\n" + 
        "\n" + 
        "Padding is done using the specified fill character (default is a space).";

    public final static String str_center_sig = 
        "($self, width, fillchar=' ', /)";

    public final static String str_count_doc = 
        "S.count(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the number of non-overlapping occurrences of substring sub in\n" + 
        "string S[start:end].  Optional arguments start and end are\n" + 
        "interpreted as in slice notation.";

    public final static String str_encode_doc = 
        "Encode the string using the codec registered for encoding.\n" + 
        "\n" + 
        "  encoding\n" + 
        "    The encoding in which to encode the string.\n" + 
        "  errors\n" + 
        "    The error handling scheme to use for encoding errors.\n" + 
        "    The default is 'strict' meaning that encoding errors raise a\n" + 
        "    UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n" + 
        "    'xmlcharrefreplace' as well as any other name registered with\n" + 
        "    codecs.register_error that can handle UnicodeEncodeErrors.";

    public final static String str_encode_sig = 
        "($self, /, encoding='utf-8', errors='strict')";

    public final static String str_endswith_doc = 
        "S.endswith(suffix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S ends with the specified suffix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "suffix can also be a tuple of strings to try.";

    public final static String str_expandtabs_doc = 
        "Return a copy where all tab characters are expanded using spaces.\n" + 
        "\n" + 
        "If tabsize is not given, a tab size of 8 characters is assumed.";

    public final static String str_expandtabs_sig = 
        "($self, /, tabsize=8)";

    public final static String str_find_doc = 
        "S.find(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in S where substring sub is found,\n" + 
        "such that sub is contained within S[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String str_format_doc = 
        "S.format(*args, **kwargs) -> str\n" + 
        "\n" + 
        "Return a formatted version of S, using substitutions from args and kwargs.\n" + 
        "The substitutions are identified by braces ('{' and '}').";

    public final static String str_format_map_doc = 
        "S.format_map(mapping) -> str\n" + 
        "\n" + 
        "Return a formatted version of S, using substitutions from mapping.\n" + 
        "The substitutions are identified by braces ('{' and '}').";

    public final static String str_index_doc = 
        "S.index(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in S where substring sub is found, \n" + 
        "such that sub is contained within S[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Raises ValueError when the substring is not found.";

    public final static String str_isalnum_doc = 
        "Return True if the string is an alpha-numeric string, False otherwise.\n" + 
        "\n" + 
        "A string is alpha-numeric if all characters in the string are alpha-numeric and\n" + 
        "there is at least one character in the string.";

    public final static String str_isalnum_sig = 
        "($self, /)";

    public final static String str_isalpha_doc = 
        "Return True if the string is an alphabetic string, False otherwise.\n" + 
        "\n" + 
        "A string is alphabetic if all characters in the string are alphabetic and there\n" + 
        "is at least one character in the string.";

    public final static String str_isalpha_sig = 
        "($self, /)";

    public final static String str_isascii_doc = 
        "Return True if all characters in the string are ASCII, False otherwise.\n" + 
        "\n" + 
        "ASCII characters have code points in the range U+0000-U+007F.\n" + 
        "Empty string is ASCII too.";

    public final static String str_isascii_sig = 
        "($self, /)";

    public final static String str_isdecimal_doc = 
        "Return True if the string is a decimal string, False otherwise.\n" + 
        "\n" + 
        "A string is a decimal string if all characters in the string are decimal and\n" + 
        "there is at least one character in the string.";

    public final static String str_isdecimal_sig = 
        "($self, /)";

    public final static String str_isdigit_doc = 
        "Return True if the string is a digit string, False otherwise.\n" + 
        "\n" + 
        "A string is a digit string if all characters in the string are digits and there\n" + 
        "is at least one character in the string.";

    public final static String str_isdigit_sig = 
        "($self, /)";

    public final static String str_isidentifier_doc = 
        "Return True if the string is a valid Python identifier, False otherwise.\n" + 
        "\n" + 
        "Use keyword.iskeyword() to test for reserved identifiers such as \"def\" and\n" + 
        "\"class\".";

    public final static String str_isidentifier_sig = 
        "($self, /)";

    public final static String str_islower_doc = 
        "Return True if the string is a lowercase string, False otherwise.\n" + 
        "\n" + 
        "A string is lowercase if all cased characters in the string are lowercase and\n" + 
        "there is at least one cased character in the string.";

    public final static String str_islower_sig = 
        "($self, /)";

    public final static String str_isnumeric_doc = 
        "Return True if the string is a numeric string, False otherwise.\n" + 
        "\n" + 
        "A string is numeric if all characters in the string are numeric and there is at\n" + 
        "least one character in the string.";

    public final static String str_isnumeric_sig = 
        "($self, /)";

    public final static String str_isprintable_doc = 
        "Return True if the string is printable, False otherwise.\n" + 
        "\n" + 
        "A string is printable if all of its characters are considered printable in\n" + 
        "repr() or if it is empty.";

    public final static String str_isprintable_sig = 
        "($self, /)";

    public final static String str_isspace_doc = 
        "Return True if the string is a whitespace string, False otherwise.\n" + 
        "\n" + 
        "A string is whitespace if all characters in the string are whitespace and there\n" + 
        "is at least one character in the string.";

    public final static String str_isspace_sig = 
        "($self, /)";

    public final static String str_istitle_doc = 
        "Return True if the string is a title-cased string, False otherwise.\n" + 
        "\n" + 
        "In a title-cased string, upper- and title-case characters may only\n" + 
        "follow uncased characters and lowercase characters only cased ones.";

    public final static String str_istitle_sig = 
        "($self, /)";

    public final static String str_isupper_doc = 
        "Return True if the string is an uppercase string, False otherwise.\n" + 
        "\n" + 
        "A string is uppercase if all cased characters in the string are uppercase and\n" + 
        "there is at least one cased character in the string.";

    public final static String str_isupper_sig = 
        "($self, /)";

    public final static String str_join_doc = 
        "Concatenate any number of strings.\n" + 
        "\n" + 
        "The string whose method is called is inserted in between each given string.\n" + 
        "The result is returned as a new string.\n" + 
        "\n" + 
        "Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'";

    public final static String str_join_sig = 
        "($self, iterable, /)";

    public final static String str_ljust_doc = 
        "Return a left-justified string of length width.\n" + 
        "\n" + 
        "Padding is done using the specified fill character (default is a space).";

    public final static String str_ljust_sig = 
        "($self, width, fillchar=' ', /)";

    public final static String str_lower_doc = 
        "Return a copy of the string converted to lowercase.";

    public final static String str_lower_sig = 
        "($self, /)";

    public final static String str_lstrip_doc = 
        "Return a copy of the string with leading whitespace removed.\n" + 
        "\n" + 
        "If chars is given and not None, remove characters in chars instead.";

    public final static String str_lstrip_sig = 
        "($self, chars=None, /)";

    public final static String str_maketrans_doc = 
        "Return a translation table usable for str.translate().\n" + 
        "\n" + 
        "If there is only one argument, it must be a dictionary mapping Unicode\n" + 
        "ordinals (integers) or characters to Unicode ordinals, strings or None.\n" + 
        "Character keys will be then converted to ordinals.\n" + 
        "If there are two arguments, they must be strings of equal length, and\n" + 
        "in the resulting dictionary, each character in x will be mapped to the\n" + 
        "character at the same position in y. If there is a third argument, it\n" + 
        "must be a string, whose characters will be mapped to None in the result.";

    public final static String str_maketrans_sig = 
        "(x, y=None, z=None, /)";

    public final static String str_partition_doc = 
        "Partition the string into three parts using the given separator.\n" + 
        "\n" + 
        "This will search for the separator in the string.  If the separator is found,\n" + 
        "returns a 3-tuple containing the part before the separator, the separator\n" + 
        "itself, and the part after it.\n" + 
        "\n" + 
        "If the separator is not found, returns a 3-tuple containing the original string\n" + 
        "and two empty strings.";

    public final static String str_partition_sig = 
        "($self, sep, /)";

    public final static String str_replace_doc = 
        "Return a copy with all occurrences of substring old replaced by new.\n" + 
        "\n" + 
        "  count\n" + 
        "    Maximum number of occurrences to replace.\n" + 
        "    -1 (the default value) means replace all occurrences.\n" + 
        "\n" + 
        "If the optional argument count is given, only the first count occurrences are\n" + 
        "replaced.";

    public final static String str_replace_sig = 
        "($self, old, new, count=-1, /)";

    public final static String str_rfind_doc = 
        "S.rfind(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in S where substring sub is found,\n" + 
        "such that sub is contained within S[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String str_rindex_doc = 
        "S.rindex(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in S where substring sub is found,\n" + 
        "such that sub is contained within S[start:end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Raises ValueError when the substring is not found.";

    public final static String str_rjust_doc = 
        "Return a right-justified string of length width.\n" + 
        "\n" + 
        "Padding is done using the specified fill character (default is a space).";

    public final static String str_rjust_sig = 
        "($self, width, fillchar=' ', /)";

    public final static String str_rpartition_doc = 
        "Partition the string into three parts using the given separator.\n" + 
        "\n" + 
        "This will search for the separator in the string, starting at the end. If\n" + 
        "the separator is found, returns a 3-tuple containing the part before the\n" + 
        "separator, the separator itself, and the part after it.\n" + 
        "\n" + 
        "If the separator is not found, returns a 3-tuple containing two empty strings\n" + 
        "and the original string.";

    public final static String str_rpartition_sig = 
        "($self, sep, /)";

    public final static String str_rsplit_doc = 
        "Return a list of the words in the string, using sep as the delimiter string.\n" + 
        "\n" + 
        "  sep\n" + 
        "    The delimiter according which to split the string.\n" + 
        "    None (the default value) means split according to any whitespace,\n" + 
        "    and discard empty strings from the result.\n" + 
        "  maxsplit\n" + 
        "    Maximum number of splits to do.\n" + 
        "    -1 (the default value) means no limit.\n" + 
        "\n" + 
        "Splits are done starting at the end of the string and working to the front.";

    public final static String str_rsplit_sig = 
        "($self, /, sep=None, maxsplit=-1)";

    public final static String str_rstrip_doc = 
        "Return a copy of the string with trailing whitespace removed.\n" + 
        "\n" + 
        "If chars is given and not None, remove characters in chars instead.";

    public final static String str_rstrip_sig = 
        "($self, chars=None, /)";

    public final static String str_split_doc = 
        "Return a list of the words in the string, using sep as the delimiter string.\n" + 
        "\n" + 
        "  sep\n" + 
        "    The delimiter according which to split the string.\n" + 
        "    None (the default value) means split according to any whitespace,\n" + 
        "    and discard empty strings from the result.\n" + 
        "  maxsplit\n" + 
        "    Maximum number of splits to do.\n" + 
        "    -1 (the default value) means no limit.";

    public final static String str_split_sig = 
        "($self, /, sep=None, maxsplit=-1)";

    public final static String str_splitlines_doc = 
        "Return a list of the lines in the string, breaking at line boundaries.\n" + 
        "\n" + 
        "Line breaks are not included in the resulting list unless keepends is given and\n" + 
        "true.";

    public final static String str_splitlines_sig = 
        "($self, /, keepends=False)";

    public final static String str_startswith_doc = 
        "S.startswith(prefix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if S starts with the specified prefix, False otherwise.\n" + 
        "With optional start, test S beginning at that position.\n" + 
        "With optional end, stop comparing S at that position.\n" + 
        "prefix can also be a tuple of strings to try.";

    public final static String str_strip_doc = 
        "Return a copy of the string with leading and trailing whitespace remove.\n" + 
        "\n" + 
        "If chars is given and not None, remove characters in chars instead.";

    public final static String str_strip_sig = 
        "($self, chars=None, /)";

    public final static String str_swapcase_doc = 
        "Convert uppercase characters to lowercase and lowercase characters to uppercase.";

    public final static String str_swapcase_sig = 
        "($self, /)";

    public final static String str_title_doc = 
        "Return a version of the string where each word is titlecased.\n" + 
        "\n" + 
        "More specifically, words start with uppercased characters and all remaining\n" + 
        "cased characters have lower case.";

    public final static String str_title_sig = 
        "($self, /)";

    public final static String str_translate_doc = 
        "Replace each character in the string using the given translation table.\n" + 
        "\n" + 
        "  table\n" + 
        "    Translation table, which must be a mapping of Unicode ordinals to\n" + 
        "    Unicode ordinals, strings, or None.\n" + 
        "\n" + 
        "The table must implement lookup/indexing via __getitem__, for instance a\n" + 
        "dictionary or list.  If this operation raises LookupError, the character is\n" + 
        "left untouched.  Characters mapped to None are deleted.";

    public final static String str_translate_sig = 
        "($self, table, /)";

    public final static String str_upper_doc = 
        "Return a copy of the string converted to uppercase.";

    public final static String str_upper_sig = 
        "($self, /)";

    public final static String str_zfill_doc = 
        "Pad a numeric string with zeros on the left, to fill a field of the given width.\n" + 
        "\n" + 
        "The string is never truncated.";

    public final static String str_zfill_sig = 
        "($self, width, /)";

    // Docs for <class 'property'>
    public final static String property___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String property___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String property___delattr___sig = 
        "($self, name, /)";

    public final static String property___delete___doc = 
        "Delete an attribute of instance.";

    public final static String property___delete___sig = 
        "($self, instance, /)";

    public final static String property___dir___doc = 
        "Default dir() implementation.";

    public final static String property___dir___sig = 
        "($self, /)";

    public final static String property_doc = 
        "Property attribute.\n" + 
        "\n" + 
        "  fget\n" + 
        "    function to be used for getting an attribute value\n" + 
        "  fset\n" + 
        "    function to be used for setting an attribute value\n" + 
        "  fdel\n" + 
        "    function to be used for del'ing an attribute\n" + 
        "  doc\n" + 
        "    docstring\n" + 
        "\n" + 
        "Typical use is to define a managed attribute x:\n" + 
        "\n" + 
        "class C(object):\n" + 
        "    def getx(self): return self._x\n" + 
        "    def setx(self, value): self._x = value\n" + 
        "    def delx(self): del self._x\n" + 
        "    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n" + 
        "\n" + 
        "Decorators make defining new properties or modifying existing ones easy:\n" + 
        "\n" + 
        "class C(object):\n" + 
        "    @property\n" + 
        "    def x(self):\n" + 
        "        \"I am the 'x' property.\"\n" + 
        "        return self._x\n" + 
        "    @x.setter\n" + 
        "    def x(self, value):\n" + 
        "        self._x = value\n" + 
        "    @x.deleter\n" + 
        "    def x(self):\n" + 
        "        del self._x";

    public final static String property___eq___doc = 
        "Return self==value.";

    public final static String property___eq___sig = 
        "($self, value, /)";

    public final static String property___format___doc = 
        "Default object formatter.";

    public final static String property___format___sig = 
        "($self, format_spec, /)";

    public final static String property___ge___doc = 
        "Return self>=value.";

    public final static String property___ge___sig = 
        "($self, value, /)";

    public final static String property___get___doc = 
        "Return an attribute of instance, which is of type owner.";

    public final static String property___get___sig = 
        "($self, instance, owner, /)";

    public final static String property___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String property___getattribute___sig = 
        "($self, name, /)";

    public final static String property___gt___doc = 
        "Return self>value.";

    public final static String property___gt___sig = 
        "($self, value, /)";

    public final static String property___hash___doc = 
        "Return hash(self).";

    public final static String property___hash___sig = 
        "($self, /)";

    public final static String property___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String property___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String property___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String property___le___doc = 
        "Return self<=value.";

    public final static String property___le___sig = 
        "($self, value, /)";

    public final static String property___lt___doc = 
        "Return self<value.";

    public final static String property___lt___sig = 
        "($self, value, /)";

    public final static String property___ne___doc = 
        "Return self!=value.";

    public final static String property___ne___sig = 
        "($self, value, /)";

    public final static String property___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String property___new___sig = 
        "($type, *args, **kwargs)";

    public final static String property___reduce___doc = 
        "Helper for pickle.";

    public final static String property___reduce___sig = 
        "($self, /)";

    public final static String property___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String property___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String property___repr___doc = 
        "Return repr(self).";

    public final static String property___repr___sig = 
        "($self, /)";

    public final static String property___set___doc = 
        "Set an attribute of instance to value.";

    public final static String property___set___sig = 
        "($self, instance, value, /)";

    public final static String property___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String property___setattr___sig = 
        "($self, name, value, /)";

    public final static String property___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String property___sizeof___sig = 
        "($self, /)";

    public final static String property___str___doc = 
        "Return str(self).";

    public final static String property___str___sig = 
        "($self, /)";

    public final static String property___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String property_deleter_doc = 
        "Descriptor to change the deleter on a property.";

    public final static String property_getter_doc = 
        "Descriptor to change the getter on a property.";

    public final static String property_setter_doc = 
        "Descriptor to change the setter on a property.";

    // Docs for <class 'range'>
    public final static String range___bool___doc = 
        "self != 0";

    public final static String range___bool___sig = 
        "($self, /)";

    public final static String range___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String range___contains___doc = 
        "Return key in self.";

    public final static String range___contains___sig = 
        "($self, key, /)";

    public final static String range___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String range___delattr___sig = 
        "($self, name, /)";

    public final static String range___dir___doc = 
        "Default dir() implementation.";

    public final static String range___dir___sig = 
        "($self, /)";

    public final static String range_doc = 
        "range(stop) -> range object\n" + 
        "range(start, stop[, step]) -> range object\n" + 
        "\n" + 
        "Return an object that produces a sequence of integers from start (inclusive)\n" + 
        "to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\n" + 
        "start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\n" + 
        "These are exactly the valid indices for a list of 4 elements.\n" + 
        "When step is given, it specifies the increment (or decrement).";

    public final static String range___eq___doc = 
        "Return self==value.";

    public final static String range___eq___sig = 
        "($self, value, /)";

    public final static String range___format___doc = 
        "Default object formatter.";

    public final static String range___format___sig = 
        "($self, format_spec, /)";

    public final static String range___ge___doc = 
        "Return self>=value.";

    public final static String range___ge___sig = 
        "($self, value, /)";

    public final static String range___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String range___getattribute___sig = 
        "($self, name, /)";

    public final static String range___getitem___doc = 
        "Return self[key].";

    public final static String range___getitem___sig = 
        "($self, key, /)";

    public final static String range___gt___doc = 
        "Return self>value.";

    public final static String range___gt___sig = 
        "($self, value, /)";

    public final static String range___hash___doc = 
        "Return hash(self).";

    public final static String range___hash___sig = 
        "($self, /)";

    public final static String range___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String range___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String range___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String range___iter___doc = 
        "Implement iter(self).";

    public final static String range___iter___sig = 
        "($self, /)";

    public final static String range___le___doc = 
        "Return self<=value.";

    public final static String range___le___sig = 
        "($self, value, /)";

    public final static String range___len___doc = 
        "Return len(self).";

    public final static String range___len___sig = 
        "($self, /)";

    public final static String range___lt___doc = 
        "Return self<value.";

    public final static String range___lt___sig = 
        "($self, value, /)";

    public final static String range___ne___doc = 
        "Return self!=value.";

    public final static String range___ne___sig = 
        "($self, value, /)";

    public final static String range___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String range___new___sig = 
        "($type, *args, **kwargs)";

    public final static String range___reduce___doc = 
        "";

    public final static String range___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String range___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String range___repr___doc = 
        "Return repr(self).";

    public final static String range___repr___sig = 
        "($self, /)";

    public final static String range___reversed___doc = 
        "Return a reverse iterator.";

    public final static String range___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String range___setattr___sig = 
        "($self, name, value, /)";

    public final static String range___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String range___sizeof___sig = 
        "($self, /)";

    public final static String range___str___doc = 
        "Return str(self).";

    public final static String range___str___sig = 
        "($self, /)";

    public final static String range___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String range_count_doc = 
        "rangeobject.count(value) -> integer -- return number of occurrences of value";

    public final static String range_index_doc = 
        "rangeobject.index(value, [start, [stop]]) -> integer -- return index of value.\n" + 
        "Raise ValueError if the value is not present.";

    // Docs for <class 'complex'>
    public final static String complex___abs___doc = 
        "abs(self)";

    public final static String complex___abs___sig = 
        "($self, /)";

    public final static String complex___add___doc = 
        "Return self+value.";

    public final static String complex___add___sig = 
        "($self, value, /)";

    public final static String complex___bool___doc = 
        "self != 0";

    public final static String complex___bool___sig = 
        "($self, /)";

    public final static String complex___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String complex___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String complex___delattr___sig = 
        "($self, name, /)";

    public final static String complex___dir___doc = 
        "Default dir() implementation.";

    public final static String complex___dir___sig = 
        "($self, /)";

    public final static String complex___divmod___doc = 
        "Return divmod(self, value).";

    public final static String complex___divmod___sig = 
        "($self, value, /)";

    public final static String complex_doc = 
        "Create a complex number from a real part and an optional imaginary part.\n" + 
        "\n" + 
        "This is equivalent to (real + imag*1j) where imag defaults to 0.";

    public final static String complex___eq___doc = 
        "Return self==value.";

    public final static String complex___eq___sig = 
        "($self, value, /)";

    public final static String complex___float___doc = 
        "float(self)";

    public final static String complex___float___sig = 
        "($self, /)";

    public final static String complex___floordiv___doc = 
        "Return self//value.";

    public final static String complex___floordiv___sig = 
        "($self, value, /)";

    public final static String complex___format___doc = 
        "complex.__format__() -> str\n" + 
        "\n" + 
        "Convert to a string according to format_spec.";

    public final static String complex___ge___doc = 
        "Return self>=value.";

    public final static String complex___ge___sig = 
        "($self, value, /)";

    public final static String complex___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String complex___getattribute___sig = 
        "($self, name, /)";

    public final static String complex___getnewargs___doc = 
        "";

    public final static String complex___gt___doc = 
        "Return self>value.";

    public final static String complex___gt___sig = 
        "($self, value, /)";

    public final static String complex___hash___doc = 
        "Return hash(self).";

    public final static String complex___hash___sig = 
        "($self, /)";

    public final static String complex___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String complex___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String complex___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String complex___int___doc = 
        "int(self)";

    public final static String complex___int___sig = 
        "($self, /)";

    public final static String complex___le___doc = 
        "Return self<=value.";

    public final static String complex___le___sig = 
        "($self, value, /)";

    public final static String complex___lt___doc = 
        "Return self<value.";

    public final static String complex___lt___sig = 
        "($self, value, /)";

    public final static String complex___mod___doc = 
        "Return self%value.";

    public final static String complex___mod___sig = 
        "($self, value, /)";

    public final static String complex___mul___doc = 
        "Return self*value.";

    public final static String complex___mul___sig = 
        "($self, value, /)";

    public final static String complex___ne___doc = 
        "Return self!=value.";

    public final static String complex___ne___sig = 
        "($self, value, /)";

    public final static String complex___neg___doc = 
        "-self";

    public final static String complex___neg___sig = 
        "($self, /)";

    public final static String complex___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String complex___new___sig = 
        "($type, *args, **kwargs)";

    public final static String complex___pos___doc = 
        "+self";

    public final static String complex___pos___sig = 
        "($self, /)";

    public final static String complex___pow___doc = 
        "Return pow(self, value, mod).";

    public final static String complex___pow___sig = 
        "($self, value, mod=None, /)";

    public final static String complex___radd___doc = 
        "Return value+self.";

    public final static String complex___radd___sig = 
        "($self, value, /)";

    public final static String complex___rdivmod___doc = 
        "Return divmod(value, self).";

    public final static String complex___rdivmod___sig = 
        "($self, value, /)";

    public final static String complex___reduce___doc = 
        "Helper for pickle.";

    public final static String complex___reduce___sig = 
        "($self, /)";

    public final static String complex___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String complex___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String complex___repr___doc = 
        "Return repr(self).";

    public final static String complex___repr___sig = 
        "($self, /)";

    public final static String complex___rfloordiv___doc = 
        "Return value//self.";

    public final static String complex___rfloordiv___sig = 
        "($self, value, /)";

    public final static String complex___rmod___doc = 
        "Return value%self.";

    public final static String complex___rmod___sig = 
        "($self, value, /)";

    public final static String complex___rmul___doc = 
        "Return value*self.";

    public final static String complex___rmul___sig = 
        "($self, value, /)";

    public final static String complex___rpow___doc = 
        "Return pow(value, self, mod).";

    public final static String complex___rpow___sig = 
        "($self, value, mod=None, /)";

    public final static String complex___rsub___doc = 
        "Return value-self.";

    public final static String complex___rsub___sig = 
        "($self, value, /)";

    public final static String complex___rtruediv___doc = 
        "Return value/self.";

    public final static String complex___rtruediv___sig = 
        "($self, value, /)";

    public final static String complex___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String complex___setattr___sig = 
        "($self, name, value, /)";

    public final static String complex___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String complex___sizeof___sig = 
        "($self, /)";

    public final static String complex___str___doc = 
        "Return str(self).";

    public final static String complex___str___sig = 
        "($self, /)";

    public final static String complex___sub___doc = 
        "Return self-value.";

    public final static String complex___sub___sig = 
        "($self, value, /)";

    public final static String complex___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String complex___truediv___doc = 
        "Return self/value.";

    public final static String complex___truediv___sig = 
        "($self, value, /)";

    public final static String complex_conjugate_doc = 
        "complex.conjugate() -> complex\n" + 
        "\n" + 
        "Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.";

    // Docs for <class 'bool'>
    public final static String bool___abs___doc = 
        "abs(self)";

    public final static String bool___abs___sig = 
        "($self, /)";

    public final static String bool___add___doc = 
        "Return self+value.";

    public final static String bool___add___sig = 
        "($self, value, /)";

    public final static String bool___and___doc = 
        "Return self&value.";

    public final static String bool___and___sig = 
        "($self, value, /)";

    public final static String bool___bool___doc = 
        "self != 0";

    public final static String bool___bool___sig = 
        "($self, /)";

    public final static String bool___ceil___doc = 
        "Ceiling of an Integral returns itself.";

    public final static String bool___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String bool___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String bool___delattr___sig = 
        "($self, name, /)";

    public final static String bool___dir___doc = 
        "Default dir() implementation.";

    public final static String bool___dir___sig = 
        "($self, /)";

    public final static String bool___divmod___doc = 
        "Return divmod(self, value).";

    public final static String bool___divmod___sig = 
        "($self, value, /)";

    public final static String bool_doc = 
        "bool(x) -> bool\n" + 
        "\n" + 
        "Returns True when the argument x is true, False otherwise.\n" + 
        "The builtins True and False are the only two instances of the class bool.\n" + 
        "The class bool is a subclass of the class int, and cannot be subclassed.";

    public final static String bool___eq___doc = 
        "Return self==value.";

    public final static String bool___eq___sig = 
        "($self, value, /)";

    public final static String bool___float___doc = 
        "float(self)";

    public final static String bool___float___sig = 
        "($self, /)";

    public final static String bool___floor___doc = 
        "Flooring an Integral returns itself.";

    public final static String bool___floordiv___doc = 
        "Return self//value.";

    public final static String bool___floordiv___sig = 
        "($self, value, /)";

    public final static String bool___format___doc = 
        "";

    public final static String bool___format___sig = 
        "($self, format_spec, /)";

    public final static String bool___ge___doc = 
        "Return self>=value.";

    public final static String bool___ge___sig = 
        "($self, value, /)";

    public final static String bool___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String bool___getattribute___sig = 
        "($self, name, /)";

    public final static String bool___getnewargs___doc = 
        "";

    public final static String bool___getnewargs___sig = 
        "($self, /)";

    public final static String bool___gt___doc = 
        "Return self>value.";

    public final static String bool___gt___sig = 
        "($self, value, /)";

    public final static String bool___hash___doc = 
        "Return hash(self).";

    public final static String bool___hash___sig = 
        "($self, /)";

    public final static String bool___index___doc = 
        "Return self converted to an integer, if self is suitable for use as an index into a list.";

    public final static String bool___index___sig = 
        "($self, /)";

    public final static String bool___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String bool___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String bool___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String bool___int___doc = 
        "int(self)";

    public final static String bool___int___sig = 
        "($self, /)";

    public final static String bool___invert___doc = 
        "~self";

    public final static String bool___invert___sig = 
        "($self, /)";

    public final static String bool___le___doc = 
        "Return self<=value.";

    public final static String bool___le___sig = 
        "($self, value, /)";

    public final static String bool___lshift___doc = 
        "Return self<<value.";

    public final static String bool___lshift___sig = 
        "($self, value, /)";

    public final static String bool___lt___doc = 
        "Return self<value.";

    public final static String bool___lt___sig = 
        "($self, value, /)";

    public final static String bool___mod___doc = 
        "Return self%value.";

    public final static String bool___mod___sig = 
        "($self, value, /)";

    public final static String bool___mul___doc = 
        "Return self*value.";

    public final static String bool___mul___sig = 
        "($self, value, /)";

    public final static String bool___ne___doc = 
        "Return self!=value.";

    public final static String bool___ne___sig = 
        "($self, value, /)";

    public final static String bool___neg___doc = 
        "-self";

    public final static String bool___neg___sig = 
        "($self, /)";

    public final static String bool___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String bool___new___sig = 
        "($type, *args, **kwargs)";

    public final static String bool___or___doc = 
        "Return self|value.";

    public final static String bool___or___sig = 
        "($self, value, /)";

    public final static String bool___pos___doc = 
        "+self";

    public final static String bool___pos___sig = 
        "($self, /)";

    public final static String bool___pow___doc = 
        "Return pow(self, value, mod).";

    public final static String bool___pow___sig = 
        "($self, value, mod=None, /)";

    public final static String bool___radd___doc = 
        "Return value+self.";

    public final static String bool___radd___sig = 
        "($self, value, /)";

    public final static String bool___rand___doc = 
        "Return value&self.";

    public final static String bool___rand___sig = 
        "($self, value, /)";

    public final static String bool___rdivmod___doc = 
        "Return divmod(value, self).";

    public final static String bool___rdivmod___sig = 
        "($self, value, /)";

    public final static String bool___reduce___doc = 
        "Helper for pickle.";

    public final static String bool___reduce___sig = 
        "($self, /)";

    public final static String bool___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String bool___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String bool___repr___doc = 
        "Return repr(self).";

    public final static String bool___repr___sig = 
        "($self, /)";

    public final static String bool___rfloordiv___doc = 
        "Return value//self.";

    public final static String bool___rfloordiv___sig = 
        "($self, value, /)";

    public final static String bool___rlshift___doc = 
        "Return value<<self.";

    public final static String bool___rlshift___sig = 
        "($self, value, /)";

    public final static String bool___rmod___doc = 
        "Return value%self.";

    public final static String bool___rmod___sig = 
        "($self, value, /)";

    public final static String bool___rmul___doc = 
        "Return value*self.";

    public final static String bool___rmul___sig = 
        "($self, value, /)";

    public final static String bool___ror___doc = 
        "Return value|self.";

    public final static String bool___ror___sig = 
        "($self, value, /)";

    public final static String bool___round___doc = 
        "Rounding an Integral returns itself.\n" + 
        "Rounding with an ndigits argument also returns an integer.";

    public final static String bool___rpow___doc = 
        "Return pow(value, self, mod).";

    public final static String bool___rpow___sig = 
        "($self, value, mod=None, /)";

    public final static String bool___rrshift___doc = 
        "Return value>>self.";

    public final static String bool___rrshift___sig = 
        "($self, value, /)";

    public final static String bool___rshift___doc = 
        "Return self>>value.";

    public final static String bool___rshift___sig = 
        "($self, value, /)";

    public final static String bool___rsub___doc = 
        "Return value-self.";

    public final static String bool___rsub___sig = 
        "($self, value, /)";

    public final static String bool___rtruediv___doc = 
        "Return value/self.";

    public final static String bool___rtruediv___sig = 
        "($self, value, /)";

    public final static String bool___rxor___doc = 
        "Return value^self.";

    public final static String bool___rxor___sig = 
        "($self, value, /)";

    public final static String bool___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String bool___setattr___sig = 
        "($self, name, value, /)";

    public final static String bool___sizeof___doc = 
        "Returns size in memory, in bytes.";

    public final static String bool___sizeof___sig = 
        "($self, /)";

    public final static String bool___str___doc = 
        "Return str(self).";

    public final static String bool___str___sig = 
        "($self, /)";

    public final static String bool___sub___doc = 
        "Return self-value.";

    public final static String bool___sub___sig = 
        "($self, value, /)";

    public final static String bool___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String bool___truediv___doc = 
        "Return self/value.";

    public final static String bool___truediv___sig = 
        "($self, value, /)";

    public final static String bool___trunc___doc = 
        "Truncating an Integral returns itself.";

    public final static String bool___xor___doc = 
        "Return self^value.";

    public final static String bool___xor___sig = 
        "($self, value, /)";

    public final static String bool_bit_length_doc = 
        "Number of bits necessary to represent self in binary.\n" + 
        "\n" + 
        ">>> bin(37)\n" + 
        "'0b100101'\n" + 
        ">>> (37).bit_length()\n" + 
        "6";

    public final static String bool_bit_length_sig = 
        "($self, /)";

    public final static String bool_conjugate_doc = 
        "Returns self, the complex conjugate of any int.";

    public final static String bool_from_bytes_doc = 
        "Return the integer represented by the given array of bytes.\n" + 
        "\n" + 
        "  bytes\n" + 
        "    Holds the array of bytes to convert.  The argument must either\n" + 
        "    support the buffer protocol or be an iterable object producing bytes.\n" + 
        "    Bytes and bytearray are examples of built-in objects that support the\n" + 
        "    buffer protocol.\n" + 
        "  byteorder\n" + 
        "    The byte order used to represent the integer.  If byteorder is 'big',\n" + 
        "    the most significant byte is at the beginning of the byte array.  If\n" + 
        "    byteorder is 'little', the most significant byte is at the end of the\n" + 
        "    byte array.  To request the native byte order of the host system, use\n" + 
        "    `sys.byteorder' as the byte order value.\n" + 
        "  signed\n" + 
        "    Indicates whether two's complement is used to represent the integer.";

    public final static String bool_from_bytes_sig = 
        "($type, /, bytes, byteorder, *, signed=False)";

    public final static String bool_to_bytes_doc = 
        "Return an array of bytes representing an integer.\n" + 
        "\n" + 
        "  length\n" + 
        "    Length of bytes object to use.  An OverflowError is raised if the\n" + 
        "    integer is not representable with the given number of bytes.\n" + 
        "  byteorder\n" + 
        "    The byte order used to represent the integer.  If byteorder is 'big',\n" + 
        "    the most significant byte is at the beginning of the byte array.  If\n" + 
        "    byteorder is 'little', the most significant byte is at the end of the\n" + 
        "    byte array.  To request the native byte order of the host system, use\n" + 
        "    `sys.byteorder' as the byte order value.\n" + 
        "  signed\n" + 
        "    Determines whether two's complement is used to represent the integer.\n" + 
        "    If signed is False and a negative integer is given, an OverflowError\n" + 
        "    is raised.";

    public final static String bool_to_bytes_sig = 
        "($self, /, length, byteorder, *, signed=False)";

    // Docs for <class 'classmethod'>
    public final static String classmethod___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String classmethod___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String classmethod___delattr___sig = 
        "($self, name, /)";

    public final static String classmethod___dir___doc = 
        "Default dir() implementation.";

    public final static String classmethod___dir___sig = 
        "($self, /)";

    public final static String classmethod_doc = 
        "classmethod(function) -> method\n" + 
        "\n" + 
        "Convert a function to be a class method.\n" + 
        "\n" + 
        "A class method receives the class as implicit first argument,\n" + 
        "just like an instance method receives the instance.\n" + 
        "To declare a class method, use this idiom:\n" + 
        "\n" + 
        "  class C:\n" + 
        "      @classmethod\n" + 
        "      def f(cls, arg1, arg2, ...):\n" + 
        "          ...\n" + 
        "\n" + 
        "It can be called either on the class (e.g. C.f()) or on an instance\n" + 
        "(e.g. C().f()).  The instance is ignored except for its class.\n" + 
        "If a class method is called for a derived class, the derived class\n" + 
        "object is passed as the implied first argument.\n" + 
        "\n" + 
        "Class methods are different than C++ or Java static methods.\n" + 
        "If you want those, see the staticmethod builtin.";

    public final static String classmethod___eq___doc = 
        "Return self==value.";

    public final static String classmethod___eq___sig = 
        "($self, value, /)";

    public final static String classmethod___format___doc = 
        "Default object formatter.";

    public final static String classmethod___format___sig = 
        "($self, format_spec, /)";

    public final static String classmethod___ge___doc = 
        "Return self>=value.";

    public final static String classmethod___ge___sig = 
        "($self, value, /)";

    public final static String classmethod___get___doc = 
        "Return an attribute of instance, which is of type owner.";

    public final static String classmethod___get___sig = 
        "($self, instance, owner, /)";

    public final static String classmethod___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String classmethod___getattribute___sig = 
        "($self, name, /)";

    public final static String classmethod___gt___doc = 
        "Return self>value.";

    public final static String classmethod___gt___sig = 
        "($self, value, /)";

    public final static String classmethod___hash___doc = 
        "Return hash(self).";

    public final static String classmethod___hash___sig = 
        "($self, /)";

    public final static String classmethod___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String classmethod___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String classmethod___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String classmethod___le___doc = 
        "Return self<=value.";

    public final static String classmethod___le___sig = 
        "($self, value, /)";

    public final static String classmethod___lt___doc = 
        "Return self<value.";

    public final static String classmethod___lt___sig = 
        "($self, value, /)";

    public final static String classmethod___ne___doc = 
        "Return self!=value.";

    public final static String classmethod___ne___sig = 
        "($self, value, /)";

    public final static String classmethod___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String classmethod___new___sig = 
        "($type, *args, **kwargs)";

    public final static String classmethod___reduce___doc = 
        "Helper for pickle.";

    public final static String classmethod___reduce___sig = 
        "($self, /)";

    public final static String classmethod___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String classmethod___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String classmethod___repr___doc = 
        "Return repr(self).";

    public final static String classmethod___repr___sig = 
        "($self, /)";

    public final static String classmethod___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String classmethod___setattr___sig = 
        "($self, name, value, /)";

    public final static String classmethod___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String classmethod___sizeof___sig = 
        "($self, /)";

    public final static String classmethod___str___doc = 
        "Return str(self).";

    public final static String classmethod___str___sig = 
        "($self, /)";

    public final static String classmethod___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'set'>
    public final static String set___and___doc = 
        "Return self&value.";

    public final static String set___and___sig = 
        "($self, value, /)";

    public final static String set___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String set___contains___doc = 
        "x.__contains__(y) <==> y in x.";

    public final static String set___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String set___delattr___sig = 
        "($self, name, /)";

    public final static String set___dir___doc = 
        "Default dir() implementation.";

    public final static String set___dir___sig = 
        "($self, /)";

    public final static String set_doc = 
        "set() -> new empty set object\n" + 
        "set(iterable) -> new set object\n" + 
        "\n" + 
        "Build an unordered collection of unique elements.";

    public final static String set___eq___doc = 
        "Return self==value.";

    public final static String set___eq___sig = 
        "($self, value, /)";

    public final static String set___format___doc = 
        "Default object formatter.";

    public final static String set___format___sig = 
        "($self, format_spec, /)";

    public final static String set___ge___doc = 
        "Return self>=value.";

    public final static String set___ge___sig = 
        "($self, value, /)";

    public final static String set___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String set___getattribute___sig = 
        "($self, name, /)";

    public final static String set___gt___doc = 
        "Return self>value.";

    public final static String set___gt___sig = 
        "($self, value, /)";

    public final static String set___iand___doc = 
        "Return self&=value.";

    public final static String set___iand___sig = 
        "($self, value, /)";

    public final static String set___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String set___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String set___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String set___ior___doc = 
        "Return self|=value.";

    public final static String set___ior___sig = 
        "($self, value, /)";

    public final static String set___isub___doc = 
        "Return self-=value.";

    public final static String set___isub___sig = 
        "($self, value, /)";

    public final static String set___iter___doc = 
        "Implement iter(self).";

    public final static String set___iter___sig = 
        "($self, /)";

    public final static String set___ixor___doc = 
        "Return self^=value.";

    public final static String set___ixor___sig = 
        "($self, value, /)";

    public final static String set___le___doc = 
        "Return self<=value.";

    public final static String set___le___sig = 
        "($self, value, /)";

    public final static String set___len___doc = 
        "Return len(self).";

    public final static String set___len___sig = 
        "($self, /)";

    public final static String set___lt___doc = 
        "Return self<value.";

    public final static String set___lt___sig = 
        "($self, value, /)";

    public final static String set___ne___doc = 
        "Return self!=value.";

    public final static String set___ne___sig = 
        "($self, value, /)";

    public final static String set___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String set___new___sig = 
        "($type, *args, **kwargs)";

    public final static String set___or___doc = 
        "Return self|value.";

    public final static String set___or___sig = 
        "($self, value, /)";

    public final static String set___rand___doc = 
        "Return value&self.";

    public final static String set___rand___sig = 
        "($self, value, /)";

    public final static String set___reduce___doc = 
        "Return state information for pickling.";

    public final static String set___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String set___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String set___repr___doc = 
        "Return repr(self).";

    public final static String set___repr___sig = 
        "($self, /)";

    public final static String set___ror___doc = 
        "Return value|self.";

    public final static String set___ror___sig = 
        "($self, value, /)";

    public final static String set___rsub___doc = 
        "Return value-self.";

    public final static String set___rsub___sig = 
        "($self, value, /)";

    public final static String set___rxor___doc = 
        "Return value^self.";

    public final static String set___rxor___sig = 
        "($self, value, /)";

    public final static String set___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String set___setattr___sig = 
        "($self, name, value, /)";

    public final static String set___sizeof___doc = 
        "S.__sizeof__() -> size of S in memory, in bytes";

    public final static String set___str___doc = 
        "Return str(self).";

    public final static String set___str___sig = 
        "($self, /)";

    public final static String set___sub___doc = 
        "Return self-value.";

    public final static String set___sub___sig = 
        "($self, value, /)";

    public final static String set___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String set___xor___doc = 
        "Return self^value.";

    public final static String set___xor___sig = 
        "($self, value, /)";

    public final static String set_add_doc = 
        "Add an element to a set.\n" + 
        "\n" + 
        "This has no effect if the element is already present.";

    public final static String set_clear_doc = 
        "Remove all elements from this set.";

    public final static String set_copy_doc = 
        "Return a shallow copy of a set.";

    public final static String set_difference_doc = 
        "Return the difference of two or more sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in this set but not the others.)";

    public final static String set_difference_update_doc = 
        "Remove all elements of another set from this set.";

    public final static String set_discard_doc = 
        "Remove an element from a set if it is a member.\n" + 
        "\n" + 
        "If the element is not a member, do nothing.";

    public final static String set_intersection_doc = 
        "Return the intersection of two sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in both sets.)";

    public final static String set_intersection_update_doc = 
        "Update a set with the intersection of itself and another.";

    public final static String set_isdisjoint_doc = 
        "Return True if two sets have a null intersection.";

    public final static String set_issubset_doc = 
        "Report whether another set contains this set.";

    public final static String set_issuperset_doc = 
        "Report whether this set contains another set.";

    public final static String set_pop_doc = 
        "Remove and return an arbitrary set element.\n" + 
        "Raises KeyError if the set is empty.";

    public final static String set_remove_doc = 
        "Remove an element from a set; it must be a member.\n" + 
        "\n" + 
        "If the element is not a member, raise a KeyError.";

    public final static String set_symmetric_difference_doc = 
        "Return the symmetric difference of two sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in exactly one of the sets.)";

    public final static String set_symmetric_difference_update_doc = 
        "Update a set with the symmetric difference of itself and another.";

    public final static String set_union_doc = 
        "Return the union of sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in either set.)";

    public final static String set_update_doc = 
        "Update a set with the union of itself and others.";

    // Docs for <class 'frozenset'>
    public final static String frozenset___and___doc = 
        "Return self&value.";

    public final static String frozenset___and___sig = 
        "($self, value, /)";

    public final static String frozenset___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String frozenset___contains___doc = 
        "x.__contains__(y) <==> y in x.";

    public final static String frozenset___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String frozenset___delattr___sig = 
        "($self, name, /)";

    public final static String frozenset___dir___doc = 
        "Default dir() implementation.";

    public final static String frozenset___dir___sig = 
        "($self, /)";

    public final static String frozenset_doc = 
        "frozenset() -> empty frozenset object\n" + 
        "frozenset(iterable) -> frozenset object\n" + 
        "\n" + 
        "Build an immutable unordered collection of unique elements.";

    public final static String frozenset___eq___doc = 
        "Return self==value.";

    public final static String frozenset___eq___sig = 
        "($self, value, /)";

    public final static String frozenset___format___doc = 
        "Default object formatter.";

    public final static String frozenset___format___sig = 
        "($self, format_spec, /)";

    public final static String frozenset___ge___doc = 
        "Return self>=value.";

    public final static String frozenset___ge___sig = 
        "($self, value, /)";

    public final static String frozenset___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String frozenset___getattribute___sig = 
        "($self, name, /)";

    public final static String frozenset___gt___doc = 
        "Return self>value.";

    public final static String frozenset___gt___sig = 
        "($self, value, /)";

    public final static String frozenset___hash___doc = 
        "Return hash(self).";

    public final static String frozenset___hash___sig = 
        "($self, /)";

    public final static String frozenset___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String frozenset___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String frozenset___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String frozenset___iter___doc = 
        "Implement iter(self).";

    public final static String frozenset___iter___sig = 
        "($self, /)";

    public final static String frozenset___le___doc = 
        "Return self<=value.";

    public final static String frozenset___le___sig = 
        "($self, value, /)";

    public final static String frozenset___len___doc = 
        "Return len(self).";

    public final static String frozenset___len___sig = 
        "($self, /)";

    public final static String frozenset___lt___doc = 
        "Return self<value.";

    public final static String frozenset___lt___sig = 
        "($self, value, /)";

    public final static String frozenset___ne___doc = 
        "Return self!=value.";

    public final static String frozenset___ne___sig = 
        "($self, value, /)";

    public final static String frozenset___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String frozenset___new___sig = 
        "($type, *args, **kwargs)";

    public final static String frozenset___or___doc = 
        "Return self|value.";

    public final static String frozenset___or___sig = 
        "($self, value, /)";

    public final static String frozenset___rand___doc = 
        "Return value&self.";

    public final static String frozenset___rand___sig = 
        "($self, value, /)";

    public final static String frozenset___reduce___doc = 
        "Return state information for pickling.";

    public final static String frozenset___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String frozenset___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String frozenset___repr___doc = 
        "Return repr(self).";

    public final static String frozenset___repr___sig = 
        "($self, /)";

    public final static String frozenset___ror___doc = 
        "Return value|self.";

    public final static String frozenset___ror___sig = 
        "($self, value, /)";

    public final static String frozenset___rsub___doc = 
        "Return value-self.";

    public final static String frozenset___rsub___sig = 
        "($self, value, /)";

    public final static String frozenset___rxor___doc = 
        "Return value^self.";

    public final static String frozenset___rxor___sig = 
        "($self, value, /)";

    public final static String frozenset___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String frozenset___setattr___sig = 
        "($self, name, value, /)";

    public final static String frozenset___sizeof___doc = 
        "S.__sizeof__() -> size of S in memory, in bytes";

    public final static String frozenset___str___doc = 
        "Return str(self).";

    public final static String frozenset___str___sig = 
        "($self, /)";

    public final static String frozenset___sub___doc = 
        "Return self-value.";

    public final static String frozenset___sub___sig = 
        "($self, value, /)";

    public final static String frozenset___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String frozenset___xor___doc = 
        "Return self^value.";

    public final static String frozenset___xor___sig = 
        "($self, value, /)";

    public final static String frozenset_copy_doc = 
        "Return a shallow copy of a set.";

    public final static String frozenset_difference_doc = 
        "Return the difference of two or more sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in this set but not the others.)";

    public final static String frozenset_intersection_doc = 
        "Return the intersection of two sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in both sets.)";

    public final static String frozenset_isdisjoint_doc = 
        "Return True if two sets have a null intersection.";

    public final static String frozenset_issubset_doc = 
        "Report whether another set contains this set.";

    public final static String frozenset_issuperset_doc = 
        "Report whether this set contains another set.";

    public final static String frozenset_symmetric_difference_doc = 
        "Return the symmetric difference of two sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in exactly one of the sets.)";

    public final static String frozenset_union_doc = 
        "Return the union of sets as a new set.\n" + 
        "\n" + 
        "(i.e. all elements that are in either set.)";

    // Docs for <class 'BaseException'>
    public final static String BaseException___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String BaseException___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String BaseException___delattr___sig = 
        "($self, name, /)";

    public final static String BaseException___dir___doc = 
        "Default dir() implementation.";

    public final static String BaseException___dir___sig = 
        "($self, /)";

    public final static String BaseException_doc = 
        "Common base class for all exceptions";

    public final static String BaseException___eq___doc = 
        "Return self==value.";

    public final static String BaseException___eq___sig = 
        "($self, value, /)";

    public final static String BaseException___format___doc = 
        "Default object formatter.";

    public final static String BaseException___format___sig = 
        "($self, format_spec, /)";

    public final static String BaseException___ge___doc = 
        "Return self>=value.";

    public final static String BaseException___ge___sig = 
        "($self, value, /)";

    public final static String BaseException___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String BaseException___getattribute___sig = 
        "($self, name, /)";

    public final static String BaseException___gt___doc = 
        "Return self>value.";

    public final static String BaseException___gt___sig = 
        "($self, value, /)";

    public final static String BaseException___hash___doc = 
        "Return hash(self).";

    public final static String BaseException___hash___sig = 
        "($self, /)";

    public final static String BaseException___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String BaseException___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String BaseException___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String BaseException___le___doc = 
        "Return self<=value.";

    public final static String BaseException___le___sig = 
        "($self, value, /)";

    public final static String BaseException___lt___doc = 
        "Return self<value.";

    public final static String BaseException___lt___sig = 
        "($self, value, /)";

    public final static String BaseException___ne___doc = 
        "Return self!=value.";

    public final static String BaseException___ne___sig = 
        "($self, value, /)";

    public final static String BaseException___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String BaseException___new___sig = 
        "($type, *args, **kwargs)";

    public final static String BaseException___reduce___doc = 
        "";

    public final static String BaseException___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String BaseException___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String BaseException___repr___doc = 
        "Return repr(self).";

    public final static String BaseException___repr___sig = 
        "($self, /)";

    public final static String BaseException___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String BaseException___setattr___sig = 
        "($self, name, value, /)";

    public final static String BaseException___setstate___doc = 
        "";

    public final static String BaseException___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String BaseException___sizeof___sig = 
        "($self, /)";

    public final static String BaseException___str___doc = 
        "Return str(self).";

    public final static String BaseException___str___sig = 
        "($self, /)";

    public final static String BaseException___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String BaseException_with_traceback_doc = 
        "Exception.with_traceback(tb) --\n" + 
        "    set self.__traceback__ to tb and return self.";

    // Docs for <class 'bytearray'>
    public final static String bytearray___add___doc = 
        "Return self+value.";

    public final static String bytearray___add___sig = 
        "($self, value, /)";

    public final static String bytearray___alloc___doc = 
        "B.__alloc__() -> int\n" + 
        "\n" + 
        "Return the number of bytes actually allocated.";

    public final static String bytearray___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String bytearray___contains___doc = 
        "Return key in self.";

    public final static String bytearray___contains___sig = 
        "($self, key, /)";

    public final static String bytearray___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String bytearray___delattr___sig = 
        "($self, name, /)";

    public final static String bytearray___delitem___doc = 
        "Delete self[key].";

    public final static String bytearray___delitem___sig = 
        "($self, key, /)";

    public final static String bytearray___dir___doc = 
        "Default dir() implementation.";

    public final static String bytearray___dir___sig = 
        "($self, /)";

    public final static String bytearray_doc = 
        "bytearray(iterable_of_ints) -> bytearray\n" + 
        "bytearray(string, encoding[, errors]) -> bytearray\n" + 
        "bytearray(bytes_or_buffer) -> mutable copy of bytes_or_buffer\n" + 
        "bytearray(int) -> bytes array of size given by the parameter initialized with null bytes\n" + 
        "bytearray() -> empty bytes array\n" + 
        "\n" + 
        "Construct a mutable bytearray object from:\n" + 
        "  - an iterable yielding integers in range(256)\n" + 
        "  - a text string encoded using the specified encoding\n" + 
        "  - a bytes or a buffer object\n" + 
        "  - any object implementing the buffer API.\n" + 
        "  - an integer";

    public final static String bytearray___eq___doc = 
        "Return self==value.";

    public final static String bytearray___eq___sig = 
        "($self, value, /)";

    public final static String bytearray___format___doc = 
        "Default object formatter.";

    public final static String bytearray___format___sig = 
        "($self, format_spec, /)";

    public final static String bytearray___ge___doc = 
        "Return self>=value.";

    public final static String bytearray___ge___sig = 
        "($self, value, /)";

    public final static String bytearray___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String bytearray___getattribute___sig = 
        "($self, name, /)";

    public final static String bytearray___getitem___doc = 
        "Return self[key].";

    public final static String bytearray___getitem___sig = 
        "($self, key, /)";

    public final static String bytearray___gt___doc = 
        "Return self>value.";

    public final static String bytearray___gt___sig = 
        "($self, value, /)";

    public final static String bytearray___iadd___doc = 
        "Implement self+=value.";

    public final static String bytearray___iadd___sig = 
        "($self, value, /)";

    public final static String bytearray___imul___doc = 
        "Implement self*=value.";

    public final static String bytearray___imul___sig = 
        "($self, value, /)";

    public final static String bytearray___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String bytearray___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String bytearray___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String bytearray___iter___doc = 
        "Implement iter(self).";

    public final static String bytearray___iter___sig = 
        "($self, /)";

    public final static String bytearray___le___doc = 
        "Return self<=value.";

    public final static String bytearray___le___sig = 
        "($self, value, /)";

    public final static String bytearray___len___doc = 
        "Return len(self).";

    public final static String bytearray___len___sig = 
        "($self, /)";

    public final static String bytearray___lt___doc = 
        "Return self<value.";

    public final static String bytearray___lt___sig = 
        "($self, value, /)";

    public final static String bytearray___mod___doc = 
        "Return self%value.";

    public final static String bytearray___mod___sig = 
        "($self, value, /)";

    public final static String bytearray___mul___doc = 
        "Return self*value.n";

    public final static String bytearray___mul___sig = 
        "($self, value, /)";

    public final static String bytearray___ne___doc = 
        "Return self!=value.";

    public final static String bytearray___ne___sig = 
        "($self, value, /)";

    public final static String bytearray___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String bytearray___new___sig = 
        "($type, *args, **kwargs)";

    public final static String bytearray___reduce___doc = 
        "Return state information for pickling.";

    public final static String bytearray___reduce___sig = 
        "($self, /)";

    public final static String bytearray___reduce_ex___doc = 
        "Return state information for pickling.";

    public final static String bytearray___reduce_ex___sig = 
        "($self, proto=0, /)";

    public final static String bytearray___repr___doc = 
        "Return repr(self).";

    public final static String bytearray___repr___sig = 
        "($self, /)";

    public final static String bytearray___rmod___doc = 
        "Return value%self.";

    public final static String bytearray___rmod___sig = 
        "($self, value, /)";

    public final static String bytearray___rmul___doc = 
        "Return self*value.";

    public final static String bytearray___rmul___sig = 
        "($self, value, /)";

    public final static String bytearray___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String bytearray___setattr___sig = 
        "($self, name, value, /)";

    public final static String bytearray___setitem___doc = 
        "Set self[key] to value.";

    public final static String bytearray___setitem___sig = 
        "($self, key, value, /)";

    public final static String bytearray___sizeof___doc = 
        "Returns the size of the bytearray object in memory, in bytes.";

    public final static String bytearray___sizeof___sig = 
        "($self, /)";

    public final static String bytearray___str___doc = 
        "Return str(self).";

    public final static String bytearray___str___sig = 
        "($self, /)";

    public final static String bytearray___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String bytearray_append_doc = 
        "Append a single item to the end of the bytearray.\n" + 
        "\n" + 
        "  item\n" + 
        "    The item to be appended.";

    public final static String bytearray_append_sig = 
        "($self, item, /)";

    public final static String bytearray_capitalize_doc = 
        "B.capitalize() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with only its first character capitalized (ASCII)\n" + 
        "and the rest lower-cased.";

    public final static String bytearray_center_doc = 
        "B.center(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B centered in a string of length width.  Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String bytearray_clear_doc = 
        "Remove all items from the bytearray.";

    public final static String bytearray_clear_sig = 
        "($self, /)";

    public final static String bytearray_copy_doc = 
        "Return a copy of B.";

    public final static String bytearray_copy_sig = 
        "($self, /)";

    public final static String bytearray_count_doc = 
        "B.count(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the number of non-overlapping occurrences of subsection sub in\n" + 
        "bytes B[start:end].  Optional arguments start and end are interpreted\n" + 
        "as in slice notation.";

    public final static String bytearray_decode_doc = 
        "Decode the bytearray using the codec registered for encoding.\n" + 
        "\n" + 
        "  encoding\n" + 
        "    The encoding with which to decode the bytearray.\n" + 
        "  errors\n" + 
        "    The error handling scheme to use for the handling of decoding errors.\n" + 
        "    The default is 'strict' meaning that decoding errors raise a\n" + 
        "    UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n" + 
        "    as well as any other name registered with codecs.register_error that\n" + 
        "    can handle UnicodeDecodeErrors.";

    public final static String bytearray_decode_sig = 
        "($self, /, encoding='utf-8', errors='strict')";

    public final static String bytearray_endswith_doc = 
        "B.endswith(suffix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if B ends with the specified suffix, False otherwise.\n" + 
        "With optional start, test B beginning at that position.\n" + 
        "With optional end, stop comparing B at that position.\n" + 
        "suffix can also be a tuple of bytes to try.";

    public final static String bytearray_expandtabs_doc = 
        "B.expandtabs(tabsize=8) -> copy of B\n" + 
        "\n" + 
        "Return a copy of B where all tab characters are expanded using spaces.\n" + 
        "If tabsize is not given, a tab size of 8 characters is assumed.";

    public final static String bytearray_extend_doc = 
        "Append all the items from the iterator or sequence to the end of the bytearray.\n" + 
        "\n" + 
        "  iterable_of_ints\n" + 
        "    The iterable of items to append.";

    public final static String bytearray_extend_sig = 
        "($self, iterable_of_ints, /)";

    public final static String bytearray_find_doc = 
        "B.find(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in B where subsection sub is found,\n" + 
        "such that sub is contained within B[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String bytearray_fromhex_doc = 
        "Create a bytearray object from a string of hexadecimal numbers.\n" + 
        "\n" + 
        "Spaces between two numbers are accepted.\n" + 
        "Example: bytearray.fromhex('B9 01EF') -> bytearray(b'\\\\xb9\\\\x01\\\\xef')";

    public final static String bytearray_fromhex_sig = 
        "($type, string, /)";

    public final static String bytearray_hex_doc = 
        "B.hex() -> string\n" + 
        "\n" + 
        "Create a string of hexadecimal numbers from a bytearray object.\n" + 
        "Example: bytearray([0xb9, 0x01, 0xef]).hex() -> 'b901ef'.";

    public final static String bytearray_index_doc = 
        "B.index(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the lowest index in B where subsection sub is found,\n" + 
        "such that sub is contained within B[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Raises ValueError when the subsection is not found.";

    public final static String bytearray_insert_doc = 
        "Insert a single item into the bytearray before the given index.\n" + 
        "\n" + 
        "  index\n" + 
        "    The index where the value is to be inserted.\n" + 
        "  item\n" + 
        "    The item to be inserted.";

    public final static String bytearray_insert_sig = 
        "($self, index, item, /)";

    public final static String bytearray_isalnum_doc = 
        "B.isalnum() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are alphanumeric\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_isalpha_doc = 
        "B.isalpha() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are alphabetic\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_isascii_doc = 
        "B.isascii() -> bool\n" + 
        "\n" + 
        "Return True if B is empty or all characters in B are ASCII,\n" + 
        "False otherwise.";

    public final static String bytearray_isdigit_doc = 
        "B.isdigit() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are digits\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_islower_doc = 
        "B.islower() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in B are lowercase and there is\n" + 
        "at least one cased character in B, False otherwise.";

    public final static String bytearray_isspace_doc = 
        "B.isspace() -> bool\n" + 
        "\n" + 
        "Return True if all characters in B are whitespace\n" + 
        "and there is at least one character in B, False otherwise.";

    public final static String bytearray_istitle_doc = 
        "B.istitle() -> bool\n" + 
        "\n" + 
        "Return True if B is a titlecased string and there is at least one\n" + 
        "character in B, i.e. uppercase characters may only follow uncased\n" + 
        "characters and lowercase characters only cased ones. Return False\n" + 
        "otherwise.";

    public final static String bytearray_isupper_doc = 
        "B.isupper() -> bool\n" + 
        "\n" + 
        "Return True if all cased characters in B are uppercase and there is\n" + 
        "at least one cased character in B, False otherwise.";

    public final static String bytearray_join_doc = 
        "Concatenate any number of bytes/bytearray objects.\n" + 
        "\n" + 
        "The bytearray whose method is called is inserted in between each pair.\n" + 
        "\n" + 
        "The result is returned as a new bytearray object.";

    public final static String bytearray_join_sig = 
        "($self, iterable_of_bytes, /)";

    public final static String bytearray_ljust_doc = 
        "B.ljust(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B left justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space).";

    public final static String bytearray_lower_doc = 
        "B.lower() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with all ASCII characters converted to lowercase.";

    public final static String bytearray_lstrip_doc = 
        "Strip leading bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip leading ASCII whitespace.";

    public final static String bytearray_lstrip_sig = 
        "($self, bytes=None, /)";

    public final static String bytearray_maketrans_doc = 
        "Return a translation table useable for the bytes or bytearray translate method.\n" + 
        "\n" + 
        "The returned table will be one where each byte in frm is mapped to the byte at\n" + 
        "the same position in to.\n" + 
        "\n" + 
        "The bytes objects frm and to must be of the same length.";

    public final static String bytearray_maketrans_sig = 
        "(frm, to, /)";

    public final static String bytearray_partition_doc = 
        "Partition the bytearray into three parts using the given separator.\n" + 
        "\n" + 
        "This will search for the separator sep in the bytearray. If the separator is\n" + 
        "found, returns a 3-tuple containing the part before the separator, the\n" + 
        "separator itself, and the part after it as new bytearray objects.\n" + 
        "\n" + 
        "If the separator is not found, returns a 3-tuple containing the copy of the\n" + 
        "original bytearray object and two empty bytearray objects.";

    public final static String bytearray_partition_sig = 
        "($self, sep, /)";

    public final static String bytearray_pop_doc = 
        "Remove and return a single item from B.\n" + 
        "\n" + 
        "  index\n" + 
        "    The index from where to remove the item.\n" + 
        "    -1 (the default value) means remove the last item.\n" + 
        "\n" + 
        "If no index argument is given, will pop the last item.";

    public final static String bytearray_pop_sig = 
        "($self, index=-1, /)";

    public final static String bytearray_remove_doc = 
        "Remove the first occurrence of a value in the bytearray.\n" + 
        "\n" + 
        "  value\n" + 
        "    The value to remove.";

    public final static String bytearray_remove_sig = 
        "($self, value, /)";

    public final static String bytearray_replace_doc = 
        "Return a copy with all occurrences of substring old replaced by new.\n" + 
        "\n" + 
        "  count\n" + 
        "    Maximum number of occurrences to replace.\n" + 
        "    -1 (the default value) means replace all occurrences.\n" + 
        "\n" + 
        "If the optional argument count is given, only the first count occurrences are\n" + 
        "replaced.";

    public final static String bytearray_replace_sig = 
        "($self, old, new, count=-1, /)";

    public final static String bytearray_reverse_doc = 
        "Reverse the order of the values in B in place.";

    public final static String bytearray_reverse_sig = 
        "($self, /)";

    public final static String bytearray_rfind_doc = 
        "B.rfind(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in B where subsection sub is found,\n" + 
        "such that sub is contained within B[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Return -1 on failure.";

    public final static String bytearray_rindex_doc = 
        "B.rindex(sub[, start[, end]]) -> int\n" + 
        "\n" + 
        "Return the highest index in B where subsection sub is found,\n" + 
        "such that sub is contained within B[start,end].  Optional\n" + 
        "arguments start and end are interpreted as in slice notation.\n" + 
        "\n" + 
        "Raise ValueError when the subsection is not found.";

    public final static String bytearray_rjust_doc = 
        "B.rjust(width[, fillchar]) -> copy of B\n" + 
        "\n" + 
        "Return B right justified in a string of length width. Padding is\n" + 
        "done using the specified fill character (default is a space)";

    public final static String bytearray_rpartition_doc = 
        "Partition the bytearray into three parts using the given separator.\n" + 
        "\n" + 
        "This will search for the separator sep in the bytearray, starting at the end.\n" + 
        "If the separator is found, returns a 3-tuple containing the part before the\n" + 
        "separator, the separator itself, and the part after it as new bytearray\n" + 
        "objects.\n" + 
        "\n" + 
        "If the separator is not found, returns a 3-tuple containing two empty bytearray\n" + 
        "objects and the copy of the original bytearray object.";

    public final static String bytearray_rpartition_sig = 
        "($self, sep, /)";

    public final static String bytearray_rsplit_doc = 
        "Return a list of the sections in the bytearray, using sep as the delimiter.\n" + 
        "\n" + 
        "  sep\n" + 
        "    The delimiter according which to split the bytearray.\n" + 
        "    None (the default value) means split on ASCII whitespace characters\n" + 
        "    (space, tab, return, newline, formfeed, vertical tab).\n" + 
        "  maxsplit\n" + 
        "    Maximum number of splits to do.\n" + 
        "    -1 (the default value) means no limit.\n" + 
        "\n" + 
        "Splitting is done starting at the end of the bytearray and working to the front.";

    public final static String bytearray_rsplit_sig = 
        "($self, /, sep=None, maxsplit=-1)";

    public final static String bytearray_rstrip_doc = 
        "Strip trailing bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip trailing ASCII whitespace.";

    public final static String bytearray_rstrip_sig = 
        "($self, bytes=None, /)";

    public final static String bytearray_split_doc = 
        "Return a list of the sections in the bytearray, using sep as the delimiter.\n" + 
        "\n" + 
        "  sep\n" + 
        "    The delimiter according which to split the bytearray.\n" + 
        "    None (the default value) means split on ASCII whitespace characters\n" + 
        "    (space, tab, return, newline, formfeed, vertical tab).\n" + 
        "  maxsplit\n" + 
        "    Maximum number of splits to do.\n" + 
        "    -1 (the default value) means no limit.";

    public final static String bytearray_split_sig = 
        "($self, /, sep=None, maxsplit=-1)";

    public final static String bytearray_splitlines_doc = 
        "Return a list of the lines in the bytearray, breaking at line boundaries.\n" + 
        "\n" + 
        "Line breaks are not included in the resulting list unless keepends is given and\n" + 
        "true.";

    public final static String bytearray_splitlines_sig = 
        "($self, /, keepends=False)";

    public final static String bytearray_startswith_doc = 
        "B.startswith(prefix[, start[, end]]) -> bool\n" + 
        "\n" + 
        "Return True if B starts with the specified prefix, False otherwise.\n" + 
        "With optional start, test B beginning at that position.\n" + 
        "With optional end, stop comparing B at that position.\n" + 
        "prefix can also be a tuple of bytes to try.";

    public final static String bytearray_strip_doc = 
        "Strip leading and trailing bytes contained in the argument.\n" + 
        "\n" + 
        "If the argument is omitted or None, strip leading and trailing ASCII whitespace.";

    public final static String bytearray_strip_sig = 
        "($self, bytes=None, /)";

    public final static String bytearray_swapcase_doc = 
        "B.swapcase() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with uppercase ASCII characters converted\n" + 
        "to lowercase ASCII and vice versa.";

    public final static String bytearray_title_doc = 
        "B.title() -> copy of B\n" + 
        "\n" + 
        "Return a titlecased version of B, i.e. ASCII words start with uppercase\n" + 
        "characters, all remaining cased characters have lowercase.";

    public final static String bytearray_translate_doc = 
        "Return a copy with each character mapped by the given translation table.\n" + 
        "\n" + 
        "  table\n" + 
        "    Translation table, which must be a bytes object of length 256.\n" + 
        "\n" + 
        "All characters occurring in the optional argument delete are removed.\n" + 
        "The remaining characters are mapped through the given translation table.";

    public final static String bytearray_translate_sig = 
        "($self, table, /, delete=b'')";

    public final static String bytearray_upper_doc = 
        "B.upper() -> copy of B\n" + 
        "\n" + 
        "Return a copy of B with all ASCII characters converted to uppercase.";

    public final static String bytearray_zfill_doc = 
        "B.zfill(width) -> copy of B\n" + 
        "\n" + 
        "Pad a numeric string B with zeros on the left, to fill a field\n" + 
        "of the specified width.  B is never truncated.";

    // Docs for <class 'memoryview'>
    public final static String memoryview___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String memoryview___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String memoryview___delattr___sig = 
        "($self, name, /)";

    public final static String memoryview___delitem___doc = 
        "Delete self[key].";

    public final static String memoryview___delitem___sig = 
        "($self, key, /)";

    public final static String memoryview___dir___doc = 
        "Default dir() implementation.";

    public final static String memoryview___dir___sig = 
        "($self, /)";

    public final static String memoryview_doc = 
        "Create a new memoryview object which references the given object.";

    public final static String memoryview___enter___doc = 
        "";

    public final static String memoryview___eq___doc = 
        "Return self==value.";

    public final static String memoryview___eq___sig = 
        "($self, value, /)";

    public final static String memoryview___exit___doc = 
        "";

    public final static String memoryview___format___doc = 
        "Default object formatter.";

    public final static String memoryview___format___sig = 
        "($self, format_spec, /)";

    public final static String memoryview___ge___doc = 
        "Return self>=value.";

    public final static String memoryview___ge___sig = 
        "($self, value, /)";

    public final static String memoryview___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String memoryview___getattribute___sig = 
        "($self, name, /)";

    public final static String memoryview___getitem___doc = 
        "Return self[key].";

    public final static String memoryview___getitem___sig = 
        "($self, key, /)";

    public final static String memoryview___gt___doc = 
        "Return self>value.";

    public final static String memoryview___gt___sig = 
        "($self, value, /)";

    public final static String memoryview___hash___doc = 
        "Return hash(self).";

    public final static String memoryview___hash___sig = 
        "($self, /)";

    public final static String memoryview___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String memoryview___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String memoryview___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String memoryview___le___doc = 
        "Return self<=value.";

    public final static String memoryview___le___sig = 
        "($self, value, /)";

    public final static String memoryview___len___doc = 
        "Return len(self).";

    public final static String memoryview___len___sig = 
        "($self, /)";

    public final static String memoryview___lt___doc = 
        "Return self<value.";

    public final static String memoryview___lt___sig = 
        "($self, value, /)";

    public final static String memoryview___ne___doc = 
        "Return self!=value.";

    public final static String memoryview___ne___sig = 
        "($self, value, /)";

    public final static String memoryview___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String memoryview___new___sig = 
        "($type, *args, **kwargs)";

    public final static String memoryview___reduce___doc = 
        "Helper for pickle.";

    public final static String memoryview___reduce___sig = 
        "($self, /)";

    public final static String memoryview___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String memoryview___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String memoryview___repr___doc = 
        "Return repr(self).";

    public final static String memoryview___repr___sig = 
        "($self, /)";

    public final static String memoryview___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String memoryview___setattr___sig = 
        "($self, name, value, /)";

    public final static String memoryview___setitem___doc = 
        "Set self[key] to value.";

    public final static String memoryview___setitem___sig = 
        "($self, key, value, /)";

    public final static String memoryview___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String memoryview___sizeof___sig = 
        "($self, /)";

    public final static String memoryview___str___doc = 
        "Return str(self).";

    public final static String memoryview___str___sig = 
        "($self, /)";

    public final static String memoryview___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String memoryview_cast_doc = 
        "Cast a memoryview to a new format or shape.";

    public final static String memoryview_cast_sig = 
        "($self, /, format, *, shape)";

    public final static String memoryview_hex_doc = 
        "Return the data in the buffer as a string of hexadecimal numbers.";

    public final static String memoryview_hex_sig = 
        "($self, /)";

    public final static String memoryview_release_doc = 
        "Release the underlying buffer exposed by the memoryview object.";

    public final static String memoryview_release_sig = 
        "($self, /)";

    public final static String memoryview_tobytes_doc = 
        "Return the data in the buffer as a byte string.";

    public final static String memoryview_tobytes_sig = 
        "($self, /)";

    public final static String memoryview_tolist_doc = 
        "Return the data in the buffer as a list of elements.";

    public final static String memoryview_tolist_sig = 
        "($self, /)";

    // Docs for <class 'generator'>
    public final static String generator___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String generator___del___doc = 
        "";

    public final static String generator___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String generator___delattr___sig = 
        "($self, name, /)";

    public final static String generator___dir___doc = 
        "Default dir() implementation.";

    public final static String generator___dir___sig = 
        "($self, /)";

    public final static String generator_doc = 
        "";

    public final static String generator___eq___doc = 
        "Return self==value.";

    public final static String generator___eq___sig = 
        "($self, value, /)";

    public final static String generator___format___doc = 
        "Default object formatter.";

    public final static String generator___format___sig = 
        "($self, format_spec, /)";

    public final static String generator___ge___doc = 
        "Return self>=value.";

    public final static String generator___ge___sig = 
        "($self, value, /)";

    public final static String generator___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String generator___getattribute___sig = 
        "($self, name, /)";

    public final static String generator___gt___doc = 
        "Return self>value.";

    public final static String generator___gt___sig = 
        "($self, value, /)";

    public final static String generator___hash___doc = 
        "Return hash(self).";

    public final static String generator___hash___sig = 
        "($self, /)";

    public final static String generator___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String generator___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String generator___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String generator___iter___doc = 
        "Implement iter(self).";

    public final static String generator___iter___sig = 
        "($self, /)";

    public final static String generator___le___doc = 
        "Return self<=value.";

    public final static String generator___le___sig = 
        "($self, value, /)";

    public final static String generator___lt___doc = 
        "Return self<value.";

    public final static String generator___lt___sig = 
        "($self, value, /)";

    public final static String generator___ne___doc = 
        "Return self!=value.";

    public final static String generator___ne___sig = 
        "($self, value, /)";

    public final static String generator___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String generator___new___sig = 
        "($type, *args, **kwargs)";

    public final static String generator___next___doc = 
        "Implement next(self).";

    public final static String generator___next___sig = 
        "($self, /)";

    public final static String generator___reduce___doc = 
        "Helper for pickle.";

    public final static String generator___reduce___sig = 
        "($self, /)";

    public final static String generator___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String generator___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String generator___repr___doc = 
        "Return repr(self).";

    public final static String generator___repr___sig = 
        "($self, /)";

    public final static String generator___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String generator___setattr___sig = 
        "($self, name, value, /)";

    public final static String generator___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String generator___sizeof___sig = 
        "($self, /)";

    public final static String generator___str___doc = 
        "Return str(self).";

    public final static String generator___str___sig = 
        "($self, /)";

    public final static String generator___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String generator_close_doc = 
        "close() -> raise GeneratorExit inside generator.";

    public final static String generator_send_doc = 
        "send(arg) -> send 'arg' into generator,\n" + 
        "return next yielded value or raise StopIteration.";

    public final static String generator_throw_doc = 
        "throw(typ[,val[,tb]]) -> raise exception in generator,\n" + 
        "return next yielded value or raise StopIteration.";

    // Docs for <class 'coroutine'>
    public final static String coroutine___await___doc = 
        "Return an iterator to be used in await expression.";

    public final static String coroutine___await___sig = 
        "($self, /)";

    public final static String coroutine___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String coroutine___del___doc = 
        "";

    public final static String coroutine___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String coroutine___delattr___sig = 
        "($self, name, /)";

    public final static String coroutine___dir___doc = 
        "Default dir() implementation.";

    public final static String coroutine___dir___sig = 
        "($self, /)";

    public final static String coroutine_doc = 
        "";

    public final static String coroutine___eq___doc = 
        "Return self==value.";

    public final static String coroutine___eq___sig = 
        "($self, value, /)";

    public final static String coroutine___format___doc = 
        "Default object formatter.";

    public final static String coroutine___format___sig = 
        "($self, format_spec, /)";

    public final static String coroutine___ge___doc = 
        "Return self>=value.";

    public final static String coroutine___ge___sig = 
        "($self, value, /)";

    public final static String coroutine___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String coroutine___getattribute___sig = 
        "($self, name, /)";

    public final static String coroutine___gt___doc = 
        "Return self>value.";

    public final static String coroutine___gt___sig = 
        "($self, value, /)";

    public final static String coroutine___hash___doc = 
        "Return hash(self).";

    public final static String coroutine___hash___sig = 
        "($self, /)";

    public final static String coroutine___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String coroutine___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String coroutine___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String coroutine___le___doc = 
        "Return self<=value.";

    public final static String coroutine___le___sig = 
        "($self, value, /)";

    public final static String coroutine___lt___doc = 
        "Return self<value.";

    public final static String coroutine___lt___sig = 
        "($self, value, /)";

    public final static String coroutine___ne___doc = 
        "Return self!=value.";

    public final static String coroutine___ne___sig = 
        "($self, value, /)";

    public final static String coroutine___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String coroutine___new___sig = 
        "($type, *args, **kwargs)";

    public final static String coroutine___reduce___doc = 
        "Helper for pickle.";

    public final static String coroutine___reduce___sig = 
        "($self, /)";

    public final static String coroutine___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String coroutine___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String coroutine___repr___doc = 
        "Return repr(self).";

    public final static String coroutine___repr___sig = 
        "($self, /)";

    public final static String coroutine___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String coroutine___setattr___sig = 
        "($self, name, value, /)";

    public final static String coroutine___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String coroutine___sizeof___sig = 
        "($self, /)";

    public final static String coroutine___str___doc = 
        "Return str(self).";

    public final static String coroutine___str___sig = 
        "($self, /)";

    public final static String coroutine___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String coroutine_close_doc = 
        "close() -> raise GeneratorExit inside coroutine.";

    public final static String coroutine_send_doc = 
        "send(arg) -> send 'arg' into coroutine,\n" + 
        "return next iterated value or raise StopIteration.";

    public final static String coroutine_throw_doc = 
        "throw(typ[,val[,tb]]) -> raise exception in coroutine,\n" + 
        "return next iterated value or raise StopIteration.";

    // Docs for <class 'coroutine_wrapper'>
    public final static String coroutine_wrapper___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String coroutine_wrapper___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String coroutine_wrapper___delattr___sig = 
        "($self, name, /)";

    public final static String coroutine_wrapper___dir___doc = 
        "Default dir() implementation.";

    public final static String coroutine_wrapper___dir___sig = 
        "($self, /)";

    public final static String coroutine_wrapper_doc = 
        "A wrapper object implementing __await__ for coroutines.";

    public final static String coroutine_wrapper___eq___doc = 
        "Return self==value.";

    public final static String coroutine_wrapper___eq___sig = 
        "($self, value, /)";

    public final static String coroutine_wrapper___format___doc = 
        "Default object formatter.";

    public final static String coroutine_wrapper___format___sig = 
        "($self, format_spec, /)";

    public final static String coroutine_wrapper___ge___doc = 
        "Return self>=value.";

    public final static String coroutine_wrapper___ge___sig = 
        "($self, value, /)";

    public final static String coroutine_wrapper___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String coroutine_wrapper___getattribute___sig = 
        "($self, name, /)";

    public final static String coroutine_wrapper___gt___doc = 
        "Return self>value.";

    public final static String coroutine_wrapper___gt___sig = 
        "($self, value, /)";

    public final static String coroutine_wrapper___hash___doc = 
        "Return hash(self).";

    public final static String coroutine_wrapper___hash___sig = 
        "($self, /)";

    public final static String coroutine_wrapper___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String coroutine_wrapper___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String coroutine_wrapper___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String coroutine_wrapper___iter___doc = 
        "Implement iter(self).";

    public final static String coroutine_wrapper___iter___sig = 
        "($self, /)";

    public final static String coroutine_wrapper___le___doc = 
        "Return self<=value.";

    public final static String coroutine_wrapper___le___sig = 
        "($self, value, /)";

    public final static String coroutine_wrapper___lt___doc = 
        "Return self<value.";

    public final static String coroutine_wrapper___lt___sig = 
        "($self, value, /)";

    public final static String coroutine_wrapper___ne___doc = 
        "Return self!=value.";

    public final static String coroutine_wrapper___ne___sig = 
        "($self, value, /)";

    public final static String coroutine_wrapper___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String coroutine_wrapper___new___sig = 
        "($type, *args, **kwargs)";

    public final static String coroutine_wrapper___next___doc = 
        "Implement next(self).";

    public final static String coroutine_wrapper___next___sig = 
        "($self, /)";

    public final static String coroutine_wrapper___reduce___doc = 
        "Helper for pickle.";

    public final static String coroutine_wrapper___reduce___sig = 
        "($self, /)";

    public final static String coroutine_wrapper___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String coroutine_wrapper___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String coroutine_wrapper___repr___doc = 
        "Return repr(self).";

    public final static String coroutine_wrapper___repr___sig = 
        "($self, /)";

    public final static String coroutine_wrapper___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String coroutine_wrapper___setattr___sig = 
        "($self, name, value, /)";

    public final static String coroutine_wrapper___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String coroutine_wrapper___sizeof___sig = 
        "($self, /)";

    public final static String coroutine_wrapper___str___doc = 
        "Return str(self).";

    public final static String coroutine_wrapper___str___sig = 
        "($self, /)";

    public final static String coroutine_wrapper___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String coroutine_wrapper_close_doc = 
        "close() -> raise GeneratorExit inside coroutine.";

    public final static String coroutine_wrapper_send_doc = 
        "send(arg) -> send 'arg' into coroutine,\n" + 
        "return next iterated value or raise StopIteration.";

    public final static String coroutine_wrapper_throw_doc = 
        "throw(typ[,val[,tb]]) -> raise exception in coroutine,\n" + 
        "return next iterated value or raise StopIteration.";

    // Docs for <class 'function'>
    public final static String function___call___doc = 
        "Call self as a function.";

    public final static String function___call___sig = 
        "($self, /, *args, **kwargs)";

    public final static String function___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String function___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String function___delattr___sig = 
        "($self, name, /)";

    public final static String function___dir___doc = 
        "Default dir() implementation.";

    public final static String function___dir___sig = 
        "($self, /)";

    public final static String function_doc = 
        "Create a function object.\n" + 
        "\n" + 
        "  code\n" + 
        "    a code object\n" + 
        "  globals\n" + 
        "    the globals dictionary\n" + 
        "  name\n" + 
        "    a string that overrides the name from the code object\n" + 
        "  argdefs\n" + 
        "    a tuple that specifies the default argument values\n" + 
        "  closure\n" + 
        "    a tuple that supplies the bindings for free variables";

    public final static String function___eq___doc = 
        "Return self==value.";

    public final static String function___eq___sig = 
        "($self, value, /)";

    public final static String function___format___doc = 
        "Default object formatter.";

    public final static String function___format___sig = 
        "($self, format_spec, /)";

    public final static String function___ge___doc = 
        "Return self>=value.";

    public final static String function___ge___sig = 
        "($self, value, /)";

    public final static String function___get___doc = 
        "Return an attribute of instance, which is of type owner.";

    public final static String function___get___sig = 
        "($self, instance, owner, /)";

    public final static String function___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String function___getattribute___sig = 
        "($self, name, /)";

    public final static String function___gt___doc = 
        "Return self>value.";

    public final static String function___gt___sig = 
        "($self, value, /)";

    public final static String function___hash___doc = 
        "Return hash(self).";

    public final static String function___hash___sig = 
        "($self, /)";

    public final static String function___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String function___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String function___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String function___le___doc = 
        "Return self<=value.";

    public final static String function___le___sig = 
        "($self, value, /)";

    public final static String function___lt___doc = 
        "Return self<value.";

    public final static String function___lt___sig = 
        "($self, value, /)";

    public final static String function___ne___doc = 
        "Return self!=value.";

    public final static String function___ne___sig = 
        "($self, value, /)";

    public final static String function___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String function___new___sig = 
        "($type, *args, **kwargs)";

    public final static String function___reduce___doc = 
        "Helper for pickle.";

    public final static String function___reduce___sig = 
        "($self, /)";

    public final static String function___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String function___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String function___repr___doc = 
        "Return repr(self).";

    public final static String function___repr___sig = 
        "($self, /)";

    public final static String function___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String function___setattr___sig = 
        "($self, name, value, /)";

    public final static String function___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String function___sizeof___sig = 
        "($self, /)";

    public final static String function___str___doc = 
        "Return str(self).";

    public final static String function___str___sig = 
        "($self, /)";

    public final static String function___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'code'>
    public final static String code___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String code___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String code___delattr___sig = 
        "($self, name, /)";

    public final static String code___dir___doc = 
        "Default dir() implementation.";

    public final static String code___dir___sig = 
        "($self, /)";

    public final static String code_doc = 
        "code(argcount, kwonlyargcount, nlocals, stacksize, flags, codestring,\n" + 
        "      constants, names, varnames, filename, name, firstlineno,\n" + 
        "      lnotab[, freevars[, cellvars]])\n" + 
        "\n" + 
        "Create a code object.  Not for the faint of heart.";

    public final static String code___eq___doc = 
        "Return self==value.";

    public final static String code___eq___sig = 
        "($self, value, /)";

    public final static String code___format___doc = 
        "Default object formatter.";

    public final static String code___format___sig = 
        "($self, format_spec, /)";

    public final static String code___ge___doc = 
        "Return self>=value.";

    public final static String code___ge___sig = 
        "($self, value, /)";

    public final static String code___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String code___getattribute___sig = 
        "($self, name, /)";

    public final static String code___gt___doc = 
        "Return self>value.";

    public final static String code___gt___sig = 
        "($self, value, /)";

    public final static String code___hash___doc = 
        "Return hash(self).";

    public final static String code___hash___sig = 
        "($self, /)";

    public final static String code___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String code___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String code___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String code___le___doc = 
        "Return self<=value.";

    public final static String code___le___sig = 
        "($self, value, /)";

    public final static String code___lt___doc = 
        "Return self<value.";

    public final static String code___lt___sig = 
        "($self, value, /)";

    public final static String code___ne___doc = 
        "Return self!=value.";

    public final static String code___ne___sig = 
        "($self, value, /)";

    public final static String code___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String code___new___sig = 
        "($type, *args, **kwargs)";

    public final static String code___reduce___doc = 
        "Helper for pickle.";

    public final static String code___reduce___sig = 
        "($self, /)";

    public final static String code___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String code___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String code___repr___doc = 
        "Return repr(self).";

    public final static String code___repr___sig = 
        "($self, /)";

    public final static String code___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String code___setattr___sig = 
        "($self, name, value, /)";

    public final static String code___sizeof___doc = 
        "";

    public final static String code___str___doc = 
        "Return str(self).";

    public final static String code___str___sig = 
        "($self, /)";

    public final static String code___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'types.SimpleNamespace'>
    public final static String SimpleNamespace___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String SimpleNamespace___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String SimpleNamespace___delattr___sig = 
        "($self, name, /)";

    public final static String SimpleNamespace___dir___doc = 
        "Default dir() implementation.";

    public final static String SimpleNamespace___dir___sig = 
        "($self, /)";

    public final static String SimpleNamespace_doc = 
        "A simple attribute-based namespace.\n" + 
        "\n" + 
        "SimpleNamespace(**kwargs)";

    public final static String SimpleNamespace___eq___doc = 
        "Return self==value.";

    public final static String SimpleNamespace___eq___sig = 
        "($self, value, /)";

    public final static String SimpleNamespace___format___doc = 
        "Default object formatter.";

    public final static String SimpleNamespace___format___sig = 
        "($self, format_spec, /)";

    public final static String SimpleNamespace___ge___doc = 
        "Return self>=value.";

    public final static String SimpleNamespace___ge___sig = 
        "($self, value, /)";

    public final static String SimpleNamespace___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String SimpleNamespace___getattribute___sig = 
        "($self, name, /)";

    public final static String SimpleNamespace___gt___doc = 
        "Return self>value.";

    public final static String SimpleNamespace___gt___sig = 
        "($self, value, /)";

    public final static String SimpleNamespace___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String SimpleNamespace___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String SimpleNamespace___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String SimpleNamespace___le___doc = 
        "Return self<=value.";

    public final static String SimpleNamespace___le___sig = 
        "($self, value, /)";

    public final static String SimpleNamespace___lt___doc = 
        "Return self<value.";

    public final static String SimpleNamespace___lt___sig = 
        "($self, value, /)";

    public final static String SimpleNamespace___ne___doc = 
        "Return self!=value.";

    public final static String SimpleNamespace___ne___sig = 
        "($self, value, /)";

    public final static String SimpleNamespace___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String SimpleNamespace___new___sig = 
        "($type, *args, **kwargs)";

    public final static String SimpleNamespace___reduce___doc = 
        "Return state information for pickling";

    public final static String SimpleNamespace___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String SimpleNamespace___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String SimpleNamespace___repr___doc = 
        "Return repr(self).";

    public final static String SimpleNamespace___repr___sig = 
        "($self, /)";

    public final static String SimpleNamespace___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String SimpleNamespace___setattr___sig = 
        "($self, name, value, /)";

    public final static String SimpleNamespace___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String SimpleNamespace___sizeof___sig = 
        "($self, /)";

    public final static String SimpleNamespace___str___doc = 
        "Return str(self).";

    public final static String SimpleNamespace___str___sig = 
        "($self, /)";

    public final static String SimpleNamespace___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'frame'>
    public final static String frame___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String frame___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String frame___delattr___sig = 
        "($self, name, /)";

    public final static String frame___dir___doc = 
        "Default dir() implementation.";

    public final static String frame___dir___sig = 
        "($self, /)";

    public final static String frame_doc = 
        "";

    public final static String frame___eq___doc = 
        "Return self==value.";

    public final static String frame___eq___sig = 
        "($self, value, /)";

    public final static String frame___format___doc = 
        "Default object formatter.";

    public final static String frame___format___sig = 
        "($self, format_spec, /)";

    public final static String frame___ge___doc = 
        "Return self>=value.";

    public final static String frame___ge___sig = 
        "($self, value, /)";

    public final static String frame___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String frame___getattribute___sig = 
        "($self, name, /)";

    public final static String frame___gt___doc = 
        "Return self>value.";

    public final static String frame___gt___sig = 
        "($self, value, /)";

    public final static String frame___hash___doc = 
        "Return hash(self).";

    public final static String frame___hash___sig = 
        "($self, /)";

    public final static String frame___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String frame___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String frame___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String frame___le___doc = 
        "Return self<=value.";

    public final static String frame___le___sig = 
        "($self, value, /)";

    public final static String frame___lt___doc = 
        "Return self<value.";

    public final static String frame___lt___sig = 
        "($self, value, /)";

    public final static String frame___ne___doc = 
        "Return self!=value.";

    public final static String frame___ne___sig = 
        "($self, value, /)";

    public final static String frame___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String frame___new___sig = 
        "($type, *args, **kwargs)";

    public final static String frame___reduce___doc = 
        "Helper for pickle.";

    public final static String frame___reduce___sig = 
        "($self, /)";

    public final static String frame___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String frame___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String frame___repr___doc = 
        "Return repr(self).";

    public final static String frame___repr___sig = 
        "($self, /)";

    public final static String frame___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String frame___setattr___sig = 
        "($self, name, value, /)";

    public final static String frame___sizeof___doc = 
        "F.__sizeof__() -> size of F in memory, in bytes";

    public final static String frame___str___doc = 
        "Return str(self).";

    public final static String frame___str___sig = 
        "($self, /)";

    public final static String frame___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String frame_clear_doc = 
        "F.clear(): clear most references held by the frame";

    // Docs for <class 'method'>
    public final static String method___call___doc = 
        "Call self as a function.";

    public final static String method___call___sig = 
        "($self, /, *args, **kwargs)";

    public final static String method___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String method___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String method___delattr___sig = 
        "($self, name, /)";

    public final static String method___dir___doc = 
        "Default dir() implementation.";

    public final static String method___dir___sig = 
        "($self, /)";

    public final static String method_doc = 
        "method(function, instance)\n" + 
        "\n" + 
        "Create a bound instance method object.";

    public final static String method___eq___doc = 
        "Return self==value.";

    public final static String method___eq___sig = 
        "($self, value, /)";

    public final static String method___format___doc = 
        "Default object formatter.";

    public final static String method___format___sig = 
        "($self, format_spec, /)";

    public final static String method___ge___doc = 
        "Return self>=value.";

    public final static String method___ge___sig = 
        "($self, value, /)";

    public final static String method___get___doc = 
        "Return an attribute of instance, which is of type owner.";

    public final static String method___get___sig = 
        "($self, instance, owner, /)";

    public final static String method___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String method___getattribute___sig = 
        "($self, name, /)";

    public final static String method___gt___doc = 
        "Return self>value.";

    public final static String method___gt___sig = 
        "($self, value, /)";

    public final static String method___hash___doc = 
        "Return hash(self).";

    public final static String method___hash___sig = 
        "($self, /)";

    public final static String method___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String method___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String method___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String method___le___doc = 
        "Return self<=value.";

    public final static String method___le___sig = 
        "($self, value, /)";

    public final static String method___lt___doc = 
        "Return self<value.";

    public final static String method___lt___sig = 
        "($self, value, /)";

    public final static String method___ne___doc = 
        "Return self!=value.";

    public final static String method___ne___sig = 
        "($self, value, /)";

    public final static String method___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String method___new___sig = 
        "($type, *args, **kwargs)";

    public final static String method___reduce___doc = 
        "";

    public final static String method___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String method___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String method___repr___doc = 
        "Return repr(self).";

    public final static String method___repr___sig = 
        "($self, /)";

    public final static String method___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String method___setattr___sig = 
        "($self, name, value, /)";

    public final static String method___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String method___sizeof___sig = 
        "($self, /)";

    public final static String method___str___doc = 
        "Return str(self).";

    public final static String method___str___sig = 
        "($self, /)";

    public final static String method___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'traceback'>
    public final static String traceback___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String traceback___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String traceback___delattr___sig = 
        "($self, name, /)";

    public final static String traceback___dir___doc = 
        "";

    public final static String traceback_doc = 
        "TracebackType(tb_next, tb_frame, tb_lasti, tb_lineno)\n" + 
        "--\n" + 
        "\n" + 
        "Create a new traceback object.";

    public final static String traceback___eq___doc = 
        "Return self==value.";

    public final static String traceback___eq___sig = 
        "($self, value, /)";

    public final static String traceback___format___doc = 
        "Default object formatter.";

    public final static String traceback___format___sig = 
        "($self, format_spec, /)";

    public final static String traceback___ge___doc = 
        "Return self>=value.";

    public final static String traceback___ge___sig = 
        "($self, value, /)";

    public final static String traceback___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String traceback___getattribute___sig = 
        "($self, name, /)";

    public final static String traceback___gt___doc = 
        "Return self>value.";

    public final static String traceback___gt___sig = 
        "($self, value, /)";

    public final static String traceback___hash___doc = 
        "Return hash(self).";

    public final static String traceback___hash___sig = 
        "($self, /)";

    public final static String traceback___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String traceback___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String traceback___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String traceback___le___doc = 
        "Return self<=value.";

    public final static String traceback___le___sig = 
        "($self, value, /)";

    public final static String traceback___lt___doc = 
        "Return self<value.";

    public final static String traceback___lt___sig = 
        "($self, value, /)";

    public final static String traceback___ne___doc = 
        "Return self!=value.";

    public final static String traceback___ne___sig = 
        "($self, value, /)";

    public final static String traceback___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String traceback___new___sig = 
        "($type, *args, **kwargs)";

    public final static String traceback___reduce___doc = 
        "Helper for pickle.";

    public final static String traceback___reduce___sig = 
        "($self, /)";

    public final static String traceback___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String traceback___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String traceback___repr___doc = 
        "Return repr(self).";

    public final static String traceback___repr___sig = 
        "($self, /)";

    public final static String traceback___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String traceback___setattr___sig = 
        "($self, name, value, /)";

    public final static String traceback___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String traceback___sizeof___sig = 
        "($self, /)";

    public final static String traceback___str___doc = 
        "Return str(self).";

    public final static String traceback___str___sig = 
        "($self, /)";

    public final static String traceback___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 're.Pattern'>
    public final static String Pattern___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String Pattern___copy___doc = 
        "";

    public final static String Pattern___copy___sig = 
        "($self, /)";

    public final static String Pattern___deepcopy___doc = 
        "";

    public final static String Pattern___deepcopy___sig = 
        "($self, memo, /)";

    public final static String Pattern___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String Pattern___delattr___sig = 
        "($self, name, /)";

    public final static String Pattern___dir___doc = 
        "Default dir() implementation.";

    public final static String Pattern___dir___sig = 
        "($self, /)";

    public final static String Pattern_doc = 
        "Compiled regular expression object.";

    public final static String Pattern___eq___doc = 
        "Return self==value.";

    public final static String Pattern___eq___sig = 
        "($self, value, /)";

    public final static String Pattern___format___doc = 
        "Default object formatter.";

    public final static String Pattern___format___sig = 
        "($self, format_spec, /)";

    public final static String Pattern___ge___doc = 
        "Return self>=value.";

    public final static String Pattern___ge___sig = 
        "($self, value, /)";

    public final static String Pattern___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String Pattern___getattribute___sig = 
        "($self, name, /)";

    public final static String Pattern___gt___doc = 
        "Return self>value.";

    public final static String Pattern___gt___sig = 
        "($self, value, /)";

    public final static String Pattern___hash___doc = 
        "Return hash(self).";

    public final static String Pattern___hash___sig = 
        "($self, /)";

    public final static String Pattern___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String Pattern___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String Pattern___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String Pattern___le___doc = 
        "Return self<=value.";

    public final static String Pattern___le___sig = 
        "($self, value, /)";

    public final static String Pattern___lt___doc = 
        "Return self<value.";

    public final static String Pattern___lt___sig = 
        "($self, value, /)";

    public final static String Pattern___ne___doc = 
        "Return self!=value.";

    public final static String Pattern___ne___sig = 
        "($self, value, /)";

    public final static String Pattern___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String Pattern___new___sig = 
        "($type, *args, **kwargs)";

    public final static String Pattern___reduce___doc = 
        "Helper for pickle.";

    public final static String Pattern___reduce___sig = 
        "($self, /)";

    public final static String Pattern___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String Pattern___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String Pattern___repr___doc = 
        "Return repr(self).";

    public final static String Pattern___repr___sig = 
        "($self, /)";

    public final static String Pattern___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String Pattern___setattr___sig = 
        "($self, name, value, /)";

    public final static String Pattern___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String Pattern___sizeof___sig = 
        "($self, /)";

    public final static String Pattern___str___doc = 
        "Return str(self).";

    public final static String Pattern___str___sig = 
        "($self, /)";

    public final static String Pattern___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String Pattern_findall_doc = 
        "Return a list of all non-overlapping matches of pattern in string.";

    public final static String Pattern_findall_sig = 
        "($self, /, string, pos=0, endpos=sys.maxsize)";

    public final static String Pattern_finditer_doc = 
        "Return an iterator over all non-overlapping matches for the RE pattern in string.\n" + 
        "\n" + 
        "For each match, the iterator returns a match object.";

    public final static String Pattern_finditer_sig = 
        "($self, /, string, pos=0, endpos=sys.maxsize)";

    public final static String Pattern_fullmatch_doc = 
        "Matches against all of the string.";

    public final static String Pattern_fullmatch_sig = 
        "($self, /, string, pos=0, endpos=sys.maxsize)";

    public final static String Pattern_match_doc = 
        "Matches zero or more characters at the beginning of the string.";

    public final static String Pattern_match_sig = 
        "($self, /, string, pos=0, endpos=sys.maxsize)";

    public final static String Pattern_scanner_doc = 
        "";

    public final static String Pattern_scanner_sig = 
        "($self, /, string, pos=0, endpos=sys.maxsize)";

    public final static String Pattern_search_doc = 
        "Scan through string looking for a match, and return a corresponding match object instance.\n" + 
        "\n" + 
        "Return None if no position in the string matches.";

    public final static String Pattern_search_sig = 
        "($self, /, string, pos=0, endpos=sys.maxsize)";

    public final static String Pattern_split_doc = 
        "Split string by the occurrences of pattern.";

    public final static String Pattern_split_sig = 
        "($self, /, string, maxsplit=0)";

    public final static String Pattern_sub_doc = 
        "Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl.";

    public final static String Pattern_sub_sig = 
        "($self, /, repl, string, count=0)";

    public final static String Pattern_subn_doc = 
        "Return the tuple (new_string, number_of_subs_made) found by replacing the leftmost non-overlapping occurrences of pattern with the replacement repl.";

    public final static String Pattern_subn_sig = 
        "($self, /, repl, string, count=0)";

    // Docs for <class 're.Match'>
    public final static String Match___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String Match___copy___doc = 
        "";

    public final static String Match___copy___sig = 
        "($self, /)";

    public final static String Match___deepcopy___doc = 
        "";

    public final static String Match___deepcopy___sig = 
        "($self, memo, /)";

    public final static String Match___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String Match___delattr___sig = 
        "($self, name, /)";

    public final static String Match___dir___doc = 
        "Default dir() implementation.";

    public final static String Match___dir___sig = 
        "($self, /)";

    public final static String Match_doc = 
        "The result of re.match() and re.search().\n" + 
        "Match objects always have a boolean value of True.";

    public final static String Match___eq___doc = 
        "Return self==value.";

    public final static String Match___eq___sig = 
        "($self, value, /)";

    public final static String Match___format___doc = 
        "Default object formatter.";

    public final static String Match___format___sig = 
        "($self, format_spec, /)";

    public final static String Match___ge___doc = 
        "Return self>=value.";

    public final static String Match___ge___sig = 
        "($self, value, /)";

    public final static String Match___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String Match___getattribute___sig = 
        "($self, name, /)";

    public final static String Match___getitem___doc = 
        "Return self[key].";

    public final static String Match___getitem___sig = 
        "($self, key, /)";

    public final static String Match___gt___doc = 
        "Return self>value.";

    public final static String Match___gt___sig = 
        "($self, value, /)";

    public final static String Match___hash___doc = 
        "Return hash(self).";

    public final static String Match___hash___sig = 
        "($self, /)";

    public final static String Match___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String Match___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String Match___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String Match___le___doc = 
        "Return self<=value.";

    public final static String Match___le___sig = 
        "($self, value, /)";

    public final static String Match___lt___doc = 
        "Return self<value.";

    public final static String Match___lt___sig = 
        "($self, value, /)";

    public final static String Match___ne___doc = 
        "Return self!=value.";

    public final static String Match___ne___sig = 
        "($self, value, /)";

    public final static String Match___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String Match___new___sig = 
        "($type, *args, **kwargs)";

    public final static String Match___reduce___doc = 
        "Helper for pickle.";

    public final static String Match___reduce___sig = 
        "($self, /)";

    public final static String Match___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String Match___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String Match___repr___doc = 
        "Return repr(self).";

    public final static String Match___repr___sig = 
        "($self, /)";

    public final static String Match___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String Match___setattr___sig = 
        "($self, name, value, /)";

    public final static String Match___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String Match___sizeof___sig = 
        "($self, /)";

    public final static String Match___str___doc = 
        "Return str(self).";

    public final static String Match___str___sig = 
        "($self, /)";

    public final static String Match___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String Match_end_doc = 
        "Return index of the end of the substring matched by group.";

    public final static String Match_end_sig = 
        "($self, group=0, /)";

    public final static String Match_expand_doc = 
        "Return the string obtained by doing backslash substitution on the string template, as done by the sub() method.";

    public final static String Match_expand_sig = 
        "($self, /, template)";

    public final static String Match_group_doc = 
        "group([group1, ...]) -> str or tuple.\n" + 
        "    Return subgroup(s) of the match by indices or names.\n" + 
        "    For 0 returns the entire match.";

    public final static String Match_groupdict_doc = 
        "Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name.\n" + 
        "\n" + 
        "  default\n" + 
        "    Is used for groups that did not participate in the match.";

    public final static String Match_groupdict_sig = 
        "($self, /, default=None)";

    public final static String Match_groups_doc = 
        "Return a tuple containing all the subgroups of the match, from 1.\n" + 
        "\n" + 
        "  default\n" + 
        "    Is used for groups that did not participate in the match.";

    public final static String Match_groups_sig = 
        "($self, /, default=None)";

    public final static String Match_span_doc = 
        "For match object m, return the 2-tuple (m.start(group), m.end(group)).";

    public final static String Match_span_sig = 
        "($self, group=0, /)";

    public final static String Match_start_doc = 
        "Return index of the start of the substring matched by group.";

    public final static String Match_start_sig = 
        "($self, group=0, /)";

    // Docs for <class '_sre.SRE_Scanner'>
    public final static String SRE_Scanner___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String SRE_Scanner___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String SRE_Scanner___delattr___sig = 
        "($self, name, /)";

    public final static String SRE_Scanner___dir___doc = 
        "Default dir() implementation.";

    public final static String SRE_Scanner___dir___sig = 
        "($self, /)";

    public final static String SRE_Scanner_doc = 
        "";

    public final static String SRE_Scanner___eq___doc = 
        "Return self==value.";

    public final static String SRE_Scanner___eq___sig = 
        "($self, value, /)";

    public final static String SRE_Scanner___format___doc = 
        "Default object formatter.";

    public final static String SRE_Scanner___format___sig = 
        "($self, format_spec, /)";

    public final static String SRE_Scanner___ge___doc = 
        "Return self>=value.";

    public final static String SRE_Scanner___ge___sig = 
        "($self, value, /)";

    public final static String SRE_Scanner___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String SRE_Scanner___getattribute___sig = 
        "($self, name, /)";

    public final static String SRE_Scanner___gt___doc = 
        "Return self>value.";

    public final static String SRE_Scanner___gt___sig = 
        "($self, value, /)";

    public final static String SRE_Scanner___hash___doc = 
        "Return hash(self).";

    public final static String SRE_Scanner___hash___sig = 
        "($self, /)";

    public final static String SRE_Scanner___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String SRE_Scanner___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String SRE_Scanner___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String SRE_Scanner___le___doc = 
        "Return self<=value.";

    public final static String SRE_Scanner___le___sig = 
        "($self, value, /)";

    public final static String SRE_Scanner___lt___doc = 
        "Return self<value.";

    public final static String SRE_Scanner___lt___sig = 
        "($self, value, /)";

    public final static String SRE_Scanner___ne___doc = 
        "Return self!=value.";

    public final static String SRE_Scanner___ne___sig = 
        "($self, value, /)";

    public final static String SRE_Scanner___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String SRE_Scanner___new___sig = 
        "($type, *args, **kwargs)";

    public final static String SRE_Scanner___reduce___doc = 
        "Helper for pickle.";

    public final static String SRE_Scanner___reduce___sig = 
        "($self, /)";

    public final static String SRE_Scanner___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String SRE_Scanner___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String SRE_Scanner___repr___doc = 
        "Return repr(self).";

    public final static String SRE_Scanner___repr___sig = 
        "($self, /)";

    public final static String SRE_Scanner___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String SRE_Scanner___setattr___sig = 
        "($self, name, value, /)";

    public final static String SRE_Scanner___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String SRE_Scanner___sizeof___sig = 
        "($self, /)";

    public final static String SRE_Scanner___str___doc = 
        "Return str(self).";

    public final static String SRE_Scanner___str___sig = 
        "($self, /)";

    public final static String SRE_Scanner___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String SRE_Scanner_match_doc = 
        "";

    public final static String SRE_Scanner_match_sig = 
        "($self, /)";

    public final static String SRE_Scanner_search_doc = 
        "";

    public final static String SRE_Scanner_search_sig = 
        "($self, /)";

    // Docs for <class 'range_iterator'>
    public final static String range_iterator___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String range_iterator___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String range_iterator___delattr___sig = 
        "($self, name, /)";

    public final static String range_iterator___dir___doc = 
        "Default dir() implementation.";

    public final static String range_iterator___dir___sig = 
        "($self, /)";

    public final static String range_iterator_doc = 
        "";

    public final static String range_iterator___eq___doc = 
        "Return self==value.";

    public final static String range_iterator___eq___sig = 
        "($self, value, /)";

    public final static String range_iterator___format___doc = 
        "Default object formatter.";

    public final static String range_iterator___format___sig = 
        "($self, format_spec, /)";

    public final static String range_iterator___ge___doc = 
        "Return self>=value.";

    public final static String range_iterator___ge___sig = 
        "($self, value, /)";

    public final static String range_iterator___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String range_iterator___getattribute___sig = 
        "($self, name, /)";

    public final static String range_iterator___gt___doc = 
        "Return self>value.";

    public final static String range_iterator___gt___sig = 
        "($self, value, /)";

    public final static String range_iterator___hash___doc = 
        "Return hash(self).";

    public final static String range_iterator___hash___sig = 
        "($self, /)";

    public final static String range_iterator___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String range_iterator___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String range_iterator___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String range_iterator___iter___doc = 
        "Implement iter(self).";

    public final static String range_iterator___iter___sig = 
        "($self, /)";

    public final static String range_iterator___le___doc = 
        "Return self<=value.";

    public final static String range_iterator___le___sig = 
        "($self, value, /)";

    public final static String range_iterator___length_hint___doc = 
        "Private method returning an estimate of len(list(it)).";

    public final static String range_iterator___lt___doc = 
        "Return self<value.";

    public final static String range_iterator___lt___sig = 
        "($self, value, /)";

    public final static String range_iterator___ne___doc = 
        "Return self!=value.";

    public final static String range_iterator___ne___sig = 
        "($self, value, /)";

    public final static String range_iterator___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String range_iterator___new___sig = 
        "($type, *args, **kwargs)";

    public final static String range_iterator___next___doc = 
        "Implement next(self).";

    public final static String range_iterator___next___sig = 
        "($self, /)";

    public final static String range_iterator___reduce___doc = 
        "Return state information for pickling.";

    public final static String range_iterator___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String range_iterator___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String range_iterator___repr___doc = 
        "Return repr(self).";

    public final static String range_iterator___repr___sig = 
        "($self, /)";

    public final static String range_iterator___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String range_iterator___setattr___sig = 
        "($self, name, value, /)";

    public final static String range_iterator___setstate___doc = 
        "Set state information for unpickling.";

    public final static String range_iterator___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String range_iterator___sizeof___sig = 
        "($self, /)";

    public final static String range_iterator___str___doc = 
        "Return str(self).";

    public final static String range_iterator___str___sig = 
        "($self, /)";

    public final static String range_iterator___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'list_iterator'>
    public final static String list_iterator___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String list_iterator___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String list_iterator___delattr___sig = 
        "($self, name, /)";

    public final static String list_iterator___dir___doc = 
        "Default dir() implementation.";

    public final static String list_iterator___dir___sig = 
        "($self, /)";

    public final static String list_iterator_doc = 
        "";

    public final static String list_iterator___eq___doc = 
        "Return self==value.";

    public final static String list_iterator___eq___sig = 
        "($self, value, /)";

    public final static String list_iterator___format___doc = 
        "Default object formatter.";

    public final static String list_iterator___format___sig = 
        "($self, format_spec, /)";

    public final static String list_iterator___ge___doc = 
        "Return self>=value.";

    public final static String list_iterator___ge___sig = 
        "($self, value, /)";

    public final static String list_iterator___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String list_iterator___getattribute___sig = 
        "($self, name, /)";

    public final static String list_iterator___gt___doc = 
        "Return self>value.";

    public final static String list_iterator___gt___sig = 
        "($self, value, /)";

    public final static String list_iterator___hash___doc = 
        "Return hash(self).";

    public final static String list_iterator___hash___sig = 
        "($self, /)";

    public final static String list_iterator___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String list_iterator___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String list_iterator___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String list_iterator___iter___doc = 
        "Implement iter(self).";

    public final static String list_iterator___iter___sig = 
        "($self, /)";

    public final static String list_iterator___le___doc = 
        "Return self<=value.";

    public final static String list_iterator___le___sig = 
        "($self, value, /)";

    public final static String list_iterator___length_hint___doc = 
        "Private method returning an estimate of len(list(it)).";

    public final static String list_iterator___lt___doc = 
        "Return self<value.";

    public final static String list_iterator___lt___sig = 
        "($self, value, /)";

    public final static String list_iterator___ne___doc = 
        "Return self!=value.";

    public final static String list_iterator___ne___sig = 
        "($self, value, /)";

    public final static String list_iterator___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String list_iterator___new___sig = 
        "($type, *args, **kwargs)";

    public final static String list_iterator___next___doc = 
        "Implement next(self).";

    public final static String list_iterator___next___sig = 
        "($self, /)";

    public final static String list_iterator___reduce___doc = 
        "Return state information for pickling.";

    public final static String list_iterator___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String list_iterator___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String list_iterator___repr___doc = 
        "Return repr(self).";

    public final static String list_iterator___repr___sig = 
        "($self, /)";

    public final static String list_iterator___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String list_iterator___setattr___sig = 
        "($self, name, value, /)";

    public final static String list_iterator___setstate___doc = 
        "Set state information for unpickling.";

    public final static String list_iterator___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String list_iterator___sizeof___sig = 
        "($self, /)";

    public final static String list_iterator___str___doc = 
        "Return str(self).";

    public final static String list_iterator___str___sig = 
        "($self, /)";

    public final static String list_iterator___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'itertools.chain'>
    public final static String chain___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String chain___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String chain___delattr___sig = 
        "($self, name, /)";

    public final static String chain___dir___doc = 
        "Default dir() implementation.";

    public final static String chain___dir___sig = 
        "($self, /)";

    public final static String chain_doc = 
        "chain(*iterables) --> chain object\n" + 
        "\n" + 
        "Return a chain object whose .__next__() method returns elements from the\n" + 
        "first iterable until it is exhausted, then elements from the next\n" + 
        "iterable, until all of the iterables are exhausted.";

    public final static String chain___eq___doc = 
        "Return self==value.";

    public final static String chain___eq___sig = 
        "($self, value, /)";

    public final static String chain___format___doc = 
        "Default object formatter.";

    public final static String chain___format___sig = 
        "($self, format_spec, /)";

    public final static String chain___ge___doc = 
        "Return self>=value.";

    public final static String chain___ge___sig = 
        "($self, value, /)";

    public final static String chain___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String chain___getattribute___sig = 
        "($self, name, /)";

    public final static String chain___gt___doc = 
        "Return self>value.";

    public final static String chain___gt___sig = 
        "($self, value, /)";

    public final static String chain___hash___doc = 
        "Return hash(self).";

    public final static String chain___hash___sig = 
        "($self, /)";

    public final static String chain___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String chain___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String chain___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String chain___iter___doc = 
        "Implement iter(self).";

    public final static String chain___iter___sig = 
        "($self, /)";

    public final static String chain___le___doc = 
        "Return self<=value.";

    public final static String chain___le___sig = 
        "($self, value, /)";

    public final static String chain___lt___doc = 
        "Return self<value.";

    public final static String chain___lt___sig = 
        "($self, value, /)";

    public final static String chain___ne___doc = 
        "Return self!=value.";

    public final static String chain___ne___sig = 
        "($self, value, /)";

    public final static String chain___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String chain___new___sig = 
        "($type, *args, **kwargs)";

    public final static String chain___next___doc = 
        "Implement next(self).";

    public final static String chain___next___sig = 
        "($self, /)";

    public final static String chain___reduce___doc = 
        "Return state information for pickling.";

    public final static String chain___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String chain___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String chain___repr___doc = 
        "Return repr(self).";

    public final static String chain___repr___sig = 
        "($self, /)";

    public final static String chain___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String chain___setattr___sig = 
        "($self, name, value, /)";

    public final static String chain___setstate___doc = 
        "Set state information for unpickling.";

    public final static String chain___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String chain___sizeof___sig = 
        "($self, /)";

    public final static String chain___str___doc = 
        "Return str(self).";

    public final static String chain___str___sig = 
        "($self, /)";

    public final static String chain___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String chain_from_iterable_doc = 
        "chain.from_iterable(iterable) --> chain object\n" + 
        "\n" + 
        "Alternate chain() constructor taking a single iterable argument\n" + 
        "that evaluates lazily.";

    // Docs for <class 'NoneType'>
    public final static String NoneType___bool___doc = 
        "self != 0";

    public final static String NoneType___bool___sig = 
        "($self, /)";

    public final static String NoneType___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String NoneType___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String NoneType___delattr___sig = 
        "($self, name, /)";

    public final static String NoneType___dir___doc = 
        "Default dir() implementation.";

    public final static String NoneType___dir___sig = 
        "($self, /)";

    public final static String NoneType_doc = 
        "";

    public final static String NoneType___eq___doc = 
        "Return self==value.";

    public final static String NoneType___eq___sig = 
        "($self, value, /)";

    public final static String NoneType___format___doc = 
        "Default object formatter.";

    public final static String NoneType___format___sig = 
        "($self, format_spec, /)";

    public final static String NoneType___ge___doc = 
        "Return self>=value.";

    public final static String NoneType___ge___sig = 
        "($self, value, /)";

    public final static String NoneType___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String NoneType___getattribute___sig = 
        "($self, name, /)";

    public final static String NoneType___gt___doc = 
        "Return self>value.";

    public final static String NoneType___gt___sig = 
        "($self, value, /)";

    public final static String NoneType___hash___doc = 
        "Return hash(self).";

    public final static String NoneType___hash___sig = 
        "($self, /)";

    public final static String NoneType___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String NoneType___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String NoneType___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String NoneType___le___doc = 
        "Return self<=value.";

    public final static String NoneType___le___sig = 
        "($self, value, /)";

    public final static String NoneType___lt___doc = 
        "Return self<value.";

    public final static String NoneType___lt___sig = 
        "($self, value, /)";

    public final static String NoneType___ne___doc = 
        "Return self!=value.";

    public final static String NoneType___ne___sig = 
        "($self, value, /)";

    public final static String NoneType___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String NoneType___new___sig = 
        "($type, *args, **kwargs)";

    public final static String NoneType___reduce___doc = 
        "Helper for pickle.";

    public final static String NoneType___reduce___sig = 
        "($self, /)";

    public final static String NoneType___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String NoneType___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String NoneType___repr___doc = 
        "Return repr(self).";

    public final static String NoneType___repr___sig = 
        "($self, /)";

    public final static String NoneType___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String NoneType___setattr___sig = 
        "($self, name, value, /)";

    public final static String NoneType___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String NoneType___sizeof___sig = 
        "($self, /)";

    public final static String NoneType___str___doc = 
        "Return str(self).";

    public final static String NoneType___str___sig = 
        "($self, /)";

    public final static String NoneType___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'NotImplementedType'>
    public final static String NotImplementedType___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String NotImplementedType___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String NotImplementedType___delattr___sig = 
        "($self, name, /)";

    public final static String NotImplementedType___dir___doc = 
        "Default dir() implementation.";

    public final static String NotImplementedType___dir___sig = 
        "($self, /)";

    public final static String NotImplementedType_doc = 
        "";

    public final static String NotImplementedType___eq___doc = 
        "Return self==value.";

    public final static String NotImplementedType___eq___sig = 
        "($self, value, /)";

    public final static String NotImplementedType___format___doc = 
        "Default object formatter.";

    public final static String NotImplementedType___format___sig = 
        "($self, format_spec, /)";

    public final static String NotImplementedType___ge___doc = 
        "Return self>=value.";

    public final static String NotImplementedType___ge___sig = 
        "($self, value, /)";

    public final static String NotImplementedType___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String NotImplementedType___getattribute___sig = 
        "($self, name, /)";

    public final static String NotImplementedType___gt___doc = 
        "Return self>value.";

    public final static String NotImplementedType___gt___sig = 
        "($self, value, /)";

    public final static String NotImplementedType___hash___doc = 
        "Return hash(self).";

    public final static String NotImplementedType___hash___sig = 
        "($self, /)";

    public final static String NotImplementedType___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String NotImplementedType___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String NotImplementedType___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String NotImplementedType___le___doc = 
        "Return self<=value.";

    public final static String NotImplementedType___le___sig = 
        "($self, value, /)";

    public final static String NotImplementedType___lt___doc = 
        "Return self<value.";

    public final static String NotImplementedType___lt___sig = 
        "($self, value, /)";

    public final static String NotImplementedType___ne___doc = 
        "Return self!=value.";

    public final static String NotImplementedType___ne___sig = 
        "($self, value, /)";

    public final static String NotImplementedType___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String NotImplementedType___new___sig = 
        "($type, *args, **kwargs)";

    public final static String NotImplementedType___reduce___doc = 
        "";

    public final static String NotImplementedType___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String NotImplementedType___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String NotImplementedType___repr___doc = 
        "Return repr(self).";

    public final static String NotImplementedType___repr___sig = 
        "($self, /)";

    public final static String NotImplementedType___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String NotImplementedType___setattr___sig = 
        "($self, name, value, /)";

    public final static String NotImplementedType___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String NotImplementedType___sizeof___sig = 
        "($self, /)";

    public final static String NotImplementedType___str___doc = 
        "Return str(self).";

    public final static String NotImplementedType___str___sig = 
        "($self, /)";

    public final static String NotImplementedType___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class 'ellipsis'>
    public final static String ellipsis___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String ellipsis___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String ellipsis___delattr___sig = 
        "($self, name, /)";

    public final static String ellipsis___dir___doc = 
        "Default dir() implementation.";

    public final static String ellipsis___dir___sig = 
        "($self, /)";

    public final static String ellipsis_doc = 
        "";

    public final static String ellipsis___eq___doc = 
        "Return self==value.";

    public final static String ellipsis___eq___sig = 
        "($self, value, /)";

    public final static String ellipsis___format___doc = 
        "Default object formatter.";

    public final static String ellipsis___format___sig = 
        "($self, format_spec, /)";

    public final static String ellipsis___ge___doc = 
        "Return self>=value.";

    public final static String ellipsis___ge___sig = 
        "($self, value, /)";

    public final static String ellipsis___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String ellipsis___getattribute___sig = 
        "($self, name, /)";

    public final static String ellipsis___gt___doc = 
        "Return self>value.";

    public final static String ellipsis___gt___sig = 
        "($self, value, /)";

    public final static String ellipsis___hash___doc = 
        "Return hash(self).";

    public final static String ellipsis___hash___sig = 
        "($self, /)";

    public final static String ellipsis___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String ellipsis___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String ellipsis___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String ellipsis___le___doc = 
        "Return self<=value.";

    public final static String ellipsis___le___sig = 
        "($self, value, /)";

    public final static String ellipsis___lt___doc = 
        "Return self<value.";

    public final static String ellipsis___lt___sig = 
        "($self, value, /)";

    public final static String ellipsis___ne___doc = 
        "Return self!=value.";

    public final static String ellipsis___ne___sig = 
        "($self, value, /)";

    public final static String ellipsis___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String ellipsis___new___sig = 
        "($type, *args, **kwargs)";

    public final static String ellipsis___reduce___doc = 
        "";

    public final static String ellipsis___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String ellipsis___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String ellipsis___repr___doc = 
        "Return repr(self).";

    public final static String ellipsis___repr___sig = 
        "($self, /)";

    public final static String ellipsis___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String ellipsis___setattr___sig = 
        "($self, name, value, /)";

    public final static String ellipsis___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String ellipsis___sizeof___sig = 
        "($self, /)";

    public final static String ellipsis___str___doc = 
        "Return str(self).";

    public final static String ellipsis___str___sig = 
        "($self, /)";

    public final static String ellipsis___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    // Docs for <class '_multiprocessing.SemLock'>
    public final static String SemLock___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String SemLock___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String SemLock___delattr___sig = 
        "($self, name, /)";

    public final static String SemLock___dir___doc = 
        "Default dir() implementation.";

    public final static String SemLock___dir___sig = 
        "($self, /)";

    public final static String SemLock_doc = 
        "Semaphore/Mutex type";

    public final static String SemLock___enter___doc = 
        "enter the semaphore/lock";

    public final static String SemLock___eq___doc = 
        "Return self==value.";

    public final static String SemLock___eq___sig = 
        "($self, value, /)";

    public final static String SemLock___exit___doc = 
        "exit the semaphore/lock";

    public final static String SemLock___format___doc = 
        "Default object formatter.";

    public final static String SemLock___format___sig = 
        "($self, format_spec, /)";

    public final static String SemLock___ge___doc = 
        "Return self>=value.";

    public final static String SemLock___ge___sig = 
        "($self, value, /)";

    public final static String SemLock___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String SemLock___getattribute___sig = 
        "($self, name, /)";

    public final static String SemLock___gt___doc = 
        "Return self>value.";

    public final static String SemLock___gt___sig = 
        "($self, value, /)";

    public final static String SemLock___hash___doc = 
        "Return hash(self).";

    public final static String SemLock___hash___sig = 
        "($self, /)";

    public final static String SemLock___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String SemLock___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String SemLock___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String SemLock___le___doc = 
        "Return self<=value.";

    public final static String SemLock___le___sig = 
        "($self, value, /)";

    public final static String SemLock___lt___doc = 
        "Return self<value.";

    public final static String SemLock___lt___sig = 
        "($self, value, /)";

    public final static String SemLock___ne___doc = 
        "Return self!=value.";

    public final static String SemLock___ne___sig = 
        "($self, value, /)";

    public final static String SemLock___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String SemLock___new___sig = 
        "($type, *args, **kwargs)";

    public final static String SemLock___reduce___doc = 
        "Helper for pickle.";

    public final static String SemLock___reduce___sig = 
        "($self, /)";

    public final static String SemLock___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String SemLock___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String SemLock___repr___doc = 
        "Return repr(self).";

    public final static String SemLock___repr___sig = 
        "($self, /)";

    public final static String SemLock___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String SemLock___setattr___sig = 
        "($self, name, value, /)";

    public final static String SemLock___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String SemLock___sizeof___sig = 
        "($self, /)";

    public final static String SemLock___str___doc = 
        "Return str(self).";

    public final static String SemLock___str___sig = 
        "($self, /)";

    public final static String SemLock___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String SemLock__after_fork_doc = 
        "rezero the net acquisition count after fork()";

    public final static String SemLock__count_doc = 
        "num of `acquire()`s minus num of `release()`s for this process";

    public final static String SemLock__get_value_doc = 
        "get the value of the semaphore";

    public final static String SemLock__is_mine_doc = 
        "whether the lock is owned by this thread";

    public final static String SemLock__is_zero_doc = 
        "returns whether semaphore has value zero";

    public final static String SemLock__rebuild_doc = 
        "";

    public final static String SemLock_acquire_doc = 
        "acquire the semaphore/lock";

    public final static String SemLock_release_doc = 
        "release the semaphore/lock";

    // Docs for <class 'io.TextIOBase'>
    public final static String TextIOBase___class___doc = 
        "Metaclass for defining Abstract Base Classes (ABCs).\n" + 
        "\n" + 
        "        Use this metaclass to create an ABC.  An ABC can be subclassed\n" + 
        "        directly, and then acts as a mix-in class.  You can also register\n" + 
        "        unrelated concrete classes (even built-in classes) and unrelated\n" + 
        "        ABCs as 'virtual subclasses' -- these and their descendants will\n" + 
        "        be considered subclasses of the registering ABC by the built-in\n" + 
        "        issubclass() function, but the registering ABC won't show up in\n" + 
        "        their MRO (Method Resolution Order) nor will method\n" + 
        "        implementations defined by the registering ABC be callable (not\n" + 
        "        even via super()).\n" + 
        "        ";

    public final static String TextIOBase___del___doc = 
        "";

    public final static String TextIOBase___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String TextIOBase___delattr___sig = 
        "($self, name, /)";

    public final static String TextIOBase___dir___doc = 
        "Default dir() implementation.";

    public final static String TextIOBase___dir___sig = 
        "($self, /)";

    public final static String TextIOBase_doc = 
        "Base class for text I/O.\n" + 
        "\n" + 
        "This class provides a character and line based interface to stream\n" + 
        "I/O. There is no readinto method because Python's character strings\n" + 
        "are immutable. There is no public constructor.\n" + 
        "";

    public final static String TextIOBase___enter___doc = 
        "";

    public final static String TextIOBase___eq___doc = 
        "Return self==value.";

    public final static String TextIOBase___eq___sig = 
        "($self, value, /)";

    public final static String TextIOBase___exit___doc = 
        "";

    public final static String TextIOBase___format___doc = 
        "Default object formatter.";

    public final static String TextIOBase___format___sig = 
        "($self, format_spec, /)";

    public final static String TextIOBase___ge___doc = 
        "Return self>=value.";

    public final static String TextIOBase___ge___sig = 
        "($self, value, /)";

    public final static String TextIOBase___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String TextIOBase___getattribute___sig = 
        "($self, name, /)";

    public final static String TextIOBase___gt___doc = 
        "Return self>value.";

    public final static String TextIOBase___gt___sig = 
        "($self, value, /)";

    public final static String TextIOBase___hash___doc = 
        "Return hash(self).";

    public final static String TextIOBase___hash___sig = 
        "($self, /)";

    public final static String TextIOBase___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String TextIOBase___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String TextIOBase___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String TextIOBase___iter___doc = 
        "Implement iter(self).";

    public final static String TextIOBase___iter___sig = 
        "($self, /)";

    public final static String TextIOBase___le___doc = 
        "Return self<=value.";

    public final static String TextIOBase___le___sig = 
        "($self, value, /)";

    public final static String TextIOBase___lt___doc = 
        "Return self<value.";

    public final static String TextIOBase___lt___sig = 
        "($self, value, /)";

    public final static String TextIOBase___ne___doc = 
        "Return self!=value.";

    public final static String TextIOBase___ne___sig = 
        "($self, value, /)";

    public final static String TextIOBase___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String TextIOBase___new___sig = 
        "($type, *args, **kwargs)";

    public final static String TextIOBase___next___doc = 
        "Implement next(self).";

    public final static String TextIOBase___next___sig = 
        "($self, /)";

    public final static String TextIOBase___reduce___doc = 
        "Helper for pickle.";

    public final static String TextIOBase___reduce___sig = 
        "($self, /)";

    public final static String TextIOBase___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String TextIOBase___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String TextIOBase___repr___doc = 
        "Return repr(self).";

    public final static String TextIOBase___repr___sig = 
        "($self, /)";

    public final static String TextIOBase___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String TextIOBase___setattr___sig = 
        "($self, name, value, /)";

    public final static String TextIOBase___sizeof___doc = 
        "Size of object in memory, in bytes.";

    public final static String TextIOBase___sizeof___sig = 
        "($self, /)";

    public final static String TextIOBase___str___doc = 
        "Return str(self).";

    public final static String TextIOBase___str___sig = 
        "($self, /)";

    public final static String TextIOBase___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String TextIOBase__checkClosed_doc = 
        "";

    public final static String TextIOBase__checkReadable_doc = 
        "";

    public final static String TextIOBase__checkSeekable_doc = 
        "";

    public final static String TextIOBase__checkWritable_doc = 
        "";

    public final static String TextIOBase_close_doc = 
        "Flush and close the IO object.\n" + 
        "\n" + 
        "This method has no effect if the file is already closed.";

    public final static String TextIOBase_close_sig = 
        "($self, /)";

    public final static String TextIOBase_detach_doc = 
        "Separate the underlying buffer from the TextIOBase and return it.\n" + 
        "\n" + 
        "After the underlying buffer has been detached, the TextIO is in an\n" + 
        "unusable state.\n" + 
        "";

    public final static String TextIOBase_fileno_doc = 
        "Returns underlying file descriptor if one exists.\n" + 
        "\n" + 
        "OSError is raised if the IO object does not use a file descriptor.";

    public final static String TextIOBase_fileno_sig = 
        "($self, /)";

    public final static String TextIOBase_flush_doc = 
        "Flush write buffers, if applicable.\n" + 
        "\n" + 
        "This is not implemented for read-only and non-blocking streams.";

    public final static String TextIOBase_flush_sig = 
        "($self, /)";

    public final static String TextIOBase_isatty_doc = 
        "Return whether this is an 'interactive' stream.\n" + 
        "\n" + 
        "Return False if it can't be determined.";

    public final static String TextIOBase_isatty_sig = 
        "($self, /)";

    public final static String TextIOBase_read_doc = 
        "Read at most n characters from stream.\n" + 
        "\n" + 
        "Read from underlying buffer until we have n characters or we hit EOF.\n" + 
        "If n is negative or omitted, read until EOF.\n" + 
        "";

    public final static String TextIOBase_readable_doc = 
        "Return whether object was opened for reading.\n" + 
        "\n" + 
        "If False, read() will raise OSError.";

    public final static String TextIOBase_readable_sig = 
        "($self, /)";

    public final static String TextIOBase_readline_doc = 
        "Read until newline or EOF.\n" + 
        "\n" + 
        "Returns an empty string if EOF is hit immediately.\n" + 
        "";

    public final static String TextIOBase_readlines_doc = 
        "Return a list of lines from the stream.\n" + 
        "\n" + 
        "hint can be specified to control the number of lines read: no more\n" + 
        "lines will be read if the total size (in bytes/characters) of all\n" + 
        "lines so far exceeds hint.";

    public final static String TextIOBase_readlines_sig = 
        "($self, hint=-1, /)";

    public final static String TextIOBase_seek_doc = 
        "Change stream position.\n" + 
        "\n" + 
        "Change the stream position to the given byte offset. The offset is\n" + 
        "interpreted relative to the position indicated by whence.  Values\n" + 
        "for whence are:\n" + 
        "\n" + 
        "* 0 -- start of stream (the default); offset should be zero or positive\n" + 
        "* 1 -- current stream position; offset may be negative\n" + 
        "* 2 -- end of stream; offset is usually negative\n" + 
        "\n" + 
        "Return the new absolute position.";

    public final static String TextIOBase_seekable_doc = 
        "Return whether object supports random access.\n" + 
        "\n" + 
        "If False, seek(), tell() and truncate() will raise OSError.\n" + 
        "This method may need to do a test seek().";

    public final static String TextIOBase_seekable_sig = 
        "($self, /)";

    public final static String TextIOBase_tell_doc = 
        "Return current stream position.";

    public final static String TextIOBase_tell_sig = 
        "($self, /)";

    public final static String TextIOBase_truncate_doc = 
        "Truncate file to size bytes.\n" + 
        "\n" + 
        "File pointer is left unchanged.  Size defaults to the current IO\n" + 
        "position as reported by tell().  Returns the new size.";

    public final static String TextIOBase_writable_doc = 
        "Return whether object was opened for writing.\n" + 
        "\n" + 
        "If False, write() will raise OSError.";

    public final static String TextIOBase_writable_sig = 
        "($self, /)";

    public final static String TextIOBase_write_doc = 
        "Write string to stream.\n" + 
        "Returns the number of characters written (which is always equal to\n" + 
        "the length of the string).\n" + 
        "";

    public final static String TextIOBase_writelines_doc = 
        "";

    public final static String TextIOBase_writelines_sig = 
        "($self, lines, /)";

    // Docs for <class '_io.BufferedReader'>
    public final static String BufferedReader___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String BufferedReader___del___doc = 
        "";

    public final static String BufferedReader___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String BufferedReader___delattr___sig = 
        "($self, name, /)";

    public final static String BufferedReader___dir___doc = 
        "Default dir() implementation.";

    public final static String BufferedReader___dir___sig = 
        "($self, /)";

    public final static String BufferedReader_doc = 
        "Create a new buffered reader using the given readable raw IO object.";

    public final static String BufferedReader___enter___doc = 
        "";

    public final static String BufferedReader___eq___doc = 
        "Return self==value.";

    public final static String BufferedReader___eq___sig = 
        "($self, value, /)";

    public final static String BufferedReader___exit___doc = 
        "";

    public final static String BufferedReader___format___doc = 
        "Default object formatter.";

    public final static String BufferedReader___format___sig = 
        "($self, format_spec, /)";

    public final static String BufferedReader___ge___doc = 
        "Return self>=value.";

    public final static String BufferedReader___ge___sig = 
        "($self, value, /)";

    public final static String BufferedReader___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String BufferedReader___getattribute___sig = 
        "($self, name, /)";

    public final static String BufferedReader___getstate___doc = 
        "";

    public final static String BufferedReader___gt___doc = 
        "Return self>value.";

    public final static String BufferedReader___gt___sig = 
        "($self, value, /)";

    public final static String BufferedReader___hash___doc = 
        "Return hash(self).";

    public final static String BufferedReader___hash___sig = 
        "($self, /)";

    public final static String BufferedReader___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String BufferedReader___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String BufferedReader___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String BufferedReader___iter___doc = 
        "Implement iter(self).";

    public final static String BufferedReader___iter___sig = 
        "($self, /)";

    public final static String BufferedReader___le___doc = 
        "Return self<=value.";

    public final static String BufferedReader___le___sig = 
        "($self, value, /)";

    public final static String BufferedReader___lt___doc = 
        "Return self<value.";

    public final static String BufferedReader___lt___sig = 
        "($self, value, /)";

    public final static String BufferedReader___ne___doc = 
        "Return self!=value.";

    public final static String BufferedReader___ne___sig = 
        "($self, value, /)";

    public final static String BufferedReader___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String BufferedReader___new___sig = 
        "($type, *args, **kwargs)";

    public final static String BufferedReader___next___doc = 
        "Implement next(self).";

    public final static String BufferedReader___next___sig = 
        "($self, /)";

    public final static String BufferedReader___reduce___doc = 
        "Helper for pickle.";

    public final static String BufferedReader___reduce___sig = 
        "($self, /)";

    public final static String BufferedReader___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String BufferedReader___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String BufferedReader___repr___doc = 
        "Return repr(self).";

    public final static String BufferedReader___repr___sig = 
        "($self, /)";

    public final static String BufferedReader___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String BufferedReader___setattr___sig = 
        "($self, name, value, /)";

    public final static String BufferedReader___sizeof___doc = 
        "";

    public final static String BufferedReader___str___doc = 
        "Return str(self).";

    public final static String BufferedReader___str___sig = 
        "($self, /)";

    public final static String BufferedReader___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String BufferedReader__checkClosed_doc = 
        "";

    public final static String BufferedReader__checkReadable_doc = 
        "";

    public final static String BufferedReader__checkSeekable_doc = 
        "";

    public final static String BufferedReader__checkWritable_doc = 
        "";

    public final static String BufferedReader__dealloc_warn_doc = 
        "";

    public final static String BufferedReader_close_doc = 
        "";

    public final static String BufferedReader_detach_doc = 
        "";

    public final static String BufferedReader_fileno_doc = 
        "";

    public final static String BufferedReader_flush_doc = 
        "";

    public final static String BufferedReader_isatty_doc = 
        "";

    public final static String BufferedReader_peek_doc = 
        "";

    public final static String BufferedReader_peek_sig = 
        "($self, size=0, /)";

    public final static String BufferedReader_read_doc = 
        "";

    public final static String BufferedReader_read_sig = 
        "($self, size=-1, /)";

    public final static String BufferedReader_read1_doc = 
        "";

    public final static String BufferedReader_read1_sig = 
        "($self, size=-1, /)";

    public final static String BufferedReader_readable_doc = 
        "";

    public final static String BufferedReader_readinto_doc = 
        "";

    public final static String BufferedReader_readinto_sig = 
        "($self, buffer, /)";

    public final static String BufferedReader_readinto1_doc = 
        "";

    public final static String BufferedReader_readinto1_sig = 
        "($self, buffer, /)";

    public final static String BufferedReader_readline_doc = 
        "";

    public final static String BufferedReader_readline_sig = 
        "($self, size=-1, /)";

    public final static String BufferedReader_readlines_doc = 
        "Return a list of lines from the stream.\n" + 
        "\n" + 
        "hint can be specified to control the number of lines read: no more\n" + 
        "lines will be read if the total size (in bytes/characters) of all\n" + 
        "lines so far exceeds hint.";

    public final static String BufferedReader_readlines_sig = 
        "($self, hint=-1, /)";

    public final static String BufferedReader_seek_doc = 
        "";

    public final static String BufferedReader_seek_sig = 
        "($self, target, whence=0, /)";

    public final static String BufferedReader_seekable_doc = 
        "";

    public final static String BufferedReader_tell_doc = 
        "";

    public final static String BufferedReader_truncate_doc = 
        "";

    public final static String BufferedReader_truncate_sig = 
        "($self, pos=None, /)";

    public final static String BufferedReader_writable_doc = 
        "Return whether object was opened for writing.\n" + 
        "\n" + 
        "If False, write() will raise OSError.";

    public final static String BufferedReader_writable_sig = 
        "($self, /)";

    public final static String BufferedReader_write_doc = 
        "Write the given buffer to the IO stream.\n" + 
        "\n" + 
        "Returns the number of bytes written, which is always the length of b\n" + 
        "in bytes.\n" + 
        "\n" + 
        "Raises BlockingIOError if the buffer is full and the\n" + 
        "underlying raw stream cannot accept more data at the moment.\n" + 
        "";

    public final static String BufferedReader_writelines_doc = 
        "";

    public final static String BufferedReader_writelines_sig = 
        "($self, lines, /)";

    // Docs for <class '_io.BufferedWriter'>
    public final static String BufferedWriter___class___doc = 
        "type(object_or_name, bases, dict)\n" + 
        "type(object) -> the object's type\n" + 
        "type(name, bases, dict) -> a new type";

    public final static String BufferedWriter___del___doc = 
        "";

    public final static String BufferedWriter___delattr___doc = 
        "Implement delattr(self, name).";

    public final static String BufferedWriter___delattr___sig = 
        "($self, name, /)";

    public final static String BufferedWriter___dir___doc = 
        "Default dir() implementation.";

    public final static String BufferedWriter___dir___sig = 
        "($self, /)";

    public final static String BufferedWriter_doc = 
        "A buffer for a writeable sequential RawIO object.\n" + 
        "\n" + 
        "The constructor creates a BufferedWriter for the given writeable raw\n" + 
        "stream. If the buffer_size is not given, it defaults to\n" + 
        "DEFAULT_BUFFER_SIZE.";

    public final static String BufferedWriter___enter___doc = 
        "";

    public final static String BufferedWriter___eq___doc = 
        "Return self==value.";

    public final static String BufferedWriter___eq___sig = 
        "($self, value, /)";

    public final static String BufferedWriter___exit___doc = 
        "";

    public final static String BufferedWriter___format___doc = 
        "Default object formatter.";

    public final static String BufferedWriter___format___sig = 
        "($self, format_spec, /)";

    public final static String BufferedWriter___ge___doc = 
        "Return self>=value.";

    public final static String BufferedWriter___ge___sig = 
        "($self, value, /)";

    public final static String BufferedWriter___getattribute___doc = 
        "Return getattr(self, name).";

    public final static String BufferedWriter___getattribute___sig = 
        "($self, name, /)";

    public final static String BufferedWriter___getstate___doc = 
        "";

    public final static String BufferedWriter___gt___doc = 
        "Return self>value.";

    public final static String BufferedWriter___gt___sig = 
        "($self, value, /)";

    public final static String BufferedWriter___hash___doc = 
        "Return hash(self).";

    public final static String BufferedWriter___hash___sig = 
        "($self, /)";

    public final static String BufferedWriter___init___doc = 
        "Initialize self.  See help(type(self)) for accurate signature.";

    public final static String BufferedWriter___init___sig = 
        "($self, /, *args, **kwargs)";

    public final static String BufferedWriter___init_subclass___doc = 
        "This method is called when a class is subclassed.\n" + 
        "\n" + 
        "The default implementation does nothing. It may be\n" + 
        "overridden to extend subclasses.\n" + 
        "";

    public final static String BufferedWriter___iter___doc = 
        "Implement iter(self).";

    public final static String BufferedWriter___iter___sig = 
        "($self, /)";

    public final static String BufferedWriter___le___doc = 
        "Return self<=value.";

    public final static String BufferedWriter___le___sig = 
        "($self, value, /)";

    public final static String BufferedWriter___lt___doc = 
        "Return self<value.";

    public final static String BufferedWriter___lt___sig = 
        "($self, value, /)";

    public final static String BufferedWriter___ne___doc = 
        "Return self!=value.";

    public final static String BufferedWriter___ne___sig = 
        "($self, value, /)";

    public final static String BufferedWriter___new___doc = 
        "Create and return a new object.  See help(type) for accurate signature.";

    public final static String BufferedWriter___new___sig = 
        "($type, *args, **kwargs)";

    public final static String BufferedWriter___next___doc = 
        "Implement next(self).";

    public final static String BufferedWriter___next___sig = 
        "($self, /)";

    public final static String BufferedWriter___reduce___doc = 
        "Helper for pickle.";

    public final static String BufferedWriter___reduce___sig = 
        "($self, /)";

    public final static String BufferedWriter___reduce_ex___doc = 
        "Helper for pickle.";

    public final static String BufferedWriter___reduce_ex___sig = 
        "($self, protocol, /)";

    public final static String BufferedWriter___repr___doc = 
        "Return repr(self).";

    public final static String BufferedWriter___repr___sig = 
        "($self, /)";

    public final static String BufferedWriter___setattr___doc = 
        "Implement setattr(self, name, value).";

    public final static String BufferedWriter___setattr___sig = 
        "($self, name, value, /)";

    public final static String BufferedWriter___sizeof___doc = 
        "";

    public final static String BufferedWriter___str___doc = 
        "Return str(self).";

    public final static String BufferedWriter___str___sig = 
        "($self, /)";

    public final static String BufferedWriter___subclasshook___doc = 
        "Abstract classes can override this to customize issubclass().\n" + 
        "\n" + 
        "This is invoked early on by abc.ABCMeta.__subclasscheck__().\n" + 
        "It should return True, False or NotImplemented.  If it returns\n" + 
        "NotImplemented, the normal algorithm is used.  Otherwise, it\n" + 
        "overrides the normal algorithm (and the outcome is cached).\n" + 
        "";

    public final static String BufferedWriter__checkClosed_doc = 
        "";

    public final static String BufferedWriter__checkReadable_doc = 
        "";

    public final static String BufferedWriter__checkSeekable_doc = 
        "";

    public final static String BufferedWriter__checkWritable_doc = 
        "";

    public final static String BufferedWriter__dealloc_warn_doc = 
        "";

    public final static String BufferedWriter_close_doc = 
        "";

    public final static String BufferedWriter_detach_doc = 
        "";

    public final static String BufferedWriter_fileno_doc = 
        "";

    public final static String BufferedWriter_flush_doc = 
        "";

    public final static String BufferedWriter_isatty_doc = 
        "";

    public final static String BufferedWriter_read_doc = 
        "Read and return up to n bytes.\n" + 
        "\n" + 
        "If the argument is omitted, None, or negative, reads and\n" + 
        "returns all data until EOF.\n" + 
        "\n" + 
        "If the argument is positive, and the underlying raw stream is\n" + 
        "not 'interactive', multiple raw reads may be issued to satisfy\n" + 
        "the byte count (unless EOF is reached first).  But for\n" + 
        "interactive raw streams (as well as sockets and pipes), at most\n" + 
        "one raw read will be issued, and a short result does not imply\n" + 
        "that EOF is imminent.\n" + 
        "\n" + 
        "Returns an empty bytes object on EOF.\n" + 
        "\n" + 
        "Returns None if the underlying raw stream was open in non-blocking\n" + 
        "mode and no data is available at the moment.\n" + 
        "";

    public final static String BufferedWriter_read1_doc = 
        "Read and return up to n bytes, with at most one read() call\n" + 
        "to the underlying raw stream. A short result does not imply\n" + 
        "that EOF is imminent.\n" + 
        "\n" + 
        "Returns an empty bytes object on EOF.\n" + 
        "";

    public final static String BufferedWriter_readable_doc = 
        "Return whether object was opened for reading.\n" + 
        "\n" + 
        "If False, read() will raise OSError.";

    public final static String BufferedWriter_readable_sig = 
        "($self, /)";

    public final static String BufferedWriter_readinto_doc = 
        "";

    public final static String BufferedWriter_readinto_sig = 
        "($self, buffer, /)";

    public final static String BufferedWriter_readinto1_doc = 
        "";

    public final static String BufferedWriter_readinto1_sig = 
        "($self, buffer, /)";

    public final static String BufferedWriter_readline_doc = 
        "Read and return a line from the stream.\n" + 
        "\n" + 
        "If size is specified, at most size bytes will be read.\n" + 
        "\n" + 
        "The line terminator is always b'\\n' for binary files; for text\n" + 
        "files, the newlines argument to open can be used to select the line\n" + 
        "terminator(s) recognized.";

    public final static String BufferedWriter_readline_sig = 
        "($self, size=-1, /)";

    public final static String BufferedWriter_readlines_doc = 
        "Return a list of lines from the stream.\n" + 
        "\n" + 
        "hint can be specified to control the number of lines read: no more\n" + 
        "lines will be read if the total size (in bytes/characters) of all\n" + 
        "lines so far exceeds hint.";

    public final static String BufferedWriter_readlines_sig = 
        "($self, hint=-1, /)";

    public final static String BufferedWriter_seek_doc = 
        "";

    public final static String BufferedWriter_seek_sig = 
        "($self, target, whence=0, /)";

    public final static String BufferedWriter_seekable_doc = 
        "";

    public final static String BufferedWriter_tell_doc = 
        "";

    public final static String BufferedWriter_truncate_doc = 
        "";

    public final static String BufferedWriter_truncate_sig = 
        "($self, pos=None, /)";

    public final static String BufferedWriter_writable_doc = 
        "";

    public final static String BufferedWriter_write_doc = 
        "";

    public final static String BufferedWriter_write_sig = 
        "($self, buffer, /)";

    public final static String BufferedWriter_writelines_doc = 
        "";

    public final static String BufferedWriter_writelines_sig = 
        "($self, lines, /)";

    // Docs for <module 'array' from '/home/isaiah/codes/python/build/lib.linux-x86_64-3.7/array.cpython-37m-x86_64-linux-gnu.so'>
    public final static String array_ArrayType_doc = 
        "array(typecode [, initializer]) -> array\n" + 
        "\n" + 
        "Return a new array whose items are restricted by typecode, and\n" + 
        "initialized from the optional initializer value, which must be a list,\n" + 
        "string or iterable over elements of the appropriate type.\n" + 
        "\n" + 
        "Arrays represent basic values and behave very much like lists, except\n" + 
        "the type of objects stored in them is constrained. The type is specified\n" + 
        "at object creation time by using a type code, which is a single character.\n" + 
        "The following type codes are defined:\n" + 
        "\n" + 
        "    Type code   C Type             Minimum size in bytes \n" + 
        "    'b'         signed integer     1 \n" + 
        "    'B'         unsigned integer   1 \n" + 
        "    'u'         Unicode character  2 (see note) \n" + 
        "    'h'         signed integer     2 \n" + 
        "    'H'         unsigned integer   2 \n" + 
        "    'i'         signed integer     2 \n" + 
        "    'I'         unsigned integer   2 \n" + 
        "    'l'         signed integer     4 \n" + 
        "    'L'         unsigned integer   4 \n" + 
        "    'q'         signed integer     8 (see note) \n" + 
        "    'Q'         unsigned integer   8 (see note) \n" + 
        "    'f'         floating point     4 \n" + 
        "    'd'         floating point     8 \n" + 
        "\n" + 
        "NOTE: The 'u' typecode corresponds to Python's unicode character. On \n" + 
        "narrow builds this is 2-bytes on wide builds this is 4-bytes.\n" + 
        "\n" + 
        "NOTE: The 'q' and 'Q' type codes are only available if the platform \n" + 
        "C compiler used to build Python supports 'long long', or, on Windows, \n" + 
        "'__int64'.\n" + 
        "\n" + 
        "Methods:\n" + 
        "\n" + 
        "append() -- append a new item to the end of the array\n" + 
        "buffer_info() -- return information giving the current memory info\n" + 
        "byteswap() -- byteswap all the items of the array\n" + 
        "count() -- return number of occurrences of an object\n" + 
        "extend() -- extend array by appending multiple elements from an iterable\n" + 
        "fromfile() -- read items from a file object\n" + 
        "fromlist() -- append items from the list\n" + 
        "frombytes() -- append items from the string\n" + 
        "index() -- return index of first occurrence of an object\n" + 
        "insert() -- insert a new item into the array at a provided position\n" + 
        "pop() -- remove and return item (default last)\n" + 
        "remove() -- remove first occurrence of an object\n" + 
        "reverse() -- reverse the order of the items in the array\n" + 
        "tofile() -- write all items to a file object\n" + 
        "tolist() -- return the array converted to an ordinary list\n" + 
        "tobytes() -- return the array converted to a string\n" + 
        "\n" + 
        "Attributes:\n" + 
        "\n" + 
        "typecode -- the typecode character used to create the array\n" + 
        "itemsize -- the length in bytes of one array item\n" + 
        "";

    public final static String array_doc = 
        "This module defines an object type which can efficiently represent\n" + 
        "an array of basic values: characters, integers, floating point\n" + 
        "numbers.  Arrays are sequence types and behave very much like lists,\n" + 
        "except that the type of objects stored in them is constrained.\n" + 
        "";

    public final static String array__array_reconstructor_doc = 
        "Internal. Used for pickling support.";

    public final static String array__array_reconstructor_sig = 
        "($module, arraytype, typecode, mformat_code, items,\n" + 
        "                     /)";

    public final static String array_array_doc = 
        "array(typecode [, initializer]) -> array\n" + 
        "\n" + 
        "Return a new array whose items are restricted by typecode, and\n" + 
        "initialized from the optional initializer value, which must be a list,\n" + 
        "string or iterable over elements of the appropriate type.\n" + 
        "\n" + 
        "Arrays represent basic values and behave very much like lists, except\n" + 
        "the type of objects stored in them is constrained. The type is specified\n" + 
        "at object creation time by using a type code, which is a single character.\n" + 
        "The following type codes are defined:\n" + 
        "\n" + 
        "    Type code   C Type             Minimum size in bytes \n" + 
        "    'b'         signed integer     1 \n" + 
        "    'B'         unsigned integer   1 \n" + 
        "    'u'         Unicode character  2 (see note) \n" + 
        "    'h'         signed integer     2 \n" + 
        "    'H'         unsigned integer   2 \n" + 
        "    'i'         signed integer     2 \n" + 
        "    'I'         unsigned integer   2 \n" + 
        "    'l'         signed integer     4 \n" + 
        "    'L'         unsigned integer   4 \n" + 
        "    'q'         signed integer     8 (see note) \n" + 
        "    'Q'         unsigned integer   8 (see note) \n" + 
        "    'f'         floating point     4 \n" + 
        "    'd'         floating point     8 \n" + 
        "\n" + 
        "NOTE: The 'u' typecode corresponds to Python's unicode character. On \n" + 
        "narrow builds this is 2-bytes on wide builds this is 4-bytes.\n" + 
        "\n" + 
        "NOTE: The 'q' and 'Q' type codes are only available if the platform \n" + 
        "C compiler used to build Python supports 'long long', or, on Windows, \n" + 
        "'__int64'.\n" + 
        "\n" + 
        "Methods:\n" + 
        "\n" + 
        "append() -- append a new item to the end of the array\n" + 
        "buffer_info() -- return information giving the current memory info\n" + 
        "byteswap() -- byteswap all the items of the array\n" + 
        "count() -- return number of occurrences of an object\n" + 
        "extend() -- extend array by appending multiple elements from an iterable\n" + 
        "fromfile() -- read items from a file object\n" + 
        "fromlist() -- append items from the list\n" + 
        "frombytes() -- append items from the string\n" + 
        "index() -- return index of first occurrence of an object\n" + 
        "insert() -- insert a new item into the array at a provided position\n" + 
        "pop() -- remove and return item (default last)\n" + 
        "remove() -- remove first occurrence of an object\n" + 
        "reverse() -- reverse the order of the items in the array\n" + 
        "tofile() -- write all items to a file object\n" + 
        "tolist() -- return the array converted to an ordinary list\n" + 
        "tobytes() -- return the array converted to a string\n" + 
        "\n" + 
        "Attributes:\n" + 
        "\n" + 
        "typecode -- the typecode character used to create the array\n" + 
        "itemsize -- the length in bytes of one array item\n" + 
        "";

    // Docs for <module 'csv' from '/home/isaiah/codes/python/Lib/csv.py'>
    public final static String csv_Dialect_doc = 
        "Describe a CSV dialect.\n" + 
        "\n" + 
        "    This must be subclassed (see csv.excel).  Valid attributes are:\n" + 
        "    delimiter, quotechar, escapechar, doublequote, skipinitialspace,\n" + 
        "    lineterminator, quoting.\n" + 
        "\n" + 
        "    ";

    public final static String csv_DictReader_doc = 
        "";

    public final static String csv_DictWriter_doc = 
        "";

    public final static String csv_Error_doc = 
        "";

    public final static String csv_OrderedDict_doc = 
        "Dictionary that remembers insertion order";

    public final static String csv_Sniffer_doc = 
        "\n" + 
        "    \"Sniffs\" the format of a CSV file (i.e. delimiter, quotechar)\n" + 
        "    Returns a Dialect object.\n" + 
        "    ";

    public final static String csv_StringIO_doc = 
        "Text I/O implementation using an in-memory buffer.\n" + 
        "\n" + 
        "The initial_value argument sets the value of object.  The newline\n" + 
        "argument is like the one of TextIOWrapper's constructor.";

    public final static String csv_StringIO_sig = 
        "(initial_value='', newline='\\n')";

    public final static String csv__Dialect_doc = 
        "CSV dialect\n" + 
        "\n" + 
        "The Dialect type records CSV parsing and generation options.\n" + 
        "";

    public final static String csv_doc = 
        "CSV parsing and writing.\n" + 
        "\n" + 
        "This module provides classes that assist in the reading and writing\n" + 
        "of Comma Separated Value (CSV) files, and implements the interface\n" + 
        "described by PEP 305.  Although many CSV files are simple to parse,\n" + 
        "the format is not formally defined by a stable specification and\n" + 
        "is subtle enough that parsing lines of a CSV file with something\n" + 
        "like line.split(\",\") is bound to fail.  The module supports three\n" + 
        "basic APIs: reading, writing, and registration of dialects.\n" + 
        "\n" + 
        "\n" + 
        "DIALECT REGISTRATION:\n" + 
        "\n" + 
        "Readers and writers support a dialect argument, which is a convenient\n" + 
        "handle on a group of settings.  When the dialect argument is a string,\n" + 
        "it identifies one of the dialects previously registered with the module.\n" + 
        "If it is a class or instance, the attributes of the argument are used as\n" + 
        "the settings for the reader or writer:\n" + 
        "\n" + 
        "    class excel:\n" + 
        "        delimiter = ','\n" + 
        "        quotechar = '\"'\n" + 
        "        escapechar = None\n" + 
        "        doublequote = True\n" + 
        "        skipinitialspace = False\n" + 
        "        lineterminator = '\\r\\n'\n" + 
        "        quoting = QUOTE_MINIMAL\n" + 
        "\n" + 
        "SETTINGS:\n" + 
        "\n" + 
        "    * quotechar - specifies a one-character string to use as the \n" + 
        "        quoting character.  It defaults to '\"'.\n" + 
        "    * delimiter - specifies a one-character string to use as the \n" + 
        "        field separator.  It defaults to ','.\n" + 
        "    * skipinitialspace - specifies how to interpret whitespace which\n" + 
        "        immediately follows a delimiter.  It defaults to False, which\n" + 
        "        means that whitespace immediately following a delimiter is part\n" + 
        "        of the following field.\n" + 
        "    * lineterminator -  specifies the character sequence which should \n" + 
        "        terminate rows.\n" + 
        "    * quoting - controls when quotes should be generated by the writer.\n" + 
        "        It can take on any of the following module constants:\n" + 
        "\n" + 
        "        csv.QUOTE_MINIMAL means only when required, for example, when a\n" + 
        "            field contains either the quotechar or the delimiter\n" + 
        "        csv.QUOTE_ALL means that quotes are always placed around fields.\n" + 
        "        csv.QUOTE_NONNUMERIC means that quotes are always placed around\n" + 
        "            fields which do not parse as integers or floating point\n" + 
        "            numbers.\n" + 
        "        csv.QUOTE_NONE means that quotes are never placed around fields.\n" + 
        "    * escapechar - specifies a one-character string used to escape \n" + 
        "        the delimiter when quoting is set to QUOTE_NONE.\n" + 
        "    * doublequote - controls the handling of quotes inside fields.  When\n" + 
        "        True, two consecutive quotes are interpreted as one during read,\n" + 
        "        and when writing, each quote character embedded in the data is\n" + 
        "        written as two quotes\n" + 
        "";

    public final static String csv_excel_doc = 
        "Describe the usual properties of Excel-generated CSV files.";

    public final static String csv_excel_tab_doc = 
        "Describe the usual properties of Excel-generated TAB-delimited files.";

    public final static String csv_field_size_limit_doc = 
        "Sets an upper limit on parsed fields.\n" + 
        "    csv.field_size_limit([limit])\n" + 
        "\n" + 
        "Returns old limit. If limit is not given, no new limit is set and\n" + 
        "the old limit is returned";

    public final static String csv_get_dialect_doc = 
        "Return the dialect instance associated with name.\n" + 
        "    dialect = csv.get_dialect(name)";

    public final static String csv_list_dialects_doc = 
        "Return a list of all know dialect names.\n" + 
        "    names = csv.list_dialects()";

    public final static String csv_reader_doc = 
        "    csv_reader = reader(iterable [, dialect='excel']\n" + 
        "                        [optional keyword args])\n" + 
        "    for row in csv_reader:\n" + 
        "        process(row)\n" + 
        "\n" + 
        "The \"iterable\" argument can be any object that returns a line\n" + 
        "of input for each iteration, such as a file object or a list.  The\n" + 
        "optional \"dialect\" parameter is discussed below.  The function\n" + 
        "also accepts optional keyword arguments which override settings\n" + 
        "provided by the dialect.\n" + 
        "\n" + 
        "The returned object is an iterator.  Each iteration returns a row\n" + 
        "of the CSV file (which can span multiple input lines).\n" + 
        "";

    public final static String csv_register_dialect_doc = 
        "Create a mapping from a string name to a dialect class.\n" + 
        "    dialect = csv.register_dialect(name[, dialect[, **fmtparams]])";

    public final static String csv_unix_dialect_doc = 
        "Describe the usual properties of Unix-generated CSV files.";

    public final static String csv_unregister_dialect_doc = 
        "Delete the name/dialect mapping associated with a string name.\n" + 
        "    csv.unregister_dialect(name)";

    public final static String csv_writer_doc = 
        "    csv_writer = csv.writer(fileobj [, dialect='excel']\n" + 
        "                            [optional keyword args])\n" + 
        "    for row in sequence:\n" + 
        "        csv_writer.writerow(row)\n" + 
        "\n" + 
        "    [or]\n" + 
        "\n" + 
        "    csv_writer = csv.writer(fileobj [, dialect='excel']\n" + 
        "                            [optional keyword args])\n" + 
        "    csv_writer.writerows(rows)\n" + 
        "\n" + 
        "The \"fileobj\" argument can be any object that supports the file API.\n" + 
        "";

    // Docs for <module 'errno' (built-in)>
    public final static String errno_doc = 
        "This module makes available standard errno system symbols.\n" + 
        "\n" + 
        "The value of each symbol is the corresponding integer value,\n" + 
        "e.g., on most systems, errno.ENOENT equals the integer 2.\n" + 
        "\n" + 
        "The dictionary errno.errorcode maps numeric codes to symbol names,\n" + 
        "e.g., errno.errorcode[2] could be the string 'ENOENT'.\n" + 
        "\n" + 
        "Symbols that are not relevant to the underlying system are not defined.\n" + 
        "\n" + 
        "To map error codes to error messages, use the function os.strerror(),\n" + 
        "e.g. os.strerror(2) could return 'No such file or directory'.";

    public final static String errno___loader___doc = 
        "Meta path import for built-in modules.\n" + 
        "\n" + 
        "    All methods are either class or static methods to avoid the need to\n" + 
        "    instantiate the class.\n" + 
        "\n" + 
        "    ";

    // Docs for <module 'itertools' (built-in)>
    public final static String itertools_doc = 
        "Functional tools for creating and using iterators.\n" + 
        "\n" + 
        "Infinite iterators:\n" + 
        "count(start=0, step=1) --> start, start+step, start+2*step, ...\n" + 
        "cycle(p) --> p0, p1, ... plast, p0, p1, ...\n" + 
        "repeat(elem [,n]) --> elem, elem, elem, ... endlessly or up to n times\n" + 
        "\n" + 
        "Iterators terminating on the shortest input sequence:\n" + 
        "accumulate(p[, func]) --> p0, p0+p1, p0+p1+p2\n" + 
        "chain(p, q, ...) --> p0, p1, ... plast, q0, q1, ... \n" + 
        "chain.from_iterable([p, q, ...]) --> p0, p1, ... plast, q0, q1, ... \n" + 
        "compress(data, selectors) --> (d[0] if s[0]), (d[1] if s[1]), ...\n" + 
        "dropwhile(pred, seq) --> seq[n], seq[n+1], starting when pred fails\n" + 
        "groupby(iterable[, keyfunc]) --> sub-iterators grouped by value of keyfunc(v)\n" + 
        "filterfalse(pred, seq) --> elements of seq where pred(elem) is False\n" + 
        "islice(seq, [start,] stop [, step]) --> elements from\n" + 
        "       seq[start:stop:step]\n" + 
        "starmap(fun, seq) --> fun(*seq[0]), fun(*seq[1]), ...\n" + 
        "tee(it, n=2) --> (it1, it2 , ... itn) splits one iterator into n\n" + 
        "takewhile(pred, seq) --> seq[0], seq[1], until pred fails\n" + 
        "zip_longest(p, q, ...) --> (p[0], q[0]), (p[1], q[1]), ... \n" + 
        "\n" + 
        "Combinatoric generators:\n" + 
        "product(p, q, ... [repeat=1]) --> cartesian product\n" + 
        "permutations(p[, r])\n" + 
        "combinations(p, r)\n" + 
        "combinations_with_replacement(p, r)\n" + 
        "";

    public final static String itertools___loader___doc = 
        "Meta path import for built-in modules.\n" + 
        "\n" + 
        "    All methods are either class or static methods to avoid the need to\n" + 
        "    instantiate the class.\n" + 
        "\n" + 
        "    ";

    public final static String itertools__grouper_doc = 
        "";

    public final static String itertools__tee_doc = 
        "Iterator wrapped to make it copyable";

    public final static String itertools__tee_dataobject_doc = 
        "Data container common to multiple tee objects.";

    public final static String itertools_accumulate_doc = 
        "accumulate(iterable[, func]) --> accumulate object\n" + 
        "\n" + 
        "Return series of accumulated sums (or other binary function results).";

    public final static String itertools_chain_doc = 
        "chain(*iterables) --> chain object\n" + 
        "\n" + 
        "Return a chain object whose .__next__() method returns elements from the\n" + 
        "first iterable until it is exhausted, then elements from the next\n" + 
        "iterable, until all of the iterables are exhausted.";

    public final static String itertools_combinations_doc = 
        "combinations(iterable, r) --> combinations object\n" + 
        "\n" + 
        "Return successive r-length combinations of elements in the iterable.\n" + 
        "\n" + 
        "combinations(range(4), 3) --> (0,1,2), (0,1,3), (0,2,3), (1,2,3)";

    public final static String itertools_combinations_with_replacement_doc = 
        "combinations_with_replacement(iterable, r) --> combinations_with_replacement object\n" + 
        "\n" + 
        "Return successive r-length combinations of elements in the iterable\n" + 
        "allowing individual elements to have successive repeats.\n" + 
        "combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC";

    public final static String itertools_compress_doc = 
        "compress(data, selectors) --> iterator over selected data\n" + 
        "\n" + 
        "Return data elements corresponding to true selector elements.\n" + 
        "Forms a shorter iterator from selected data elements using the\n" + 
        "selectors to choose the data elements.";

    public final static String itertools_count_doc = 
        "count(start=0, step=1) --> count object\n" + 
        "\n" + 
        "Return a count object whose .__next__() method returns consecutive values.\n" + 
        "Equivalent to:\n" + 
        "\n" + 
        "    def count(firstval=0, step=1):\n" + 
        "        x = firstval\n" + 
        "        while 1:\n" + 
        "            yield x\n" + 
        "            x += step\n" + 
        "";

    public final static String itertools_cycle_doc = 
        "cycle(iterable) --> cycle object\n" + 
        "\n" + 
        "Return elements from the iterable until it is exhausted.\n" + 
        "Then repeat the sequence indefinitely.";

    public final static String itertools_dropwhile_doc = 
        "dropwhile(predicate, iterable) --> dropwhile object\n" + 
        "\n" + 
        "Drop items from the iterable while predicate(item) is true.\n" + 
        "Afterwards, return every element until the iterable is exhausted.";

    public final static String itertools_filterfalse_doc = 
        "filterfalse(function or None, sequence) --> filterfalse object\n" + 
        "\n" + 
        "Return those items of sequence for which function(item) is false.\n" + 
        "If function is None, return the items that are false.";

    public final static String itertools_groupby_doc = 
        "groupby(iterable, key=None) -> make an iterator that returns consecutive\n" + 
        "keys and groups from the iterable.  If the key function is not specified or\n" + 
        "is None, the element itself is used for grouping.\n" + 
        "";

    public final static String itertools_islice_doc = 
        "islice(iterable, stop) --> islice object\n" + 
        "islice(iterable, start, stop[, step]) --> islice object\n" + 
        "\n" + 
        "Return an iterator whose next() method returns selected values from an\n" + 
        "iterable.  If start is specified, will skip all preceding elements;\n" + 
        "otherwise, start defaults to zero.  Step defaults to one.  If\n" + 
        "specified as another value, step determines how many values are \n" + 
        "skipped between successive calls.  Works like a slice() on a list\n" + 
        "but returns an iterator.";

    public final static String itertools_permutations_doc = 
        "permutations(iterable[, r]) --> permutations object\n" + 
        "\n" + 
        "Return successive r-length permutations of elements in the iterable.\n" + 
        "\n" + 
        "permutations(range(3), 2) --> (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)";

    public final static String itertools_product_doc = 
        "product(*iterables, repeat=1) --> product object\n" + 
        "\n" + 
        "Cartesian product of input iterables.  Equivalent to nested for-loops.\n" + 
        "\n" + 
        "For example, product(A, B) returns the same as:  ((x,y) for x in A for y in B).\n" + 
        "The leftmost iterators are in the outermost for-loop, so the output tuples\n" + 
        "cycle in a manner similar to an odometer (with the rightmost element changing\n" + 
        "on every iteration).\n" + 
        "\n" + 
        "To compute the product of an iterable with itself, specify the number\n" + 
        "of repetitions with the optional repeat keyword argument. For example,\n" + 
        "product(A, repeat=4) means the same as product(A, A, A, A).\n" + 
        "\n" + 
        "product('ab', range(3)) --> ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\n" + 
        "product((0,1), (0,1), (0,1)) --> (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...";

    public final static String itertools_repeat_doc = 
        "repeat(object [,times]) -> create an iterator which returns the object\n" + 
        "for the specified number of times.  If not specified, returns the object\n" + 
        "endlessly.";

    public final static String itertools_starmap_doc = 
        "starmap(function, sequence) --> starmap object\n" + 
        "\n" + 
        "Return an iterator whose values are returned from the function evaluated\n" + 
        "with an argument tuple taken from the given sequence.";

    public final static String itertools_takewhile_doc = 
        "takewhile(predicate, iterable) --> takewhile object\n" + 
        "\n" + 
        "Return successive entries from an iterable as long as the \n" + 
        "predicate evaluates to true for each entry.";

    public final static String itertools_tee_doc = 
        "tee(iterable, n=2) --> tuple of n independent iterators.";

    public final static String itertools_zip_longest_doc = 
        "zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --> zip_longest object\n" + 
        "\n" + 
        "Return a zip_longest object whose .__next__() method returns a tuple where\n" + 
        "the i-th element comes from the i-th iterable argument.  The .__next__()\n" + 
        "method continues until the longest iterable in the argument sequence\n" + 
        "is exhausted and then it raises StopIteration.  When the shorter iterables\n" + 
        "are exhausted, the fillvalue is substituted in their place.  The fillvalue\n" + 
        "defaults to None or can be specified by a keyword argument.\n" + 
        "";

    // Docs for <module 'posix' (built-in)>
    public final static String posix_DirEntry_doc = 
        "";

    public final static String posix_WCOREDUMP_doc = 
        "Return True if the process returning status was dumped to a core file.";

    public final static String posix_WCOREDUMP_sig = 
        "($module, status, /)";

    public final static String posix_WEXITSTATUS_doc = 
        "Return the process return code from status.";

    public final static String posix_WEXITSTATUS_sig = 
        "($module, /, status)";

    public final static String posix_WIFCONTINUED_doc = 
        "Return True if a particular process was continued from a job control stop.\n" + 
        "\n" + 
        "Return True if the process returning status was continued from a\n" + 
        "job control stop.";

    public final static String posix_WIFCONTINUED_sig = 
        "($module, /, status)";

    public final static String posix_WIFEXITED_doc = 
        "Return True if the process returning status exited via the exit() system call.";

    public final static String posix_WIFEXITED_sig = 
        "($module, /, status)";

    public final static String posix_WIFSIGNALED_doc = 
        "Return True if the process returning status was terminated by a signal.";

    public final static String posix_WIFSIGNALED_sig = 
        "($module, /, status)";

    public final static String posix_WIFSTOPPED_doc = 
        "Return True if the process returning status was stopped.";

    public final static String posix_WIFSTOPPED_sig = 
        "($module, /, status)";

    public final static String posix_WSTOPSIG_doc = 
        "Return the signal that stopped the process that provided the status value.";

    public final static String posix_WSTOPSIG_sig = 
        "($module, /, status)";

    public final static String posix_WTERMSIG_doc = 
        "Return the signal that terminated the process that provided the status value.";

    public final static String posix_WTERMSIG_sig = 
        "($module, /, status)";

    public final static String posix_doc = 
        "This module provides access to operating system functionality that is\n" + 
        "standardized by the C Standard and the POSIX standard (a thinly\n" + 
        "disguised Unix interface).  Refer to the library manual and\n" + 
        "corresponding Unix manual entries for more information on calls.";

    public final static String posix___loader___doc = 
        "Meta path import for built-in modules.\n" + 
        "\n" + 
        "    All methods are either class or static methods to avoid the need to\n" + 
        "    instantiate the class.\n" + 
        "\n" + 
        "    ";

    public final static String posix__exit_doc = 
        "Exit to the system with specified status, without normal exit processing.";

    public final static String posix__exit_sig = 
        "($module, /, status)";

    public final static String posix_abort_doc = 
        "Abort the interpreter immediately.\n" + 
        "\n" + 
        "This function 'dumps core' or otherwise fails in the hardest way possible\n" + 
        "on the hosting operating system.  This function never returns.";

    public final static String posix_abort_sig = 
        "($module, /)";

    public final static String posix_access_doc = 
        "Use the real uid/gid to test for access to a path.\n" + 
        "\n" + 
        "  path\n" + 
        "    Path to be tested; can be string or bytes\n" + 
        "  mode\n" + 
        "    Operating-system mode bitfield.  Can be F_OK to test existence,\n" + 
        "    or the inclusive-OR of R_OK, W_OK, and X_OK.\n" + 
        "  dir_fd\n" + 
        "    If not None, it should be a file descriptor open to a directory,\n" + 
        "    and path should be relative; path will then be relative to that\n" + 
        "    directory.\n" + 
        "  effective_ids\n" + 
        "    If True, access will use the effective uid/gid instead of\n" + 
        "    the real uid/gid.\n" + 
        "  follow_symlinks\n" + 
        "    If False, and the last element of the path is a symbolic link,\n" + 
        "    access will examine the symbolic link itself instead of the file\n" + 
        "    the link points to.\n" + 
        "\n" + 
        "dir_fd, effective_ids, and follow_symlinks may not be implemented\n" + 
        "  on your platform.  If they are unavailable, using them will raise a\n" + 
        "  NotImplementedError.\n" + 
        "\n" + 
        "Note that most operations will use the effective uid/gid, therefore this\n" + 
        "  routine can be used in a suid/sgid environment to test if the invoking user\n" + 
        "  has the specified access to the path.";

    public final static String posix_access_sig = 
        "($module, /, path, mode, *, dir_fd=None, effective_ids=False,\n" + 
        "       follow_symlinks=True)";

    public final static String posix_chdir_doc = 
        "Change the current working directory to the specified path.\n" + 
        "\n" + 
        "path may always be specified as a string.\n" + 
        "On some platforms, path may also be specified as an open file descriptor.\n" + 
        "  If this functionality is unavailable, using it raises an exception.";

    public final static String posix_chdir_sig = 
        "($module, /, path)";

    public final static String posix_chmod_doc = 
        "Change the access permissions of a file.\n" + 
        "\n" + 
        "  path\n" + 
        "    Path to be modified.  May always be specified as a str or bytes.\n" + 
        "    On some platforms, path may also be specified as an open file descriptor.\n" + 
        "    If this functionality is unavailable, using it raises an exception.\n" + 
        "  mode\n" + 
        "    Operating-system mode bitfield.\n" + 
        "  dir_fd\n" + 
        "    If not None, it should be a file descriptor open to a directory,\n" + 
        "    and path should be relative; path will then be relative to that\n" + 
        "    directory.\n" + 
        "  follow_symlinks\n" + 
        "    If False, and the last element of the path is a symbolic link,\n" + 
        "    chmod will modify the symbolic link itself instead of the file\n" + 
        "    the link points to.\n" + 
        "\n" + 
        "It is an error to use dir_fd or follow_symlinks when specifying path as\n" + 
        "  an open file descriptor.\n" + 
        "dir_fd and follow_symlinks may not be implemented on your platform.\n" + 
        "  If they are unavailable, using them will raise a NotImplementedError.";

    public final static String posix_chmod_sig = 
        "($module, /, path, mode, *, dir_fd=None, follow_symlinks=True)";

    public final static String posix_chown_doc = 
        "Change the owner and group id of path to the numeric uid and gid.\\\n" + 
        "\n" + 
        "  path\n" + 
        "    Path to be examined; can be string, bytes, or open-file-descriptor int.\n" + 
        "  dir_fd\n" + 
        "    If not None, it should be a file descriptor open to a directory,\n" + 
        "    and path should be relative; path will then be relative to that\n" + 
        "    directory.\n" + 
        "  follow_symlinks\n" + 
        "    If False, and the last element of the path is a symbolic link,\n" + 
        "    stat will examine the symbolic link itself instead of the file\n" + 
        "    the link points to.\n" + 
        "\n" + 
        "path may always be specified as a string.\n" + 
        "On some platforms, path may also be specified as an open file descriptor.\n" + 
        "  If this functionality is unavailable, using it raises an exception.\n" + 
        "If dir_fd is not None, it should be a file descriptor open to a directory,\n" + 
        "  and path should be relative; path will then be relative to that directory.\n" + 
        "If follow_symlinks is False, and the last element of the path is a symbolic\n" + 
        "  link, chown will modify the symbolic link itself instead of the file the\n" + 
        "  link points to.\n" + 
        "It is an error to use dir_fd or follow_symlinks when specifying path as\n" + 
        "  an open file descriptor.\n" + 
        "dir_fd and follow_symlinks may not be implemented on your platform.\n" + 
        "  If they are unavailable, using them will raise a NotImplementedError.";

    public final static String posix_chown_sig = 
        "($module, /, path, uid, gid, *, dir_fd=None, follow_symlinks=True)";

    public final static String posix_chroot_doc = 
        "Change root directory to path.";

    public final static String posix_chroot_sig = 
        "($module, /, path)";

    public final static String posix_close_doc = 
        "Close a file descriptor.";

    public final static String posix_close_sig = 
        "($module, /, fd)";

    public final static String posix_closerange_doc = 
        "Closes all file descriptors in [fd_low, fd_high), ignoring errors.";

    public final static String posix_closerange_sig = 
        "($module, fd_low, fd_high, /)";

    public final static String posix_confstr_doc = 
        "Return a string-valued system configuration variable.";

    public final static String posix_confstr_sig = 
        "($module, name, /)";

    public final static String posix_cpu_count_doc = 
        "Return the number of CPUs in the system; return None if indeterminable.\n" + 
        "\n" + 
        "This number is not equivalent to the number of CPUs the current process can\n" + 
        "use.  The number of usable CPUs can be obtained with\n" + 
        "``len(os.sched_getaffinity(0))``";

    public final static String posix_cpu_count_sig = 
        "($module, /)";

    public final static String posix_ctermid_doc = 
        "Return the name of the controlling terminal for this process.";

    public final static String posix_ctermid_sig = 
        "($module, /)";

    public final static String posix_device_encoding_doc = 
        "Return a string describing the encoding of a terminal's file descriptor.\n" + 
        "\n" + 
        "The file descriptor must be attached to a terminal.\n" + 
        "If the device is not a terminal, return None.";

    public final static String posix_device_encoding_sig = 
        "($module, /, fd)";

    public final static String posix_dup_doc = 
        "Return a duplicate of a file descriptor.";

    public final static String posix_dup_sig = 
        "($module, fd, /)";

    public final static String posix_dup2_doc = 
        "Duplicate file descriptor.";

    public final static String posix_dup2_sig = 
        "($module, /, fd, fd2, inheritable=True)";

    public final static String posix_error_doc = 
        "Base class for I/O related errors.";

    public final static String posix_execv_doc = 
        "Execute an executable path with arguments, replacing current process.\n" + 
        "\n" + 
        "  path\n" + 
        "    Path of executable file.\n" + 
        "  argv\n" + 
        "    Tuple or list of strings.";

    public final static String posix_execv_sig = 
        "($module, path, argv, /)";

    public final static String posix_execve_doc = 
        "Execute an executable path with arguments, replacing current process.\n" + 
        "\n" + 
        "  path\n" + 
        "    Path of executable file.\n" + 
        "  argv\n" + 
        "    Tuple or list of strings.\n" + 
        "  env\n" + 
        "    Dictionary of strings mapping to strings.";

    public final static String posix_execve_sig = 
        "($module, /, path, argv, env)";

    public final static String posix_fchdir_doc = 
        "Change to the directory of the given file descriptor.\n" + 
        "\n" + 
        "fd must be opened on a directory, not a file.\n" + 
        "Equivalent to os.chdir(fd).";

    public final static String posix_fchdir_sig = 
        "($module, /, fd)";

    public final static String posix_fchmod_doc = 
        "Change the access permissions of the file given by file descriptor fd.\n" + 
        "\n" + 
        "Equivalent to os.chmod(fd, mode).";

    public final static String posix_fchmod_sig = 
        "($module, /, fd, mode)";

    public final static String posix_fchown_doc = 
        "Change the owner and group id of the file specified by file descriptor.\n" + 
        "\n" + 
        "Equivalent to os.chown(fd, uid, gid).";

    public final static String posix_fchown_sig = 
        "($module, /, fd, uid, gid)";

    public final static String posix_fdatasync_doc = 
        "Force write of fd to disk without forcing update of metadata.";

    public final static String posix_fdatasync_sig = 
        "($module, /, fd)";

    public final static String posix_fork_doc = 
        "Fork a child process.\n" + 
        "\n" + 
        "Return 0 to child process and PID of child to parent process.";

    public final static String posix_fork_sig = 
        "($module, /)";

    public final static String posix_forkpty_doc = 
        "Fork a new process with a new pseudo-terminal as controlling tty.\n" + 
        "\n" + 
        "Returns a tuple of (pid, master_fd).\n" + 
        "Like fork(), return pid of 0 to the child process,\n" + 
        "and pid of child to the parent process.\n" + 
        "To both, return fd of newly opened pseudo-terminal.";

    public final static String posix_forkpty_sig = 
        "($module, /)";

    public final static String posix_fpathconf_doc = 
        "Return the configuration limit name for the file descriptor fd.\n" + 
        "\n" + 
        "If there is no limit, return -1.";

    public final static String posix_fpathconf_sig = 
        "($module, fd, name, /)";

    public final static String posix_fspath_doc = 
        "Return the file system path representation of the object.\n" + 
        "\n" + 
        "If the object is str or bytes, then allow it to pass through as-is. If the\n" + 
        "object defines __fspath__(), then return the result of that method. All other\n" + 
        "types raise a TypeError.";

    public final static String posix_fspath_sig = 
        "($module, /, path)";

    public final static String posix_fstat_doc = 
        "Perform a stat system call on the given file descriptor.\n" + 
        "\n" + 
        "Like stat(), but for an open file descriptor.\n" + 
        "Equivalent to os.stat(fd).";

    public final static String posix_fstat_sig = 
        "($module, /, fd)";

    public final static String posix_fstatvfs_doc = 
        "Perform an fstatvfs system call on the given fd.\n" + 
        "\n" + 
        "Equivalent to statvfs(fd).";

    public final static String posix_fstatvfs_sig = 
        "($module, fd, /)";

    public final static String posix_fsync_doc = 
        "Force write of fd to disk.";

    public final static String posix_fsync_sig = 
        "($module, /, fd)";

    public final static String posix_ftruncate_doc = 
        "Truncate a file, specified by file descriptor, to a specific length.";

    public final static String posix_ftruncate_sig = 
        "($module, fd, length, /)";

    public final static String posix_get_blocking_doc = 
        "get_blocking(fd) -> bool\n" + 
        "\n" + 
        "Get the blocking mode of the file descriptor:\n" + 
        "False if the O_NONBLOCK flag is set, True if the flag is cleared.";

    public final static String posix_get_inheritable_doc = 
        "Get the close-on-exe flag of the specified file descriptor.";

    public final static String posix_get_inheritable_sig = 
        "($module, fd, /)";

    public final static String posix_get_terminal_size_doc = 
        "Return the size of the terminal window as (columns, lines).\n" + 
        "\n" + 
        "The optional argument fd (default standard output) specifies\n" + 
        "which file descriptor should be queried.\n" + 
        "\n" + 
        "If the file descriptor is not connected to a terminal, an OSError\n" + 
        "is thrown.\n" + 
        "\n" + 
        "This function will only be defined if an implementation is\n" + 
        "available for this system.\n" + 
        "\n" + 
        "shutil.get_terminal_size is the high-level function which should \n" + 
        "normally be used, os.get_terminal_size is the low-level implementation.";

    public final static String posix_getcwd_doc = 
        "Return a unicode string representing the current working directory.";

    public final static String posix_getcwd_sig = 
        "($module, /)";

    public final static String posix_getcwdb_doc = 
        "Return a bytes string representing the current working directory.";

    public final static String posix_getcwdb_sig = 
        "($module, /)";

    public final static String posix_getegid_doc = 
        "Return the current process's effective group id.";

    public final static String posix_getegid_sig = 
        "($module, /)";

    public final static String posix_geteuid_doc = 
        "Return the current process's effective user id.";

    public final static String posix_geteuid_sig = 
        "($module, /)";

    public final static String posix_getgid_doc = 
        "Return the current process's group id.";

    public final static String posix_getgid_sig = 
        "($module, /)";

    public final static String posix_getgrouplist_doc = 
        "getgrouplist(user, group) -> list of groups to which a user belongs\n" + 
        "\n" + 
        "Returns a list of groups to which a user belongs.\n" + 
        "\n" + 
        "    user: username to lookup\n" + 
        "    group: base group id of the user";

    public final static String posix_getgroups_doc = 
        "Return list of supplemental group IDs for the process.";

    public final static String posix_getgroups_sig = 
        "($module, /)";

    public final static String posix_getloadavg_doc = 
        "Return average recent system load information.\n" + 
        "\n" + 
        "Return the number of processes in the system run queue averaged over\n" + 
        "the last 1, 5, and 15 minutes as a tuple of three floats.\n" + 
        "Raises OSError if the load average was unobtainable.";

    public final static String posix_getloadavg_sig = 
        "($module, /)";

    public final static String posix_getlogin_doc = 
        "Return the actual login name.";

    public final static String posix_getlogin_sig = 
        "($module, /)";

    public final static String posix_getpgid_doc = 
        "Call the system call getpgid(), and return the result.";

    public final static String posix_getpgid_sig = 
        "($module, /, pid)";

    public final static String posix_getpgrp_doc = 
        "Return the current process group id.";

    public final static String posix_getpgrp_sig = 
        "($module, /)";

    public final static String posix_getpid_doc = 
        "Return the current process id.";

    public final static String posix_getpid_sig = 
        "($module, /)";

    public final static String posix_getppid_doc = 
        "Return the parent's process id.\n" + 
        "\n" + 
        "If the parent process has already exited, Windows machines will still\n" + 
        "return its id; others systems will return the id of the 'init' process (1).";

    public final static String posix_getppid_sig = 
        "($module, /)";

    public final static String posix_getpriority_doc = 
        "Return program scheduling priority.";

    public final static String posix_getpriority_sig = 
        "($module, /, which, who)";

    public final static String posix_getrandom_doc = 
        "Obtain a series of random bytes.";

    public final static String posix_getrandom_sig = 
        "($module, /, size, flags=0)";

    public final static String posix_getresgid_doc = 
        "Return a tuple of the current process's real, effective, and saved group ids.";

    public final static String posix_getresgid_sig = 
        "($module, /)";

    public final static String posix_getresuid_doc = 
        "Return a tuple of the current process's real, effective, and saved user ids.";

    public final static String posix_getresuid_sig = 
        "($module, /)";

    public final static String posix_getsid_doc = 
        "Call the system call getsid(pid) and return the result.";

    public final static String posix_getsid_sig = 
        "($module, pid, /)";

    public final static String posix_getuid_doc = 
        "Return the current process's user id.";

    public final static String posix_getuid_sig = 
        "($module, /)";

    public final static String posix_getxattr_doc = 
        "Return the value of extended attribute attribute on path.\n" + 
        "\n" + 
        "path may be either a string or an open file descriptor.\n" + 
        "If follow_symlinks is False, and the last element of the path is a symbolic\n" + 
        "  link, getxattr will examine the symbolic link itself instead of the file\n" + 
        "  the link points to.";

    public final static String posix_getxattr_sig = 
        "($module, /, path, attribute, *, follow_symlinks=True)";

    public final static String posix_initgroups_doc = 
        "initgroups(username, gid) -> None\n" + 
        "\n" + 
        "Call the system initgroups() to initialize the group access list with all of\n" + 
        "the groups of which the specified username is a member, plus the specified\n" + 
        "group id.";

    public final static String posix_isatty_doc = 
        "Return True if the fd is connected to a terminal.\n" + 
        "\n" + 
        "Return True if the file descriptor is an open file descriptor\n" + 
        "connected to the slave end of a terminal.";

    public final static String posix_isatty_sig = 
        "($module, fd, /)";

    public final static String posix_kill_doc = 
        "Kill a process with a signal.";

    public final static String posix_kill_sig = 
        "($module, pid, signal, /)";

    public final static String posix_killpg_doc = 
        "Kill a process group with a signal.";

    public final static String posix_killpg_sig = 
        "($module, pgid, signal, /)";

    public final static String posix_lchown_doc = 
        "Change the owner and group id of path to the numeric uid and gid.\n" + 
        "\n" + 
        "This function will not follow symbolic links.\n" + 
        "Equivalent to os.chown(path, uid, gid, follow_symlinks=False).";

    public final static String posix_lchown_sig = 
        "($module, /, path, uid, gid)";

    public final static String posix_link_doc = 
        "Create a hard link to a file.\n" + 
        "\n" + 
        "If either src_dir_fd or dst_dir_fd is not None, it should be a file\n" + 
        "  descriptor open to a directory, and the respective path string (src or dst)\n" + 
        "  should be relative; the path will then be relative to that directory.\n" + 
        "If follow_symlinks is False, and the last element of src is a symbolic\n" + 
        "  link, link will create a link to the symbolic link itself instead of the\n" + 
        "  file the link points to.\n" + 
        "src_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your\n" + 
        "  platform.  If they are unavailable, using them will raise a\n" + 
        "  NotImplementedError.";

    public final static String posix_link_sig = 
        "($module, /, src, dst, *, src_dir_fd=None, dst_dir_fd=None,\n" + 
        "     follow_symlinks=True)";

    public final static String posix_listdir_doc = 
        "Return a list containing the names of the files in the directory.\n" + 
        "\n" + 
        "path can be specified as either str or bytes.  If path is bytes,\n" + 
        "  the filenames returned will also be bytes; in all other circumstances\n" + 
        "  the filenames returned will be str.\n" + 
        "If path is None, uses the path='.'.\n" + 
        "On some platforms, path may also be specified as an open file descriptor;\\\n" + 
        "  the file descriptor must refer to a directory.\n" + 
        "  If this functionality is unavailable, using it raises NotImplementedError.\n" + 
        "\n" + 
        "The list is in arbitrary order.  It does not include the special\n" + 
        "entries '.' and '..' even if they are present in the directory.";

    public final static String posix_listdir_sig = 
        "($module, /, path=None)";

    public final static String posix_listxattr_doc = 
        "Return a list of extended attributes on path.\n" + 
        "\n" + 
        "path may be either None, a string, or an open file descriptor.\n" + 
        "if path is None, listxattr will examine the current directory.\n" + 
        "If follow_symlinks is False, and the last element of the path is a symbolic\n" + 
        "  link, listxattr will examine the symbolic link itself instead of the file\n" + 
        "  the link points to.";

    public final static String posix_listxattr_sig = 
        "($module, /, path=None, *, follow_symlinks=True)";

    public final static String posix_lockf_doc = 
        "Apply, test or remove a POSIX lock on an open file descriptor.\n" + 
        "\n" + 
        "  fd\n" + 
        "    An open file descriptor.\n" + 
        "  command\n" + 
        "    One of F_LOCK, F_TLOCK, F_ULOCK or F_TEST.\n" + 
        "  length\n" + 
        "    The number of bytes to lock, starting at the current position.";

    public final static String posix_lockf_sig = 
        "($module, fd, command, length, /)";

    public final static String posix_lseek_doc = 
        "Set the position of a file descriptor.  Return the new position.\n" + 
        "\n" + 
        "Return the new cursor position in number of bytes\n" + 
        "relative to the beginning of the file.";

    public final static String posix_lseek_sig = 
        "($module, fd, position, how, /)";

    public final static String posix_lstat_doc = 
        "Perform a stat system call on the given path, without following symbolic links.\n" + 
        "\n" + 
        "Like stat(), but do not follow symbolic links.\n" + 
        "Equivalent to stat(path, follow_symlinks=False).";

    public final static String posix_lstat_sig = 
        "($module, /, path, *, dir_fd=None)";

    public final static String posix_major_doc = 
        "Extracts a device major number from a raw device number.";

    public final static String posix_major_sig = 
        "($module, device, /)";

    public final static String posix_makedev_doc = 
        "Composes a raw device number from the major and minor device numbers.";

    public final static String posix_makedev_sig = 
        "($module, major, minor, /)";

    public final static String posix_minor_doc = 
        "Extracts a device minor number from a raw device number.";

    public final static String posix_minor_sig = 
        "($module, device, /)";

    public final static String posix_mkdir_doc = 
        "Create a directory.\n" + 
        "\n" + 
        "If dir_fd is not None, it should be a file descriptor open to a directory,\n" + 
        "  and path should be relative; path will then be relative to that directory.\n" + 
        "dir_fd may not be implemented on your platform.\n" + 
        "  If it is unavailable, using it will raise a NotImplementedError.\n" + 
        "\n" + 
        "The mode argument is ignored on Windows.";

    public final static String posix_mkdir_sig = 
        "($module, /, path, mode=511, *, dir_fd=None)";

    public final static String posix_mkfifo_doc = 
        "Create a \"fifo\" (a POSIX named pipe).\n" + 
        "\n" + 
        "If dir_fd is not None, it should be a file descriptor open to a directory,\n" + 
        "  and path should be relative; path will then be relative to that directory.\n" + 
        "dir_fd may not be implemented on your platform.\n" + 
        "  If it is unavailable, using it will raise a NotImplementedError.";

    public final static String posix_mkfifo_sig = 
        "($module, /, path, mode=438, *, dir_fd=None)";

    public final static String posix_mknod_doc = 
        "Create a node in the file system.\n" + 
        "\n" + 
        "Create a node in the file system (file, device special file or named pipe)\n" + 
        "at path.  mode specifies both the permissions to use and the\n" + 
        "type of node to be created, being combined (bitwise OR) with one of\n" + 
        "S_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO.  If S_IFCHR or S_IFBLK is set on mode,\n" + 
        "device defines the newly created device special file (probably using\n" + 
        "os.makedev()).  Otherwise device is ignored.\n" + 
        "\n" + 
        "If dir_fd is not None, it should be a file descriptor open to a directory,\n" + 
        "  and path should be relative; path will then be relative to that directory.\n" + 
        "dir_fd may not be implemented on your platform.\n" + 
        "  If it is unavailable, using it will raise a NotImplementedError.";

    public final static String posix_mknod_sig = 
        "($module, /, path, mode=384, device=0, *, dir_fd=None)";

    public final static String posix_nice_doc = 
        "Add increment to the priority of process and return the new priority.";

    public final static String posix_nice_sig = 
        "($module, increment, /)";

    public final static String posix_open_doc = 
        "Open a file for low level IO.  Returns a file descriptor (integer).\n" + 
        "\n" + 
        "If dir_fd is not None, it should be a file descriptor open to a directory,\n" + 
        "  and path should be relative; path will then be relative to that directory.\n" + 
        "dir_fd may not be implemented on your platform.\n" + 
        "  If it is unavailable, using it will raise a NotImplementedError.";

    public final static String posix_open_sig = 
        "($module, /, path, flags, mode=511, *, dir_fd=None)";

    public final static String posix_openpty_doc = 
        "Open a pseudo-terminal.\n" + 
        "\n" + 
        "Return a tuple of (master_fd, slave_fd) containing open file descriptors\n" + 
        "for both the master and slave ends.";

    public final static String posix_openpty_sig = 
        "($module, /)";

    public final static String posix_pathconf_doc = 
        "Return the configuration limit name for the file or directory path.\n" + 
        "\n" + 
        "If there is no limit, return -1.\n" + 
        "On some platforms, path may also be specified as an open file descriptor.\n" + 
        "  If this functionality is unavailable, using it raises an exception.";

    public final static String posix_pathconf_sig = 
        "($module, /, path, name)";

    public final static String posix_pipe_doc = 
        "Create a pipe.\n" + 
        "\n" + 
        "Returns a tuple of two file descriptors:\n" + 
        "  (read_fd, write_fd)";

    public final static String posix_pipe_sig = 
        "($module, /)";

    public final static String posix_pipe2_doc = 
        "Create a pipe with flags set atomically.\n" + 
        "\n" + 
        "Returns a tuple of two file descriptors:\n" + 
        "  (read_fd, write_fd)\n" + 
        "\n" + 
        "flags can be constructed by ORing together one or more of these values:\n" + 
        "O_NONBLOCK, O_CLOEXEC.";

    public final static String posix_pipe2_sig = 
        "($module, flags, /)";

    public final static String posix_posix_fadvise_doc = 
        "Announce an intention to access data in a specific pattern.\n" + 
        "\n" + 
        "Announce an intention to access data in a specific pattern, thus allowing\n" + 
        "the kernel to make optimizations.\n" + 
        "The advice applies to the region of the file specified by fd starting at\n" + 
        "offset and continuing for length bytes.\n" + 
        "advice is one of POSIX_FADV_NORMAL, POSIX_FADV_SEQUENTIAL,\n" + 
        "POSIX_FADV_RANDOM, POSIX_FADV_NOREUSE, POSIX_FADV_WILLNEED, or\n" + 
        "POSIX_FADV_DONTNEED.";

    public final static String posix_posix_fadvise_sig = 
        "($module, fd, offset, length, advice, /)";

    public final static String posix_posix_fallocate_doc = 
        "Ensure a file has allocated at least a particular number of bytes on disk.\n" + 
        "\n" + 
        "Ensure that the file specified by fd encompasses a range of bytes\n" + 
        "starting at offset bytes from the beginning and continuing for length bytes.";

    public final static String posix_posix_fallocate_sig = 
        "($module, fd, offset, length, /)";

    public final static String posix_posix_spawn_doc = 
        "Execute the program specified by path in a new process.\n" + 
        "\n" + 
        "  path\n" + 
        "    Path of executable file.\n" + 
        "  argv\n" + 
        "    Tuple or list of strings.\n" + 
        "  env\n" + 
        "    Dictionary of strings mapping to strings.\n" + 
        "  file_actions\n" + 
        "    FileActions object.";

    public final static String posix_posix_spawn_sig = 
        "($module, path, argv, env, file_actions=None, /)";

    public final static String posix_pread_doc = 
        "Read a number of bytes from a file descriptor starting at a particular offset.\n" + 
        "\n" + 
        "Read length bytes from file descriptor fd, starting at offset bytes from\n" + 
        "the beginning of the file.  The file offset remains unchanged.";

    public final static String posix_pread_sig = 
        "($module, fd, length, offset, /)";

    public final static String posix_preadv_doc = 
        "Reads from a file descriptor into a number of mutable bytes-like objects.\n" + 
        "\n" + 
        "Combines the functionality of readv() and pread(). As readv(), it will\n" + 
        "transfer data into each buffer until it is full and then move on to the next\n" + 
        "buffer in the sequence to hold the rest of the data. Its fourth argument,\n" + 
        "specifies the file offset at which the input operation is to be performed. It\n" + 
        "will return the total number of bytes read (which can be less than the total\n" + 
        "capacity of all the objects).\n" + 
        "\n" + 
        "The flags argument contains a bitwise OR of zero or more of the following flags:\n" + 
        "\n" + 
        "- RWF_HIPRI\n" + 
        "- RWF_NOWAIT\n" + 
        "\n" + 
        "Using non-zero flags requires Linux 4.6 or newer.";

    public final static String posix_preadv_sig = 
        "($module, fd, buffers, offset, flags=0, /)";

    public final static String posix_putenv_doc = 
        "Change or add an environment variable.";

    public final static String posix_putenv_sig = 
        "($module, name, value, /)";

    public final static String posix_pwrite_doc = 
        "Write bytes to a file descriptor starting at a particular offset.\n" + 
        "\n" + 
        "Write buffer to fd, starting at offset bytes from the beginning of\n" + 
        "the file.  Returns the number of bytes writte.  Does not change the\n" + 
        "current file offset.";

    public final static String posix_pwrite_sig = 
        "($module, fd, buffer, offset, /)";

    public final static String posix_pwritev_doc = 
        "Writes the contents of bytes-like objects to a file descriptor at a given offset.\n" + 
        "\n" + 
        "Combines the functionality of writev() and pwrite(). All buffers must be a sequence\n" + 
        "of bytes-like objects. Buffers are processed in array order. Entire contents of first\n" + 
        "buffer is written before proceeding to second, and so on. The operating system may\n" + 
        "set a limit (sysconf() value SC_IOV_MAX) on the number of buffers that can be used.\n" + 
        "This function writes the contents of each object to the file descriptor and returns\n" + 
        "the total number of bytes written.\n" + 
        "\n" + 
        "The flags argument contains a bitwise OR of zero or more of the following flags:\n" + 
        "\n" + 
        "- RWF_DSYNC\n" + 
        "- RWF_SYNC\n" + 
        "\n" + 
        "Using non-zero flags requires Linux 4.7 or newer.";

    public final static String posix_pwritev_sig = 
        "($module, fd, buffers, offset, flags=0, /)";

    public final static String posix_read_doc = 
        "Read from a file descriptor.  Returns a bytes object.";

    public final static String posix_read_sig = 
        "($module, fd, length, /)";

    public final static String posix_readlink_doc = 
        "readlink(path, *, dir_fd=None) -> path\n" + 
        "\n" + 
        "Return a string representing the path to which the symbolic link points.\n" + 
        "\n" + 
        "If dir_fd is not None, it should be a file descriptor open to a directory,\n" + 
        "  and path should be relative; path will then be relative to that directory.\n" + 
        "dir_fd may not be implemented on your platform.\n" + 
        "  If it is unavailable, using it will raise a NotImplementedError.";

    public final static String posix_readv_doc = 
        "Read from a file descriptor fd into an iterable of buffers.\n" + 
        "\n" + 
        "The buffers should be mutable buffers accepting bytes.\n" + 
        "readv will transfer data into each buffer until it is full\n" + 
        "and then move on to the next buffer in the sequence to hold\n" + 
        "the rest of the data.\n" + 
        "\n" + 
        "readv returns the total number of bytes read,\n" + 
        "which may be less than the total capacity of all the buffers.";

    public final static String posix_readv_sig = 
        "($module, fd, buffers, /)";

    public final static String posix_register_at_fork_doc = 
        "Register callables to be called when forking a new process.\n" + 
        "\n" + 
        "  before\n" + 
        "    A callable to be called in the parent before the fork() syscall.\n" + 
        "  after_in_child\n" + 
        "    A callable to be called in the child after fork().\n" + 
        "  after_in_parent\n" + 
        "    A callable to be called in the parent after fork().\n" + 
        "\n" + 
        "'before' callbacks are called in reverse order.\n" + 
        "'after_in_child' and 'after_in_parent' callbacks are called in order.";

    public final static String posix_register_at_fork_sig = 
        "($module, /, *, before=None, after_in_child=None,\n" + 
        "                 after_in_parent=None)";

    public final static String posix_remove_doc = 
        "Remove a file (same as unlink()).\n" + 
        "\n" + 
        "If dir_fd is not None, it should be a file descriptor open to a directory,\n" + 
        "  and path should be relative; path will then be relative to that directory.\n" + 
        "dir_fd may not be implemented on your platform.\n" + 
        "  If it is unavailable, using it will raise a NotImplementedError.";

    public final static String posix_remove_sig = 
        "($module, /, path, *, dir_fd=None)";

    public final static String posix_removexattr_doc = 
        "Remove extended attribute attribute on path.\n" + 
        "\n" + 
        "path may be either a string or an open file descriptor.\n" + 
        "If follow_symlinks is False, and the last element of the path is a symbolic\n" + 
        "  link, removexattr will modify the symbolic link itself instead of the file\n" + 
        "  the link points to.";

    public final static String posix_removexattr_sig = 
        "($module, /, path, attribute, *, follow_symlinks=True)";

    public final static String posix_rename_doc = 
        "Rename a file or directory.\n" + 
        "\n" + 
        "If either src_dir_fd or dst_dir_fd is not None, it should be a file\n" + 
        "  descriptor open to a directory, and the respective path string (src or dst)\n" + 
        "  should be relative; the path will then be relative to that directory.\n" + 
        "src_dir_fd and dst_dir_fd, may not be implemented on your platform.\n" + 
        "  If they are unavailable, using them will raise a NotImplementedError.";

    public final static String posix_rename_sig = 
        "($module, /, src, dst, *, src_dir_fd=None, dst_dir_fd=None)";

    public final static String posix_replace_doc = 
        "Rename a file or directory, overwriting the destination.\n" + 
        "\n" + 
        "If either src_dir_fd or dst_dir_fd is not None, it should be a file\n" + 
        "  descriptor open to a directory, and the respective path string (src or dst)\n" + 
        "  should be relative; the path will then be relative to that directory.\n" + 
        "src_dir_fd and dst_dir_fd, may not be implemented on your platform.\n" + 
        "  If they are unavailable, using them will raise a NotImplementedError.\"";

    public final static String posix_replace_sig = 
        "($module, /, src, dst, *, src_dir_fd=None, dst_dir_fd=None)";

    public final static String posix_rmdir_doc = 
        "Remove a directory.\n" + 
        "\n" + 
        "If dir_fd is not None, it should be a file descriptor open to a directory,\n" + 
        "  and path should be relative; path will then be relative to that directory.\n" + 
        "dir_fd may not be implemented on your platform.\n" + 
        "  If it is unavailable, using it will raise a NotImplementedError.";

    public final static String posix_rmdir_sig = 
        "($module, /, path, *, dir_fd=None)";

    public final static String posix_scandir_doc = 
        "Return an iterator of DirEntry objects for given path.\n" + 
        "\n" + 
        "path can be specified as either str, bytes or path-like object.  If path\n" + 
        "is bytes, the names of yielded DirEntry objects will also be bytes; in\n" + 
        "all other circumstances they will be str.\n" + 
        "\n" + 
        "If path is None, uses the path='.'.";

    public final static String posix_scandir_sig = 
        "($module, /, path=None)";

    public final static String posix_sched_get_priority_max_doc = 
        "Get the maximum scheduling priority for policy.";

    public final static String posix_sched_get_priority_max_sig = 
        "($module, /, policy)";

    public final static String posix_sched_get_priority_min_doc = 
        "Get the minimum scheduling priority for policy.";

    public final static String posix_sched_get_priority_min_sig = 
        "($module, /, policy)";

    public final static String posix_sched_getaffinity_doc = 
        "Return the affinity of the process identified by pid (or the current process if zero).\n" + 
        "\n" + 
        "The affinity is returned as a set of CPU identifiers.";

    public final static String posix_sched_getaffinity_sig = 
        "($module, pid, /)";

    public final static String posix_sched_getparam_doc = 
        "Returns scheduling parameters for the process identified by pid.\n" + 
        "\n" + 
        "If pid is 0, returns parameters for the calling process.\n" + 
        "Return value is an instance of sched_param.";

    public final static String posix_sched_getparam_sig = 
        "($module, pid, /)";

    public final static String posix_sched_getscheduler_doc = 
        "Get the scheduling policy for the process identifiedy by pid.\n" + 
        "\n" + 
        "Passing 0 for pid returns the scheduling policy for the calling process.";

    public final static String posix_sched_getscheduler_sig = 
        "($module, pid, /)";

    public final static String posix_sched_param_doc = 
        "Current has only one field: sched_priority\");\n" + 
        "\n" + 
        "  sched_priority\n" + 
        "    A scheduling parameter.";

    public final static String posix_sched_param_sig = 
        "(sched_priority)";

    public final static String posix_sched_rr_get_interval_doc = 
        "Return the round-robin quantum for the process identified by pid, in seconds.\n" + 
        "\n" + 
        "Value returned is a float.";

    public final static String posix_sched_rr_get_interval_sig = 
        "($module, pid, /)";

    public final static String posix_sched_setaffinity_doc = 
        "Set the CPU affinity of the process identified by pid to mask.\n" + 
        "\n" + 
        "mask should be an iterable of integers identifying CPUs.";

    public final static String posix_sched_setaffinity_sig = 
        "($module, pid, mask, /)";

    public final static String posix_sched_setparam_doc = 
        "Set scheduling parameters for the process identified by pid.\n" + 
        "\n" + 
        "If pid is 0, sets parameters for the calling process.\n" + 
        "param should be an instance of sched_param.";

    public final static String posix_sched_setparam_sig = 
        "($module, pid, param, /)";

    public final static String posix_sched_setscheduler_doc = 
        "Set the scheduling policy for the process identified by pid.\n" + 
        "\n" + 
        "If pid is 0, the calling process is changed.\n" + 
        "param is an instance of sched_param.";

    public final static String posix_sched_setscheduler_sig = 
        "($module, pid, policy, param, /)";

    public final static String posix_sched_yield_doc = 
        "Voluntarily relinquish the CPU.";

    public final static String posix_sched_yield_sig = 
        "($module, /)";

    public final static String posix_sendfile_doc = 
        "sendfile(out, in, offset, count) -> byteswritten\n" + 
        "sendfile(out, in, offset, count[, headers][, trailers], flags=0)\n" + 
        "            -> byteswritten\n" + 
        "Copy count bytes from file descriptor in to file descriptor out.";

    public final static String posix_set_blocking_doc = 
        "set_blocking(fd, blocking)\n" + 
        "\n" + 
        "Set the blocking mode of the specified file descriptor.\n" + 
        "Set the O_NONBLOCK flag if blocking is False,\n" + 
        "clear the O_NONBLOCK flag otherwise.";

    public final static String posix_set_inheritable_doc = 
        "Set the inheritable flag of the specified file descriptor.";

    public final static String posix_set_inheritable_sig = 
        "($module, fd, inheritable, /)";

    public final static String posix_setegid_doc = 
        "Set the current process's effective group id.";

    public final static String posix_setegid_sig = 
        "($module, egid, /)";

    public final static String posix_seteuid_doc = 
        "Set the current process's effective user id.";

    public final static String posix_seteuid_sig = 
        "($module, euid, /)";

    public final static String posix_setgid_doc = 
        "Set the current process's group id.";

    public final static String posix_setgid_sig = 
        "($module, gid, /)";

    public final static String posix_setgroups_doc = 
        "Set the groups of the current process to list.";

    public final static String posix_setgroups_sig = 
        "($module, groups, /)";

    public final static String posix_setpgid_doc = 
        "Call the system call setpgid(pid, pgrp).";

    public final static String posix_setpgid_sig = 
        "($module, pid, pgrp, /)";

    public final static String posix_setpgrp_doc = 
        "Make the current process the leader of its process group.";

    public final static String posix_setpgrp_sig = 
        "($module, /)";

    public final static String posix_setpriority_doc = 
        "Set program scheduling priority.";

    public final static String posix_setpriority_sig = 
        "($module, /, which, who, priority)";

    public final static String posix_setregid_doc = 
        "Set the current process's real and effective group ids.";

    public final static String posix_setregid_sig = 
        "($module, rgid, egid, /)";

    public final static String posix_setresgid_doc = 
        "Set the current process's real, effective, and saved group ids.";

    public final static String posix_setresgid_sig = 
        "($module, rgid, egid, sgid, /)";

    public final static String posix_setresuid_doc = 
        "Set the current process's real, effective, and saved user ids.";

    public final static String posix_setresuid_sig = 
        "($module, ruid, euid, suid, /)";

    public final static String posix_setreuid_doc = 
        "Set the current process's real and effective user ids.";

    public final static String posix_setreuid_sig = 
        "($module, ruid, euid, /)";

    public final static String posix_setsid_doc = 
        "Call the system call setsid().";

    public final static String posix_setsid_sig = 
        "($module, /)";

    public final static String posix_setuid_doc = 
        "Set the current process's user id.";

    public final static String posix_setuid_sig = 
        "($module, uid, /)";

    public final static String posix_setxattr_doc = 
        "Set extended attribute attribute on path to value.\n" + 
        "\n" + 
        "path may be either a string or an open file descriptor.\n" + 
        "If follow_symlinks is False, and the last element of the path is a symbolic\n" + 
        "  link, setxattr will modify the symbolic link itself instead of the file\n" + 
        "  the link points to.";

    public final static String posix_setxattr_sig = 
        "($module, /, path, attribute, value, flags=0, *,\n" + 
        "         follow_symlinks=True)";

    public final static String posix_stat_doc = 
        "Perform a stat system call on the given path.\n" + 
        "\n" + 
        "  path\n" + 
        "    Path to be examined; can be string, bytes, path-like object or\n" + 
        "    open-file-descriptor int.\n" + 
        "  dir_fd\n" + 
        "    If not None, it should be a file descriptor open to a directory,\n" + 
        "    and path should be a relative string; path will then be relative to\n" + 
        "    that directory.\n" + 
        "  follow_symlinks\n" + 
        "    If False, and the last element of the path is a symbolic link,\n" + 
        "    stat will examine the symbolic link itself instead of the file\n" + 
        "    the link points to.\n" + 
        "\n" + 
        "dir_fd and follow_symlinks may not be implemented\n" + 
        "  on your platform.  If they are unavailable, using them will raise a\n" + 
        "  NotImplementedError.\n" + 
        "\n" + 
        "It's an error to use dir_fd or follow_symlinks when specifying path as\n" + 
        "  an open file descriptor.";

    public final static String posix_stat_sig = 
        "($module, /, path, *, dir_fd=None, follow_symlinks=True)";

    public final static String posix_stat_result_doc = 
        "stat_result: Result from stat, fstat, or lstat.\n" + 
        "\n" + 
        "This object may be accessed either as a tuple of\n" + 
        "  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)\n" + 
        "or via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.\n" + 
        "\n" + 
        "Posix/windows: If your platform supports st_blksize, st_blocks, st_rdev,\n" + 
        "or st_flags, they are available as attributes only.\n" + 
        "\n" + 
        "See os.stat for more information.";

    public final static String posix_statvfs_doc = 
        "Perform a statvfs system call on the given path.\n" + 
        "\n" + 
        "path may always be specified as a string.\n" + 
        "On some platforms, path may also be specified as an open file descriptor.\n" + 
        "  If this functionality is unavailable, using it raises an exception.";

    public final static String posix_statvfs_sig = 
        "($module, /, path)";

    public final static String posix_statvfs_result_doc = 
        "statvfs_result: Result from statvfs or fstatvfs.\n" + 
        "\n" + 
        "This object may be accessed either as a tuple of\n" + 
        "  (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),\n" + 
        "or via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.\n" + 
        "\n" + 
        "See os.statvfs for more information.";

    public final static String posix_strerror_doc = 
        "Translate an error code to a message string.";

    public final static String posix_strerror_sig = 
        "($module, code, /)";

    public final static String posix_symlink_doc = 
        "Create a symbolic link pointing to src named dst.\n" + 
        "\n" + 
        "target_is_directory is required on Windows if the target is to be\n" + 
        "  interpreted as a directory.  (On Windows, symlink requires\n" + 
        "  Windows 6.0 or greater, and raises a NotImplementedError otherwise.)\n" + 
        "  target_is_directory is ignored on non-Windows platforms.\n" + 
        "\n" + 
        "If dir_fd is not None, it should be a file descriptor open to a directory,\n" + 
        "  and path should be relative; path will then be relative to that directory.\n" + 
        "dir_fd may not be implemented on your platform.\n" + 
        "  If it is unavailable, using it will raise a NotImplementedError.";

    public final static String posix_symlink_sig = 
        "($module, /, src, dst, target_is_directory=False, *, dir_fd=None)";

    public final static String posix_sync_doc = 
        "Force write of everything to disk.";

    public final static String posix_sync_sig = 
        "($module, /)";

    public final static String posix_sysconf_doc = 
        "Return an integer-valued system configuration variable.";

    public final static String posix_sysconf_sig = 
        "($module, name, /)";

    public final static String posix_system_doc = 
        "Execute the command in a subshell.";

    public final static String posix_system_sig = 
        "($module, /, command)";

    public final static String posix_tcgetpgrp_doc = 
        "Return the process group associated with the terminal specified by fd.";

    public final static String posix_tcgetpgrp_sig = 
        "($module, fd, /)";

    public final static String posix_tcsetpgrp_doc = 
        "Set the process group associated with the terminal specified by fd.";

    public final static String posix_tcsetpgrp_sig = 
        "($module, fd, pgid, /)";

    public final static String posix_terminal_size_doc = 
        "A tuple of (columns, lines) for holding terminal window size";

    public final static String posix_times_doc = 
        "Return a collection containing process timing information.\n" + 
        "\n" + 
        "The object returned behaves like a named tuple with these fields:\n" + 
        "  (utime, stime, cutime, cstime, elapsed_time)\n" + 
        "All fields are floating point numbers.";

    public final static String posix_times_sig = 
        "($module, /)";

    public final static String posix_times_result_doc = 
        "times_result: Result from os.times().\n" + 
        "\n" + 
        "This object may be accessed either as a tuple of\n" + 
        "  (user, system, children_user, children_system, elapsed),\n" + 
        "or via the attributes user, system, children_user, children_system,\n" + 
        "and elapsed.\n" + 
        "\n" + 
        "See os.times for more information.";

    public final static String posix_truncate_doc = 
        "Truncate a file, specified by path, to a specific length.\n" + 
        "\n" + 
        "On some platforms, path may also be specified as an open file descriptor.\n" + 
        "  If this functionality is unavailable, using it raises an exception.";

    public final static String posix_truncate_sig = 
        "($module, /, path, length)";

    public final static String posix_ttyname_doc = 
        "Return the name of the terminal device connected to 'fd'.\n" + 
        "\n" + 
        "  fd\n" + 
        "    Integer file descriptor handle.";

    public final static String posix_ttyname_sig = 
        "($module, fd, /)";

    public final static String posix_umask_doc = 
        "Set the current numeric umask and return the previous umask.";

    public final static String posix_umask_sig = 
        "($module, mask, /)";

    public final static String posix_uname_doc = 
        "Return an object identifying the current operating system.\n" + 
        "\n" + 
        "The object behaves like a named tuple with the following fields:\n" + 
        "  (sysname, nodename, release, version, machine)";

    public final static String posix_uname_sig = 
        "($module, /)";

    public final static String posix_uname_result_doc = 
        "uname_result: Result from os.uname().\n" + 
        "\n" + 
        "This object may be accessed either as a tuple of\n" + 
        "  (sysname, nodename, release, version, machine),\n" + 
        "or via the attributes sysname, nodename, release, version, and machine.\n" + 
        "\n" + 
        "See os.uname for more information.";

    public final static String posix_unlink_doc = 
        "Remove a file (same as remove()).\n" + 
        "\n" + 
        "If dir_fd is not None, it should be a file descriptor open to a directory,\n" + 
        "  and path should be relative; path will then be relative to that directory.\n" + 
        "dir_fd may not be implemented on your platform.\n" + 
        "  If it is unavailable, using it will raise a NotImplementedError.";

    public final static String posix_unlink_sig = 
        "($module, /, path, *, dir_fd=None)";

    public final static String posix_unsetenv_doc = 
        "Delete an environment variable.";

    public final static String posix_unsetenv_sig = 
        "($module, name, /)";

    public final static String posix_urandom_doc = 
        "Return a bytes object containing random bytes suitable for cryptographic use.";

    public final static String posix_urandom_sig = 
        "($module, size, /)";

    public final static String posix_utime_doc = 
        "Set the access and modified time of path.\n" + 
        "\n" + 
        "path may always be specified as a string.\n" + 
        "On some platforms, path may also be specified as an open file descriptor.\n" + 
        "  If this functionality is unavailable, using it raises an exception.\n" + 
        "\n" + 
        "If times is not None, it must be a tuple (atime, mtime);\n" + 
        "    atime and mtime should be expressed as float seconds since the epoch.\n" + 
        "If ns is specified, it must be a tuple (atime_ns, mtime_ns);\n" + 
        "    atime_ns and mtime_ns should be expressed as integer nanoseconds\n" + 
        "    since the epoch.\n" + 
        "If times is None and ns is unspecified, utime uses the current time.\n" + 
        "Specifying tuples for both times and ns is an error.\n" + 
        "\n" + 
        "If dir_fd is not None, it should be a file descriptor open to a directory,\n" + 
        "  and path should be relative; path will then be relative to that directory.\n" + 
        "If follow_symlinks is False, and the last element of the path is a symbolic\n" + 
        "  link, utime will modify the symbolic link itself instead of the file the\n" + 
        "  link points to.\n" + 
        "It is an error to use dir_fd or follow_symlinks when specifying path\n" + 
        "  as an open file descriptor.\n" + 
        "dir_fd and follow_symlinks may not be available on your platform.\n" + 
        "  If they are unavailable, using them will raise a NotImplementedError.";

    public final static String posix_utime_sig = 
        "($module, /, path, times=None, *, ns=None, dir_fd=None,\n" + 
        "      follow_symlinks=True)";

    public final static String posix_wait_doc = 
        "Wait for completion of a child process.\n" + 
        "\n" + 
        "Returns a tuple of information about the child process:\n" + 
        "    (pid, status)";

    public final static String posix_wait_sig = 
        "($module, /)";

    public final static String posix_wait3_doc = 
        "Wait for completion of a child process.\n" + 
        "\n" + 
        "Returns a tuple of information about the child process:\n" + 
        "  (pid, status, rusage)";

    public final static String posix_wait3_sig = 
        "($module, /, options)";

    public final static String posix_wait4_doc = 
        "Wait for completion of a specific child process.\n" + 
        "\n" + 
        "Returns a tuple of information about the child process:\n" + 
        "  (pid, status, rusage)";

    public final static String posix_wait4_sig = 
        "($module, /, pid, options)";

    public final static String posix_waitid_doc = 
        "Returns the result of waiting for a process or processes.\n" + 
        "\n" + 
        "  idtype\n" + 
        "    Must be one of be P_PID, P_PGID or P_ALL.\n" + 
        "  id\n" + 
        "    The id to wait on.\n" + 
        "  options\n" + 
        "    Constructed from the ORing of one or more of WEXITED, WSTOPPED\n" + 
        "    or WCONTINUED and additionally may be ORed with WNOHANG or WNOWAIT.\n" + 
        "\n" + 
        "Returns either waitid_result or None if WNOHANG is specified and there are\n" + 
        "no children in a waitable state.";

    public final static String posix_waitid_sig = 
        "($module, idtype, id, options, /)";

    public final static String posix_waitid_result_doc = 
        "waitid_result: Result from waitid.\n" + 
        "\n" + 
        "This object may be accessed either as a tuple of\n" + 
        "  (si_pid, si_uid, si_signo, si_status, si_code),\n" + 
        "or via the attributes si_pid, si_uid, and so on.\n" + 
        "\n" + 
        "See os.waitid for more information.";

    public final static String posix_waitpid_doc = 
        "Wait for completion of a given child process.\n" + 
        "\n" + 
        "Returns a tuple of information regarding the child process:\n" + 
        "    (pid, status)\n" + 
        "\n" + 
        "The options argument is ignored on Windows.";

    public final static String posix_waitpid_sig = 
        "($module, pid, options, /)";

    public final static String posix_write_doc = 
        "Write a bytes object to a file descriptor.";

    public final static String posix_write_sig = 
        "($module, fd, data, /)";

    public final static String posix_writev_doc = 
        "Iterate over buffers, and write the contents of each to a file descriptor.\n" + 
        "\n" + 
        "Returns the total number of bytes written.\n" + 
        "buffers must be a sequence of bytes-like objects.";

    public final static String posix_writev_sig = 
        "($module, fd, buffers, /)";

    // Docs for <module 'sys' (built-in)>
    public final static String sys___breakpointhook___doc = 
        "breakpointhook(*args, **kws)\n" + 
        "\n" + 
        "This hook function is called by built-in breakpoint().\n" + 
        "";

    public final static String sys___displayhook___doc = 
        "displayhook(object) -> None\n" + 
        "\n" + 
        "Print an object to sys.stdout and also save it in builtins._\n" + 
        "";

    public final static String sys_doc = 
        "This module provides access to some objects used or maintained by the\n" + 
        "interpreter and to functions that interact strongly with the interpreter.\n" + 
        "\n" + 
        "Dynamic objects:\n" + 
        "\n" + 
        "argv -- command line arguments; argv[0] is the script pathname if known\n" + 
        "path -- module search path; path[0] is the script directory, else ''\n" + 
        "modules -- dictionary of loaded modules\n" + 
        "\n" + 
        "displayhook -- called to show results in an interactive session\n" + 
        "excepthook -- called to handle any uncaught exception other than SystemExit\n" + 
        "  To customize printing in an interactive session or to install a custom\n" + 
        "  top-level exception handler, assign other functions to replace these.\n" + 
        "\n" + 
        "stdin -- standard input file object; used by input()\n" + 
        "stdout -- standard output file object; used by print()\n" + 
        "stderr -- standard error object; used for error messages\n" + 
        "  By assigning other file objects (or objects that behave like files)\n" + 
        "  to these, it is possible to redirect all of the interpreter's I/O.\n" + 
        "\n" + 
        "last_type -- type of last uncaught exception\n" + 
        "last_value -- value of last uncaught exception\n" + 
        "last_traceback -- traceback of last uncaught exception\n" + 
        "  These three are only available in an interactive session after a\n" + 
        "  traceback has been printed.\n" + 
        "\n" + 
        "Static objects:\n" + 
        "\n" + 
        "builtin_module_names -- tuple of module names built into this interpreter\n" + 
        "copyright -- copyright notice pertaining to this interpreter\n" + 
        "exec_prefix -- prefix used to find the machine-specific Python library\n" + 
        "executable -- absolute path of the executable binary of the Python interpreter\n" + 
        "float_info -- a struct sequence with information about the float implementation.\n" + 
        "float_repr_style -- string indicating the style of repr() output for floats\n" + 
        "hash_info -- a struct sequence with information about the hash algorithm.\n" + 
        "hexversion -- version information encoded as a single integer\n" + 
        "implementation -- Python implementation information.\n" + 
        "int_info -- a struct sequence with information about the int implementation.\n" + 
        "maxsize -- the largest supported length of containers.\n" + 
        "maxunicode -- the value of the largest Unicode code point\n" + 
        "platform -- platform identifier\n" + 
        "prefix -- prefix used to find the Python library\n" + 
        "thread_info -- a struct sequence with information about the thread implementation.\n" + 
        "version -- the version of this interpreter as a string\n" + 
        "version_info -- version information as a named tuple\n" + 
        "__stdin__ -- the original stdin; don't touch!\n" + 
        "__stdout__ -- the original stdout; don't touch!\n" + 
        "__stderr__ -- the original stderr; don't touch!\n" + 
        "__displayhook__ -- the original displayhook; don't touch!\n" + 
        "__excepthook__ -- the original excepthook; don't touch!\n" + 
        "\n" + 
        "Functions:\n" + 
        "\n" + 
        "displayhook() -- print an object to the screen, and save it in builtins._\n" + 
        "excepthook() -- print an exception and its traceback to sys.stderr\n" + 
        "exc_info() -- return thread-safe information about the current exception\n" + 
        "exit() -- exit the interpreter by raising SystemExit\n" + 
        "getdlopenflags() -- returns flags to be used for dlopen() calls\n" + 
        "getprofile() -- get the global profiling function\n" + 
        "getrefcount() -- return the reference count for an object (plus one :-)\n" + 
        "getrecursionlimit() -- return the max recursion depth for the interpreter\n" + 
        "getsizeof() -- return the size of an object in bytes\n" + 
        "gettrace() -- get the global debug tracing function\n" + 
        "setcheckinterval() -- control how often the interpreter checks for events\n" + 
        "setdlopenflags() -- set the flags to be used for dlopen() calls\n" + 
        "setprofile() -- set the global profiling function\n" + 
        "setrecursionlimit() -- set the max recursion depth for the interpreter\n" + 
        "settrace() -- set the global debug tracing function\n" + 
        "";

    public final static String sys___excepthook___doc = 
        "excepthook(exctype, value, traceback) -> None\n" + 
        "\n" + 
        "Handle an exception by displaying it with a traceback on sys.stderr.\n" + 
        "";

    public final static String sys___interactivehook___doc = 
        "";

    public final static String sys___loader___doc = 
        "Meta path import for built-in modules.\n" + 
        "\n" + 
        "    All methods are either class or static methods to avoid the need to\n" + 
        "    instantiate the class.\n" + 
        "\n" + 
        "    ";

    public final static String sys__clear_type_cache_doc = 
        "_clear_type_cache() -> None\n" + 
        "Clear the internal type lookup cache.";

    public final static String sys__current_frames_doc = 
        "_current_frames() -> dictionary\n" + 
        "\n" + 
        "Return a dictionary mapping each current thread T's thread id to T's\n" + 
        "current stack frame.\n" + 
        "\n" + 
        "This function should be used for specialized purposes only.";

    public final static String sys__debugmallocstats_doc = 
        "_debugmallocstats()\n" + 
        "\n" + 
        "Print summary info to stderr about the state of\n" + 
        "pymalloc's structures.\n" + 
        "\n" + 
        "In Py_DEBUG mode, also perform some expensive internal consistency\n" + 
        "checks.\n" + 
        "";

    public final static String sys__getframe_doc = 
        "_getframe([depth]) -> frameobject\n" + 
        "\n" + 
        "Return a frame object from the call stack.  If optional integer depth is\n" + 
        "given, return the frame object that many calls below the top of the stack.\n" + 
        "If that is deeper than the call stack, ValueError is raised.  The default\n" + 
        "for depth is zero, returning the frame at the top of the call stack.\n" + 
        "\n" + 
        "This function should be used for internal and specialized\n" + 
        "purposes only.";

    public final static String sys_breakpointhook_doc = 
        "breakpointhook(*args, **kws)\n" + 
        "\n" + 
        "This hook function is called by built-in breakpoint().\n" + 
        "";

    public final static String sys_call_tracing_doc = 
        "call_tracing(func, args) -> object\n" + 
        "\n" + 
        "Call func(*args), while tracing is enabled.  The tracing state is\n" + 
        "saved, and restored afterwards.  This is intended to be called from\n" + 
        "a debugger from a checkpoint, to recursively debug some other code.";

    public final static String sys_callstats_doc = 
        "callstats() -> tuple of integers\n" + 
        "\n" + 
        "Return a tuple of function call statistics, if CALL_PROFILE was defined\n" + 
        "when Python was built.  Otherwise, return None.\n" + 
        "\n" + 
        "When enabled, this function returns detailed, implementation-specific\n" + 
        "details about the number of function calls executed. The return value is\n" + 
        "a 11-tuple where the entries in the tuple are counts of:\n" + 
        "0. all function calls\n" + 
        "1. calls to PyFunction_Type objects\n" + 
        "2. PyFunction calls that do not create an argument tuple\n" + 
        "3. PyFunction calls that do not create an argument tuple\n" + 
        "   and bypass PyEval_EvalCodeEx()\n" + 
        "4. PyMethod calls\n" + 
        "5. PyMethod calls on bound methods\n" + 
        "6. PyType calls\n" + 
        "7. PyCFunction calls\n" + 
        "8. generator calls\n" + 
        "9. All other calls\n" + 
        "10. Number of stack pops performed by call_function()";

    public final static String sys_displayhook_doc = 
        "displayhook(object) -> None\n" + 
        "\n" + 
        "Print an object to sys.stdout and also save it in builtins._\n" + 
        "";

    public final static String sys_exc_info_doc = 
        "exc_info() -> (type, value, traceback)\n" + 
        "\n" + 
        "Return information about the most recent exception caught by an except\n" + 
        "clause in the current stack frame or in an older stack frame.";

    public final static String sys_excepthook_doc = 
        "excepthook(exctype, value, traceback) -> None\n" + 
        "\n" + 
        "Handle an exception by displaying it with a traceback on sys.stderr.\n" + 
        "";

    public final static String sys_exit_doc = 
        "exit([status])\n" + 
        "\n" + 
        "Exit the interpreter by raising SystemExit(status).\n" + 
        "If the status is omitted or None, it defaults to zero (i.e., success).\n" + 
        "If the status is an integer, it will be used as the system exit status.\n" + 
        "If it is another kind of object, it will be printed and the system\n" + 
        "exit status will be one (i.e., failure).";

    public final static String sys_get_asyncgen_hooks_doc = 
        "get_asyncgen_hooks()\n" + 
        "\n" + 
        "Return a namedtuple of installed asynchronous generators hooks (firstiter, finalizer).";

    public final static String sys_get_coroutine_origin_tracking_depth_doc = 
        "Check status of origin tracking for coroutine objects in this thread.";

    public final static String sys_get_coroutine_origin_tracking_depth_sig = 
        "($module, /)";

    public final static String sys_get_coroutine_wrapper_doc = 
        "get_coroutine_wrapper()\n" + 
        "\n" + 
        "Return the wrapper for coroutine objects set by sys.set_coroutine_wrapper.";

    public final static String sys_getallocatedblocks_doc = 
        "getallocatedblocks() -> integer\n" + 
        "\n" + 
        "Return the number of memory blocks currently allocated, regardless of their\n" + 
        "size.";

    public final static String sys_getcheckinterval_doc = 
        "getcheckinterval() -> current check interval; see setcheckinterval().";

    public final static String sys_getdefaultencoding_doc = 
        "getdefaultencoding() -> string\n" + 
        "\n" + 
        "Return the current default string encoding used by the Unicode \n" + 
        "implementation.";

    public final static String sys_getdlopenflags_doc = 
        "getdlopenflags() -> int\n" + 
        "\n" + 
        "Return the current value of the flags that are used for dlopen calls.\n" + 
        "The flag constants are defined in the os module.";

    public final static String sys_getfilesystemencodeerrors_doc = 
        "getfilesystemencodeerrors() -> string\n" + 
        "\n" + 
        "Return the error mode used to convert Unicode filenames in\n" + 
        "operating system filenames.";

    public final static String sys_getfilesystemencoding_doc = 
        "getfilesystemencoding() -> string\n" + 
        "\n" + 
        "Return the encoding used to convert Unicode filenames in\n" + 
        "operating system filenames.";

    public final static String sys_getprofile_doc = 
        "getprofile()\n" + 
        "\n" + 
        "Return the profiling function set with sys.setprofile.\n" + 
        "See the profiler chapter in the library manual.";

    public final static String sys_getrecursionlimit_doc = 
        "getrecursionlimit()\n" + 
        "\n" + 
        "Return the current value of the recursion limit, the maximum depth\n" + 
        "of the Python interpreter stack.  This limit prevents infinite\n" + 
        "recursion from causing an overflow of the C stack and crashing Python.";

    public final static String sys_getrefcount_doc = 
        "getrefcount(object) -> integer\n" + 
        "\n" + 
        "Return the reference count of object.  The count returned is generally\n" + 
        "one higher than you might expect, because it includes the (temporary)\n" + 
        "reference as an argument to getrefcount().";

    public final static String sys_getsizeof_doc = 
        "getsizeof(object, default) -> int\n" + 
        "\n" + 
        "Return the size of object in bytes.";

    public final static String sys_getswitchinterval_doc = 
        "getswitchinterval() -> current thread switch interval; see setswitchinterval().";

    public final static String sys_gettrace_doc = 
        "gettrace()\n" + 
        "\n" + 
        "Return the global debug tracing function set with sys.settrace.\n" + 
        "See the debugger chapter in the library manual.";

    public final static String sys_intern_doc = 
        "intern(string) -> string\n" + 
        "\n" + 
        "``Intern'' the given string.  This enters the string in the (global)\n" + 
        "table of interned strings whose purpose is to speed up dictionary lookups.\n" + 
        "Return the string itself or the previously interned string object with the\n" + 
        "same value.";

    public final static String sys_is_finalizing_doc = 
        "is_finalizing()\n" + 
        "Return True if Python is exiting.";

    public final static String sys_set_asyncgen_hooks_doc = 
        "set_asyncgen_hooks(*, firstiter=None, finalizer=None)\n" + 
        "\n" + 
        "Set a finalizer for async generators objects.";

    public final static String sys_set_coroutine_origin_tracking_depth_doc = 
        "Enable or disable origin tracking for coroutine objects in this thread.\n" + 
        "\n" + 
        "Coroutine objects will track 'depth' frames of traceback information about\n" + 
        "where they came from, available in their cr_origin attribute. Set depth of 0\n" + 
        "to disable.";

    public final static String sys_set_coroutine_origin_tracking_depth_sig = 
        "($module, /, depth)";

    public final static String sys_set_coroutine_wrapper_doc = 
        "set_coroutine_wrapper(wrapper)\n" + 
        "\n" + 
        "Set a wrapper for coroutine objects.";

    public final static String sys_setcheckinterval_doc = 
        "setcheckinterval(n)\n" + 
        "\n" + 
        "Tell the Python interpreter to check for asynchronous events every\n" + 
        "n instructions.  This also affects how often thread switches occur.";

    public final static String sys_setdlopenflags_doc = 
        "setdlopenflags(n) -> None\n" + 
        "\n" + 
        "Set the flags used by the interpreter for dlopen calls, such as when the\n" + 
        "interpreter loads extension modules.  Among other things, this will enable\n" + 
        "a lazy resolving of symbols when importing a module, if called as\n" + 
        "sys.setdlopenflags(0).  To share symbols across extension modules, call as\n" + 
        "sys.setdlopenflags(os.RTLD_GLOBAL).  Symbolic names for the flag modules\n" + 
        "can be found in the os module (RTLD_xxx constants, e.g. os.RTLD_LAZY).";

    public final static String sys_setprofile_doc = 
        "setprofile(function)\n" + 
        "\n" + 
        "Set the profiling function.  It will be called on each function call\n" + 
        "and return.  See the profiler chapter in the library manual.";

    public final static String sys_setrecursionlimit_doc = 
        "setrecursionlimit(n)\n" + 
        "\n" + 
        "Set the maximum depth of the Python interpreter stack to n.  This\n" + 
        "limit prevents infinite recursion from causing an overflow of the C\n" + 
        "stack and crashing Python.  The highest possible limit is platform-\n" + 
        "dependent.";

    public final static String sys_setswitchinterval_doc = 
        "setswitchinterval(n)\n" + 
        "\n" + 
        "Set the ideal thread switching delay inside the Python interpreter\n" + 
        "The actual frequency of switching threads can be lower if the\n" + 
        "interpreter executes long sequences of uninterruptible code\n" + 
        "(this is implementation-specific and workload-dependent).\n" + 
        "\n" + 
        "The parameter must represent the desired switching delay in seconds\n" + 
        "A typical value is 0.005 (5 milliseconds).";

    public final static String sys_settrace_doc = 
        "settrace(function)\n" + 
        "\n" + 
        "Set the global debug tracing function.  It will be called on each\n" + 
        "function call.  See the debugger chapter in the library manual.";

    // Docs for <module 'time' (built-in)>
    public final static String time_doc = 
        "This module provides various functions to manipulate time values.\n" + 
        "\n" + 
        "There are two standard representations of time.  One is the number\n" + 
        "of seconds since the Epoch, in UTC (a.k.a. GMT).  It may be an integer\n" + 
        "or a floating point number (to represent fractions of seconds).\n" + 
        "The Epoch is system-defined; on Unix, it is generally January 1st, 1970.\n" + 
        "The actual value can be retrieved by calling gmtime(0).\n" + 
        "\n" + 
        "The other representation is a tuple of 9 integers giving local time.\n" + 
        "The tuple items are:\n" + 
        "  year (including century, e.g. 1998)\n" + 
        "  month (1-12)\n" + 
        "  day (1-31)\n" + 
        "  hours (0-23)\n" + 
        "  minutes (0-59)\n" + 
        "  seconds (0-59)\n" + 
        "  weekday (0-6, Monday is 0)\n" + 
        "  Julian day (day in the year, 1-366)\n" + 
        "  DST (Daylight Savings Time) flag (-1, 0 or 1)\n" + 
        "If the DST flag is 0, the time is given in the regular time zone;\n" + 
        "if it is 1, the time is given in the DST time zone;\n" + 
        "if it is -1, mktime() should guess based on the date and time.\n" + 
        "";

    public final static String time___loader___doc = 
        "Meta path import for built-in modules.\n" + 
        "\n" + 
        "    All methods are either class or static methods to avoid the need to\n" + 
        "    instantiate the class.\n" + 
        "\n" + 
        "    ";

    public final static String time_asctime_doc = 
        "asctime([tuple]) -> string\n" + 
        "\n" + 
        "Convert a time tuple to a string, e.g. 'Sat Jun 06 16:26:11 1998'.\n" + 
        "When the time tuple is not present, current time as returned by localtime()\n" + 
        "is used.";

    public final static String time_clock_doc = 
        "clock() -> floating point number\n" + 
        "\n" + 
        "Return the CPU time or real time since the start of the process or since\n" + 
        "the first call to clock().  This has as much precision as the system\n" + 
        "records.";

    public final static String time_clock_getres_doc = 
        "clock_getres(clk_id) -> floating point number\n" + 
        "\n" + 
        "Return the resolution (precision) of the specified clock clk_id.";

    public final static String time_clock_gettime_doc = 
        "clock_gettime(clk_id) -> float\n" + 
        "\n" + 
        "Return the time of the specified clock clk_id.";

    public final static String time_clock_gettime_ns_doc = 
        "clock_gettime_ns(clk_id) -> int\n" + 
        "\n" + 
        "Return the time of the specified clock clk_id as nanoseconds.";

    public final static String time_clock_settime_doc = 
        "clock_settime(clk_id, time)\n" + 
        "\n" + 
        "Set the time of the specified clock clk_id.";

    public final static String time_clock_settime_ns_doc = 
        "clock_settime_ns(clk_id, time)\n" + 
        "\n" + 
        "Set the time of the specified clock clk_id with nanoseconds.";

    public final static String time_ctime_doc = 
        "ctime(seconds) -> string\n" + 
        "\n" + 
        "Convert a time in seconds since the Epoch to a string in local time.\n" + 
        "This is equivalent to asctime(localtime(seconds)). When the time tuple is\n" + 
        "not present, current time as returned by localtime() is used.";

    public final static String time_get_clock_info_doc = 
        "get_clock_info(name: str) -> dict\n" + 
        "\n" + 
        "Get information of the specified clock.";

    public final static String time_gmtime_doc = 
        "gmtime([seconds]) -> (tm_year, tm_mon, tm_mday, tm_hour, tm_min,\n" + 
        "                       tm_sec, tm_wday, tm_yday, tm_isdst)\n" + 
        "\n" + 
        "Convert seconds since the Epoch to a time tuple expressing UTC (a.k.a.\n" + 
        "GMT).  When 'seconds' is not passed in, convert the current time instead.\n" + 
        "\n" + 
        "If the platform supports the tm_gmtoff and tm_zone, they are available as\n" + 
        "attributes only.";

    public final static String time_localtime_doc = 
        "localtime([seconds]) -> (tm_year,tm_mon,tm_mday,tm_hour,tm_min,\n" + 
        "                          tm_sec,tm_wday,tm_yday,tm_isdst)\n" + 
        "\n" + 
        "Convert seconds since the Epoch to a time tuple expressing local time.\n" + 
        "When 'seconds' is not passed in, convert the current time instead.";

    public final static String time_mktime_doc = 
        "mktime(tuple) -> floating point number\n" + 
        "\n" + 
        "Convert a time tuple in local time to seconds since the Epoch.\n" + 
        "Note that mktime(gmtime(0)) will not generally return zero for most\n" + 
        "time zones; instead the returned value will either be equal to that\n" + 
        "of the timezone or altzone attributes on the time module.";

    public final static String time_monotonic_doc = 
        "monotonic() -> float\n" + 
        "\n" + 
        "Monotonic clock, cannot go backward.";

    public final static String time_monotonic_ns_doc = 
        "monotonic_ns() -> int\n" + 
        "\n" + 
        "Monotonic clock, cannot go backward, as nanoseconds.";

    public final static String time_perf_counter_doc = 
        "perf_counter() -> float\n" + 
        "\n" + 
        "Performance counter for benchmarking.";

    public final static String time_perf_counter_ns_doc = 
        "perf_counter_ns() -> int\n" + 
        "\n" + 
        "Performance counter for benchmarking as nanoseconds.";

    public final static String time_process_time_doc = 
        "process_time() -> float\n" + 
        "\n" + 
        "Process time for profiling: sum of the kernel and user-space CPU time.";

    public final static String time_process_time_ns_doc = 
        "process_time() -> int\n" + 
        "\n" + 
        "Process time for profiling as nanoseconds:\n" + 
        "sum of the kernel and user-space CPU time.";

    public final static String time_pthread_getcpuclockid_doc = 
        "pthread_getcpuclockid(thread_id) -> int\n" + 
        "\n" + 
        "Return the clk_id of a thread's CPU time clock.";

    public final static String time_sleep_doc = 
        "sleep(seconds)\n" + 
        "\n" + 
        "Delay execution for a given number of seconds.  The argument may be\n" + 
        "a floating point number for subsecond precision.";

    public final static String time_strftime_doc = 
        "strftime(format[, tuple]) -> string\n" + 
        "\n" + 
        "Convert a time tuple to a string according to a format specification.\n" + 
        "See the library reference manual for formatting codes. When the time tuple\n" + 
        "is not present, current time as returned by localtime() is used.\n" + 
        "\n" + 
        "Commonly used format codes:\n" + 
        "\n" + 
        "%Y  Year with century as a decimal number.\n" + 
        "%m  Month as a decimal number [01,12].\n" + 
        "%d  Day of the month as a decimal number [01,31].\n" + 
        "%H  Hour (24-hour clock) as a decimal number [00,23].\n" + 
        "%M  Minute as a decimal number [00,59].\n" + 
        "%S  Second as a decimal number [00,61].\n" + 
        "%z  Time zone offset from UTC.\n" + 
        "%a  Locale's abbreviated weekday name.\n" + 
        "%A  Locale's full weekday name.\n" + 
        "%b  Locale's abbreviated month name.\n" + 
        "%B  Locale's full month name.\n" + 
        "%c  Locale's appropriate date and time representation.\n" + 
        "%I  Hour (12-hour clock) as a decimal number [01,12].\n" + 
        "%p  Locale's equivalent of either AM or PM.\n" + 
        "\n" + 
        "Other codes may be available on your platform.  See documentation for\n" + 
        "the C library strftime function.\n" + 
        "";

    public final static String time_strptime_doc = 
        "strptime(string, format) -> struct_time\n" + 
        "\n" + 
        "Parse a string to a time tuple according to a format specification.\n" + 
        "See the library reference manual for formatting codes (same as\n" + 
        "strftime()).\n" + 
        "\n" + 
        "Commonly used format codes:\n" + 
        "\n" + 
        "%Y  Year with century as a decimal number.\n" + 
        "%m  Month as a decimal number [01,12].\n" + 
        "%d  Day of the month as a decimal number [01,31].\n" + 
        "%H  Hour (24-hour clock) as a decimal number [00,23].\n" + 
        "%M  Minute as a decimal number [00,59].\n" + 
        "%S  Second as a decimal number [00,61].\n" + 
        "%z  Time zone offset from UTC.\n" + 
        "%a  Locale's abbreviated weekday name.\n" + 
        "%A  Locale's full weekday name.\n" + 
        "%b  Locale's abbreviated month name.\n" + 
        "%B  Locale's full month name.\n" + 
        "%c  Locale's appropriate date and time representation.\n" + 
        "%I  Hour (12-hour clock) as a decimal number [01,12].\n" + 
        "%p  Locale's equivalent of either AM or PM.\n" + 
        "\n" + 
        "Other codes may be available on your platform.  See documentation for\n" + 
        "the C library strftime function.\n" + 
        "";

    public final static String time_struct_time_doc = 
        "The time value as returned by gmtime(), localtime(), and strptime(), and\n" + 
        " accepted by asctime(), mktime() and strftime().  May be considered as a\n" + 
        " sequence of 9 integers.\n" + 
        "\n" + 
        " Note that several fields' values are not the same as those defined by\n" + 
        " the C language standard for struct tm.  For example, the value of the\n" + 
        " field tm_year is the actual year, not year - 1900.  See individual\n" + 
        " fields' descriptions for details.";

    public final static String time_thread_time_doc = 
        "thread_time() -> float\n" + 
        "\n" + 
        "Thread time for profiling: sum of the kernel and user-space CPU time.";

    public final static String time_thread_time_ns_doc = 
        "thread_time() -> int\n" + 
        "\n" + 
        "Thread time for profiling as nanoseconds:\n" + 
        "sum of the kernel and user-space CPU time.";

    public final static String time_time_doc = 
        "time() -> floating point number\n" + 
        "\n" + 
        "Return the current time in seconds since the Epoch.\n" + 
        "Fractions of a second may be present if the system clock provides them.";

    public final static String time_time_ns_doc = 
        "time_ns() -> int\n" + 
        "\n" + 
        "Return the current time in nanoseconds since the Epoch.";

    public final static String time_tzset_doc = 
        "tzset()\n" + 
        "\n" + 
        "Initialize, or reinitialize, the local timezone to the value stored in\n" + 
        "os.environ['TZ']. The TZ environment variable should be specified in\n" + 
        "standard Unix timezone format as documented in the tzset man page\n" + 
        "(eg. 'US/Eastern', 'Europe/Amsterdam'). Unknown timezones will silently\n" + 
        "fall back to UTC. If the TZ environment variable is not set, the local\n" + 
        "timezone is set to the systems best guess of wallclock time.\n" + 
        "Changing the TZ environment variable without calling tzset *may* change\n" + 
        "the local timezone used by methods such as localtime, but this behaviour\n" + 
        "should not be relied on.";

    // Docs for <module 'binascii' from '/home/isaiah/codes/python/build/lib.linux-x86_64-3.7/binascii.cpython-37m-x86_64-linux-gnu.so'>
    public final static String binascii_Error_doc = 
        "";

    public final static String binascii_Incomplete_doc = 
        "";

    public final static String binascii_doc = 
        "Conversion between binary data and ASCII";

    public final static String binascii_a2b_base64_doc = 
        "Decode a line of base64 data.";

    public final static String binascii_a2b_base64_sig = 
        "($module, data, /)";

    public final static String binascii_a2b_hex_doc = 
        "Binary data of hexadecimal representation.\n" + 
        "\n" + 
        "hexstr must contain an even number of hex digits (upper or lower case).\n" + 
        "This function is also available as \"unhexlify()\".";

    public final static String binascii_a2b_hex_sig = 
        "($module, hexstr, /)";

    public final static String binascii_a2b_hqx_doc = 
        "Decode .hqx coding.";

    public final static String binascii_a2b_hqx_sig = 
        "($module, data, /)";

    public final static String binascii_a2b_qp_doc = 
        "Decode a string of qp-encoded data.";

    public final static String binascii_a2b_qp_sig = 
        "($module, /, data, header=False)";

    public final static String binascii_a2b_uu_doc = 
        "Decode a line of uuencoded data.";

    public final static String binascii_a2b_uu_sig = 
        "($module, data, /)";

    public final static String binascii_b2a_base64_doc = 
        "Base64-code line of data.";

    public final static String binascii_b2a_base64_sig = 
        "($module, data, /, *, newline=True)";

    public final static String binascii_b2a_hex_doc = 
        "Hexadecimal representation of binary data.\n" + 
        "\n" + 
        "The return value is a bytes object.  This function is also\n" + 
        "available as \"hexlify()\".";

    public final static String binascii_b2a_hex_sig = 
        "($module, data, /)";

    public final static String binascii_b2a_hqx_doc = 
        "Encode .hqx data.";

    public final static String binascii_b2a_hqx_sig = 
        "($module, data, /)";

    public final static String binascii_b2a_qp_doc = 
        "Encode a string using quoted-printable encoding.\n" + 
        "\n" + 
        "On encoding, when istext is set, newlines are not encoded, and white\n" + 
        "space at end of lines is.  When istext is not set, \\r and \\n (CR/LF)\n" + 
        "are both encoded.  When quotetabs is set, space and tabs are encoded.";

    public final static String binascii_b2a_qp_sig = 
        "($module, /, data, quotetabs=False, istext=True, header=False)";

    public final static String binascii_b2a_uu_doc = 
        "Uuencode line of data.";

    public final static String binascii_b2a_uu_sig = 
        "($module, data, /, *, backtick=False)";

    public final static String binascii_crc32_doc = 
        "Compute CRC-32 incrementally.";

    public final static String binascii_crc32_sig = 
        "($module, data, crc=0, /)";

    public final static String binascii_crc_hqx_doc = 
        "Compute CRC-CCITT incrementally.";

    public final static String binascii_crc_hqx_sig = 
        "($module, data, crc, /)";

    public final static String binascii_hexlify_doc = 
        "Hexadecimal representation of binary data.\n" + 
        "\n" + 
        "The return value is a bytes object.";

    public final static String binascii_hexlify_sig = 
        "($module, data, /)";

    public final static String binascii_rlecode_hqx_doc = 
        "Binhex RLE-code binary data.";

    public final static String binascii_rlecode_hqx_sig = 
        "($module, data, /)";

    public final static String binascii_rledecode_hqx_doc = 
        "Decode hexbin RLE-coded string.";

    public final static String binascii_rledecode_hqx_sig = 
        "($module, data, /)";

    public final static String binascii_unhexlify_doc = 
        "Binary data of hexadecimal representation.\n" + 
        "\n" + 
        "hexstr must contain an even number of hex digits (upper or lower case).";

    public final static String binascii_unhexlify_sig = 
        "($module, hexstr, /)";

    // Docs for <module 'zipimport' (built-in)>
    public final static String zipimport_ZipImportError_doc = 
        "";

    public final static String zipimport_doc = 
        "zipimport provides support for importing Python modules from Zip archives.\n" + 
        "\n" + 
        "This module exports three objects:\n" + 
        "- zipimporter: a class; its constructor takes a path to a Zip archive.\n" + 
        "- ZipImportError: exception raised by zipimporter objects. It's a\n" + 
        "  subclass of ImportError, so it can be caught as ImportError, too.\n" + 
        "- _zip_directory_cache: a dict, mapping archive paths to zip directory\n" + 
        "  info dicts, as used in zipimporter._files.\n" + 
        "\n" + 
        "It is usually not needed to use the zipimport module explicitly; it is\n" + 
        "used by the builtin import mechanism for sys.path items that are paths\n" + 
        "to Zip archives.";

    public final static String zipimport___loader___doc = 
        "Meta path import for built-in modules.\n" + 
        "\n" + 
        "    All methods are either class or static methods to avoid the need to\n" + 
        "    instantiate the class.\n" + 
        "\n" + 
        "    ";

    public final static String zipimport_zipimporter_doc = 
        "Create a new zipimporter instance.\n" + 
        "\n" + 
        "  archivepath\n" + 
        "    A path-like object to a zipfile, or to a specific path inside\n" + 
        "    a zipfile.\n" + 
        "\n" + 
        "'archivepath' must be a path-like object to a zipfile, or to a specific path\n" + 
        "inside a zipfile. For example, it can be '/tmp/myimport.zip', or\n" + 
        "'/tmp/myimport.zip/mydirectory', if mydirectory is a valid directory inside\n" + 
        "the archive.\n" + 
        "\n" + 
        "'ZipImportError' is raised if 'archivepath' doesn't point to a valid Zip\n" + 
        "archive.\n" + 
        "\n" + 
        "The 'archive' attribute of the zipimporter object contains the name of the\n" + 
        "zipfile targeted.";

    public final static String zipimport_zipimporter_sig = 
        "(archivepath, /)";

    // Docs for <module '_functools' (built-in)>
    public final static String _functools_doc = 
        "Tools that operate on functions.";

    public final static String _functools___loader___doc = 
        "Meta path import for built-in modules.\n" + 
        "\n" + 
        "    All methods are either class or static methods to avoid the need to\n" + 
        "    instantiate the class.\n" + 
        "\n" + 
        "    ";

    public final static String _functools__lru_cache_wrapper_doc = 
        "Create a cached callable that wraps another function.\n" + 
        "\n" + 
        "user_function:      the function being cached\n" + 
        "\n" + 
        "maxsize:  0         for no caching\n" + 
        "          None      for unlimited cache size\n" + 
        "          n         for a bounded cache\n" + 
        "\n" + 
        "typed:    False     cache f(3) and f(3.0) as identical calls\n" + 
        "          True      cache f(3) and f(3.0) as distinct calls\n" + 
        "\n" + 
        "cache_info_type:    namedtuple class with the fields:\n" + 
        "                        hits misses currsize maxsize\n" + 
        "";

    public final static String _functools_cmp_to_key_doc = 
        "Convert a cmp= function into a key= function.";

    public final static String _functools_partial_doc = 
        "partial(func, *args, **keywords) - new function with partial application\n" + 
        "    of the given arguments and keywords.\n" + 
        "";

    public final static String _functools_reduce_doc = 
        "reduce(function, sequence[, initial]) -> value\n" + 
        "\n" + 
        "Apply a function of two arguments cumulatively to the items of a sequence,\n" + 
        "from left to right, so as to reduce the sequence to a single value.\n" + 
        "For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n" + 
        "((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n" + 
        "of the sequence in the calculation, and serves as a default when the\n" + 
        "sequence is empty.";

    // Docs for <module '_hashlib' from '/home/isaiah/codes/python/build/lib.linux-x86_64-3.7/_hashlib.cpython-37m-x86_64-linux-gnu.so'>
    public final static String _hashlib_HASH_doc = 
        "A hash represents the object used to calculate a checksum of a\n" + 
        "string of information.\n" + 
        "\n" + 
        "Methods:\n" + 
        "\n" + 
        "update() -- updates the current digest with an additional string\n" + 
        "digest() -- return the current digest value\n" + 
        "hexdigest() -- return the current digest as a string of hexadecimal digits\n" + 
        "copy() -- return a copy of the current hash object\n" + 
        "\n" + 
        "Attributes:\n" + 
        "\n" + 
        "name -- the hash algorithm being used by this object\n" + 
        "digest_size -- number of bytes in this hashes output\n" + 
        "";

    public final static String _hashlib_doc = 
        "";

    public final static String _hashlib_hmac_digest_doc = 
        "Single-shot HMAC";

    public final static String _hashlib_hmac_digest_sig = 
        "($module, /, key, msg, digest)";

    public final static String _hashlib_new_doc = 
        "Return a new hash object using the named algorithm.\n" + 
        "An optional string argument may be provided and will be\n" + 
        "automatically hashed.\n" + 
        "\n" + 
        "The MD5 and SHA1 algorithms are always supported.\n" + 
        "";

    public final static String _hashlib_openssl_md5_doc = 
        "Returns a md5 hash object; optionally initialized with a string";

    public final static String _hashlib_openssl_sha1_doc = 
        "Returns a sha1 hash object; optionally initialized with a string";

    public final static String _hashlib_openssl_sha224_doc = 
        "Returns a sha224 hash object; optionally initialized with a string";

    public final static String _hashlib_openssl_sha256_doc = 
        "Returns a sha256 hash object; optionally initialized with a string";

    public final static String _hashlib_openssl_sha384_doc = 
        "Returns a sha384 hash object; optionally initialized with a string";

    public final static String _hashlib_openssl_sha512_doc = 
        "Returns a sha512 hash object; optionally initialized with a string";

    public final static String _hashlib_pbkdf2_hmac_doc = 
        "pbkdf2_hmac(hash_name, password, salt, iterations, dklen=None) -> key\n" + 
        "\n" + 
        "Password based key derivation function 2 (PKCS #5 v2.0) with HMAC as\n" + 
        "pseudorandom function.";

    public final static String _hashlib_scrypt_doc = 
        "scrypt password-based key derivation function.";

    public final static String _hashlib_scrypt_sig = 
        "($module, /, password, *, salt=None, n=None, r=None, p=None,\n" + 
        "       maxmem=0, dklen=64)";

    // Docs for <module 'io' (built-in)>
    public final static String io_BlockingIOError_doc = 
        "I/O operation would block.";

    public final static String io_BufferedRWPair_doc = 
        "A buffered reader and writer object together.\n" + 
        "\n" + 
        "A buffered reader object and buffered writer object put together to\n" + 
        "form a sequential IO object that can read and write. This is typically\n" + 
        "used with a socket or two-way pipe.\n" + 
        "\n" + 
        "reader and writer are RawIOBase objects that are readable and\n" + 
        "writeable respectively. If the buffer_size is omitted it defaults to\n" + 
        "DEFAULT_BUFFER_SIZE.";

    public final static String io_BufferedRWPair_sig = 
        "(reader, writer, buffer_size=DEFAULT_BUFFER_SIZE, /)";

    public final static String io_BufferedRandom_doc = 
        "A buffered interface to random access streams.\n" + 
        "\n" + 
        "The constructor creates a reader and writer for a seekable stream,\n" + 
        "raw, given in the first argument. If the buffer_size is omitted it\n" + 
        "defaults to DEFAULT_BUFFER_SIZE.";

    public final static String io_BufferedRandom_sig = 
        "(raw, buffer_size=DEFAULT_BUFFER_SIZE)";

    public final static String io_BufferedReader_doc = 
        "Create a new buffered reader using the given readable raw IO object.";

    public final static String io_BufferedReader_sig = 
        "(raw, buffer_size=DEFAULT_BUFFER_SIZE)";

    public final static String io_BufferedWriter_doc = 
        "A buffer for a writeable sequential RawIO object.\n" + 
        "\n" + 
        "The constructor creates a BufferedWriter for the given writeable raw\n" + 
        "stream. If the buffer_size is not given, it defaults to\n" + 
        "DEFAULT_BUFFER_SIZE.";

    public final static String io_BufferedWriter_sig = 
        "(raw, buffer_size=DEFAULT_BUFFER_SIZE)";

    public final static String io_BytesIO_doc = 
        "Buffered I/O implementation using an in-memory bytes buffer.";

    public final static String io_BytesIO_sig = 
        "(initial_bytes=b'')";

    public final static String io_FileIO_doc = 
        "Open a file.\n" + 
        "\n" + 
        "The mode can be 'r' (default), 'w', 'x' or 'a' for reading,\n" + 
        "writing, exclusive creation or appending.  The file will be created if it\n" + 
        "doesn't exist when opened for writing or appending; it will be truncated\n" + 
        "when opened for writing.  A FileExistsError will be raised if it already\n" + 
        "exists when opened for creating. Opening a file for creating implies\n" + 
        "writing so this mode behaves in a similar way to 'w'.Add a '+' to the mode\n" + 
        "to allow simultaneous reading and writing. A custom opener can be used by\n" + 
        "passing a callable as *opener*. The underlying file descriptor for the file\n" + 
        "object is then obtained by calling opener with (*name*, *flags*).\n" + 
        "*opener* must return an open file descriptor (passing os.open as *opener*\n" + 
        "results in functionality similar to passing None).";

    public final static String io_FileIO_sig = 
        "(file, mode='r', closefd=True, opener=None)";

    public final static String io_IncrementalNewlineDecoder_doc = 
        "Codec used when reading a file in universal newlines mode.\n" + 
        "\n" + 
        "It wraps another incremental decoder, translating \\r\\n and \\r into \\n.\n" + 
        "It also records the types of newlines encountered.  When used with\n" + 
        "translate=False, it ensures that the newline sequence is returned in\n" + 
        "one piece. When used with decoder=None, it expects unicode strings as\n" + 
        "decode input and translates newlines without first invoking an external\n" + 
        "decoder.";

    public final static String io_IncrementalNewlineDecoder_sig = 
        "(decoder, translate, errors='strict')";

    public final static String io_StringIO_doc = 
        "Text I/O implementation using an in-memory buffer.\n" + 
        "\n" + 
        "The initial_value argument sets the value of object.  The newline\n" + 
        "argument is like the one of TextIOWrapper's constructor.";

    public final static String io_StringIO_sig = 
        "(initial_value='', newline='\\n')";

    public final static String io_TextIOWrapper_doc = 
        "Character and line based layer over a BufferedIOBase object, buffer.\n" + 
        "\n" + 
        "encoding gives the name of the encoding that the stream will be\n" + 
        "decoded or encoded with. It defaults to locale.getpreferredencoding(False).\n" + 
        "\n" + 
        "errors determines the strictness of encoding and decoding (see\n" + 
        "help(codecs.Codec) or the documentation for codecs.register) and\n" + 
        "defaults to \"strict\".\n" + 
        "\n" + 
        "newline controls how line endings are handled. It can be None, '',\n" + 
        "'\\n', '\\r', and '\\r\\n'.  It works as follows:\n" + 
        "\n" + 
        "* On input, if newline is None, universal newlines mode is\n" + 
        "  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n" + 
        "  these are translated into '\\n' before being returned to the\n" + 
        "  caller. If it is '', universal newline mode is enabled, but line\n" + 
        "  endings are returned to the caller untranslated. If it has any of\n" + 
        "  the other legal values, input lines are only terminated by the given\n" + 
        "  string, and the line ending is returned to the caller untranslated.\n" + 
        "\n" + 
        "* On output, if newline is None, any '\\n' characters written are\n" + 
        "  translated to the system default line separator, os.linesep. If\n" + 
        "  newline is '' or '\\n', no translation takes place. If newline is any\n" + 
        "  of the other legal values, any '\\n' characters written are translated\n" + 
        "  to the given string.\n" + 
        "\n" + 
        "If line_buffering is True, a call to flush is implied when a call to\n" + 
        "write contains a newline character.";

    public final static String io_TextIOWrapper_sig = 
        "(buffer, encoding=None, errors=None, newline=None,\n" + 
        "              line_buffering=False, write_through=False)";

    public final static String io_UnsupportedOperation_doc = 
        "";

    public final static String io__BufferedIOBase_doc = 
        "Base class for buffered IO objects.\n" + 
        "\n" + 
        "The main difference with RawIOBase is that the read() method\n" + 
        "supports omitting the size argument, and does not have a default\n" + 
        "implementation that defers to readinto().\n" + 
        "\n" + 
        "In addition, read(), readinto() and write() may raise\n" + 
        "BlockingIOError if the underlying raw stream is in non-blocking\n" + 
        "mode and not ready; unlike their raw counterparts, they will never\n" + 
        "return None.\n" + 
        "\n" + 
        "A typical implementation should not inherit from a RawIOBase\n" + 
        "implementation, but wrap one.\n" + 
        "";

    public final static String io__IOBase_doc = 
        "The abstract base class for all I/O classes, acting on streams of\n" + 
        "bytes. There is no public constructor.\n" + 
        "\n" + 
        "This class provides dummy implementations for many methods that\n" + 
        "derived classes can override selectively; the default implementations\n" + 
        "represent a file that cannot be read, written or seeked.\n" + 
        "\n" + 
        "Even though IOBase does not declare read, readinto, or write because\n" + 
        "their signatures will vary, implementations and clients should\n" + 
        "consider those methods part of the interface. Also, implementations\n" + 
        "may raise UnsupportedOperation when operations they do not support are\n" + 
        "called.\n" + 
        "\n" + 
        "The basic type used for binary data read from or written to a file is\n" + 
        "bytes. Other bytes-like objects are accepted as method arguments too.\n" + 
        "In some cases (such as readinto), a writable object is required. Text\n" + 
        "I/O classes work with str data.\n" + 
        "\n" + 
        "Note that calling any method (except additional calls to close(),\n" + 
        "which are ignored) on a closed stream should raise a ValueError.\n" + 
        "\n" + 
        "IOBase (and its subclasses) support the iterator protocol, meaning\n" + 
        "that an IOBase object can be iterated over yielding the lines in a\n" + 
        "stream.\n" + 
        "\n" + 
        "IOBase also supports the :keyword:`with` statement. In this example,\n" + 
        "fp is closed after the suite of the with statement is complete:\n" + 
        "\n" + 
        "with open('spam.txt', 'r') as fp:\n" + 
        "    fp.write('Spam and eggs!')\n" + 
        "";

    public final static String io__RawIOBase_doc = 
        "Base class for raw binary I/O.";

    public final static String io__TextIOBase_doc = 
        "Base class for text I/O.\n" + 
        "\n" + 
        "This class provides a character and line based interface to stream\n" + 
        "I/O. There is no readinto method because Python's character strings\n" + 
        "are immutable. There is no public constructor.\n" + 
        "";

    public final static String io_doc = 
        "The io module provides the Python interfaces to stream handling. The\n" + 
        "builtin open function is defined in this module.\n" + 
        "\n" + 
        "At the top of the I/O hierarchy is the abstract base class IOBase. It\n" + 
        "defines the basic interface to a stream. Note, however, that there is no\n" + 
        "separation between reading and writing to streams; implementations are\n" + 
        "allowed to raise an OSError if they do not support a given operation.\n" + 
        "\n" + 
        "Extending IOBase is RawIOBase which deals simply with the reading and\n" + 
        "writing of raw bytes to a stream. FileIO subclasses RawIOBase to provide\n" + 
        "an interface to OS files.\n" + 
        "\n" + 
        "BufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its\n" + 
        "subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer\n" + 
        "streams that are readable, writable, and both respectively.\n" + 
        "BufferedRandom provides a buffered interface to random access\n" + 
        "streams. BytesIO is a simple stream of in-memory bytes.\n" + 
        "\n" + 
        "Another IOBase subclass, TextIOBase, deals with the encoding and decoding\n" + 
        "of streams into text. TextIOWrapper, which extends it, is a buffered text\n" + 
        "interface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO\n" + 
        "is an in-memory stream for text.\n" + 
        "\n" + 
        "Argument names are not part of the specification, and only the arguments\n" + 
        "of open() are intended to be used as keyword arguments.\n" + 
        "\n" + 
        "data:\n" + 
        "\n" + 
        "DEFAULT_BUFFER_SIZE\n" + 
        "\n" + 
        "   An int containing the default buffer size used by the module's buffered\n" + 
        "   I/O classes. open() uses the file's blksize (as obtained by os.stat) if\n" + 
        "   possible.\n" + 
        "";

    public final static String io___loader___doc = 
        "Meta path import for built-in modules.\n" + 
        "\n" + 
        "    All methods are either class or static methods to avoid the need to\n" + 
        "    instantiate the class.\n" + 
        "\n" + 
        "    ";

    public final static String io_open_doc = 
        "Open file and return a stream.  Raise OSError upon failure.\n" + 
        "\n" + 
        "file is either a text or byte string giving the name (and the path\n" + 
        "if the file isn't in the current working directory) of the file to\n" + 
        "be opened or an integer file descriptor of the file to be\n" + 
        "wrapped. (If a file descriptor is given, it is closed when the\n" + 
        "returned I/O object is closed, unless closefd is set to False.)\n" + 
        "\n" + 
        "mode is an optional string that specifies the mode in which the file\n" + 
        "is opened. It defaults to 'r' which means open for reading in text\n" + 
        "mode.  Other common values are 'w' for writing (truncating the file if\n" + 
        "it already exists), 'x' for creating and writing to a new file, and\n" + 
        "'a' for appending (which on some Unix systems, means that all writes\n" + 
        "append to the end of the file regardless of the current seek position).\n" + 
        "In text mode, if encoding is not specified the encoding used is platform\n" + 
        "dependent: locale.getpreferredencoding(False) is called to get the\n" + 
        "current locale encoding. (For reading and writing raw bytes use binary\n" + 
        "mode and leave encoding unspecified.) The available modes are:\n" + 
        "\n" + 
        "========= ===============================================================\n" + 
        "Character Meaning\n" + 
        "--------- ---------------------------------------------------------------\n" + 
        "'r'       open for reading (default)\n" + 
        "'w'       open for writing, truncating the file first\n" + 
        "'x'       create a new file and open it for writing\n" + 
        "'a'       open for writing, appending to the end of the file if it exists\n" + 
        "'b'       binary mode\n" + 
        "'t'       text mode (default)\n" + 
        "'+'       open a disk file for updating (reading and writing)\n" + 
        "'U'       universal newline mode (deprecated)\n" + 
        "========= ===============================================================\n" + 
        "\n" + 
        "The default mode is 'rt' (open for reading text). For binary random\n" + 
        "access, the mode 'w+b' opens and truncates the file to 0 bytes, while\n" + 
        "'r+b' opens the file without truncation. The 'x' mode implies 'w' and\n" + 
        "raises an `FileExistsError` if the file already exists.\n" + 
        "\n" + 
        "Python distinguishes between files opened in binary and text modes,\n" + 
        "even when the underlying operating system doesn't. Files opened in\n" + 
        "binary mode (appending 'b' to the mode argument) return contents as\n" + 
        "bytes objects without any decoding. In text mode (the default, or when\n" + 
        "'t' is appended to the mode argument), the contents of the file are\n" + 
        "returned as strings, the bytes having been first decoded using a\n" + 
        "platform-dependent encoding or using the specified encoding if given.\n" + 
        "\n" + 
        "'U' mode is deprecated and will raise an exception in future versions\n" + 
        "of Python.  It has no effect in Python 3.  Use newline to control\n" + 
        "universal newlines mode.\n" + 
        "\n" + 
        "buffering is an optional integer used to set the buffering policy.\n" + 
        "Pass 0 to switch buffering off (only allowed in binary mode), 1 to select\n" + 
        "line buffering (only usable in text mode), and an integer > 1 to indicate\n" + 
        "the size of a fixed-size chunk buffer.  When no buffering argument is\n" + 
        "given, the default buffering policy works as follows:\n" + 
        "\n" + 
        "* Binary files are buffered in fixed-size chunks; the size of the buffer\n" + 
        "  is chosen using a heuristic trying to determine the underlying device's\n" + 
        "  \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n" + 
        "  On many systems, the buffer will typically be 4096 or 8192 bytes long.\n" + 
        "\n" + 
        "* \"Interactive\" text files (files for which isatty() returns True)\n" + 
        "  use line buffering.  Other text files use the policy described above\n" + 
        "  for binary files.\n" + 
        "\n" + 
        "encoding is the name of the encoding used to decode or encode the\n" + 
        "file. This should only be used in text mode. The default encoding is\n" + 
        "platform dependent, but any encoding supported by Python can be\n" + 
        "passed.  See the codecs module for the list of supported encodings.\n" + 
        "\n" + 
        "errors is an optional string that specifies how encoding errors are to\n" + 
        "be handled---this argument should not be used in binary mode. Pass\n" + 
        "'strict' to raise a ValueError exception if there is an encoding error\n" + 
        "(the default of None has the same effect), or pass 'ignore' to ignore\n" + 
        "errors. (Note that ignoring encoding errors can lead to data loss.)\n" + 
        "See the documentation for codecs.register or run 'help(codecs.Codec)'\n" + 
        "for a list of the permitted encoding error strings.\n" + 
        "\n" + 
        "newline controls how universal newlines works (it only applies to text\n" + 
        "mode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works as\n" + 
        "follows:\n" + 
        "\n" + 
        "* On input, if newline is None, universal newlines mode is\n" + 
        "  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n" + 
        "  these are translated into '\\n' before being returned to the\n" + 
        "  caller. If it is '', universal newline mode is enabled, but line\n" + 
        "  endings are returned to the caller untranslated. If it has any of\n" + 
        "  the other legal values, input lines are only terminated by the given\n" + 
        "  string, and the line ending is returned to the caller untranslated.\n" + 
        "\n" + 
        "* On output, if newline is None, any '\\n' characters written are\n" + 
        "  translated to the system default line separator, os.linesep. If\n" + 
        "  newline is '' or '\\n', no translation takes place. If newline is any\n" + 
        "  of the other legal values, any '\\n' characters written are translated\n" + 
        "  to the given string.\n" + 
        "\n" + 
        "If closefd is False, the underlying file descriptor will be kept open\n" + 
        "when the file is closed. This does not work when a file name is given\n" + 
        "and must be True in that case.\n" + 
        "\n" + 
        "A custom opener can be used by passing a callable as *opener*. The\n" + 
        "underlying file descriptor for the file object is then obtained by\n" + 
        "calling *opener* with (*file*, *flags*). *opener* must return an open\n" + 
        "file descriptor (passing os.open as *opener* results in functionality\n" + 
        "similar to passing None).\n" + 
        "\n" + 
        "open() returns a file object whose type depends on the mode, and\n" + 
        "through which the standard file operations such as reading and writing\n" + 
        "are performed. When open() is used to open a file in a text mode ('w',\n" + 
        "'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\n" + 
        "a file in a binary mode, the returned class varies: in read binary\n" + 
        "mode, it returns a BufferedReader; in write binary and append binary\n" + 
        "modes, it returns a BufferedWriter, and in read/write mode, it returns\n" + 
        "a BufferedRandom.\n" + 
        "\n" + 
        "It is also possible to use a string or bytearray as a file for both\n" + 
        "reading and writing. For strings StringIO can be used like a file\n" + 
        "opened in a text mode, and for bytes a BytesIO can be used like a file\n" + 
        "opened in a binary mode.";

    public final static String io_open_sig = 
        "($module, /, file, mode='r', buffering=-1, encoding=None,\n" + 
        "     errors=None, newline=None, closefd=True, opener=None)";

    // Docs for <module '_json' from '/home/isaiah/codes/python/build/lib.linux-x86_64-3.7/_json.cpython-37m-x86_64-linux-gnu.so'>
    public final static String _json_doc = 
        "json speedups\n" + 
        "";

    public final static String _json_encode_basestring_doc = 
        "encode_basestring(string) -> string\n" + 
        "\n" + 
        "Return a JSON representation of a Python string";

    public final static String _json_encode_basestring_ascii_doc = 
        "encode_basestring_ascii(string) -> string\n" + 
        "\n" + 
        "Return an ASCII-only JSON representation of a Python string";

    public final static String _json_make_encoder_doc = 
        "_iterencode(obj, _current_indent_level) -> iterable";

    public final static String _json_make_scanner_doc = 
        "JSON scanner object";

    public final static String _json_scanstring_doc = 
        "scanstring(string, end, strict=True) -> (string, end)\n" + 
        "\n" + 
        "Scan the string s for a JSON string. End is the index of the\n" + 
        "character in s after the quote that started the JSON string.\n" + 
        "Unescapes all valid JSON string escape sequences and raises ValueError\n" + 
        "on attempt to decode an invalid string. If strict is False then literal\n" + 
        "control characters are allowed in the string.\n" + 
        "\n" + 
        "Returns a tuple of the decoded string and the index of the character in s\n" + 
        "after the end quote.";

    // Docs for <module '_struct' from '/home/isaiah/codes/python/build/lib.linux-x86_64-3.7/_struct.cpython-37m-x86_64-linux-gnu.so'>
    public final static String _struct_Struct_doc = 
        "Create a compiled struct object.\n" + 
        "\n" + 
        "Return a new Struct object which writes and reads binary data according to\n" + 
        "the format string.\n" + 
        "\n" + 
        "See help(struct) for more on format strings.";

    public final static String _struct_Struct_sig = 
        "(format)";

    public final static String _struct_doc = 
        "Functions to convert between Python values and C structs.\n" + 
        "Python bytes objects are used to hold the data representing the C struct\n" + 
        "and also as format strings (explained below) to describe the layout of data\n" + 
        "in the C struct.\n" + 
        "\n" + 
        "The optional first format char indicates byte order, size and alignment:\n" + 
        "  @: native order, size & alignment (default)\n" + 
        "  =: native order, std. size & alignment\n" + 
        "  <: little-endian, std. size & alignment\n" + 
        "  >: big-endian, std. size & alignment\n" + 
        "  !: same as >\n" + 
        "\n" + 
        "The remaining chars indicate types of args and must match exactly;\n" + 
        "these can be preceded by a decimal repeat count:\n" + 
        "  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n" + 
        "  ?: _Bool (requires C99; if not available, char is used instead)\n" + 
        "  h:short; H:unsigned short; i:int; I:unsigned int;\n" + 
        "  l:long; L:unsigned long; f:float; d:double; e:half-float.\n" + 
        "Special cases (preceding decimal count indicates length):\n" + 
        "  s:string (array of char); p: pascal string (with count byte).\n" + 
        "Special cases (only available in native format):\n" + 
        "  n:ssize_t; N:size_t;\n" + 
        "  P:an integer type that is wide enough to hold a pointer.\n" + 
        "Special case (not in native mode unless 'long long' in platform C):\n" + 
        "  q:long long; Q:unsigned long long\n" + 
        "Whitespace between formats is ignored.\n" + 
        "\n" + 
        "The variable struct.error is an exception raised on errors.\n" + 
        "";

    public final static String _struct__clearcache_doc = 
        "Clear the internal cache.";

    public final static String _struct__clearcache_sig = 
        "($module, /)";

    public final static String _struct_calcsize_doc = 
        "Return size in bytes of the struct described by the format string.";

    public final static String _struct_calcsize_sig = 
        "($module, format, /)";

    public final static String _struct_error_doc = 
        "";

    public final static String _struct_iter_unpack_doc = 
        "Return an iterator yielding tuples unpacked from the given bytes.\n" + 
        "\n" + 
        "The bytes are unpacked according to the format string, like\n" + 
        "a repeated invocation of unpack_from().\n" + 
        "\n" + 
        "Requires that the bytes length be a multiple of the format struct size.";

    public final static String _struct_iter_unpack_sig = 
        "($module, format, buffer, /)";

    public final static String _struct_pack_doc = 
        "pack(format, v1, v2, ...) -> bytes\n" + 
        "\n" + 
        "Return a bytes object containing the values v1, v2, ... packed according\n" + 
        "to the format string.  See help(struct) for more on format strings.";

    public final static String _struct_pack_into_doc = 
        "pack_into(format, buffer, offset, v1, v2, ...)\n" + 
        "\n" + 
        "Pack the values v1, v2, ... according to the format string and write\n" + 
        "the packed bytes into the writable buffer buf starting at offset.  Note\n" + 
        "that the offset is a required argument.  See help(struct) for more\n" + 
        "on format strings.";

    public final static String _struct_unpack_doc = 
        "Return a tuple containing values unpacked according to the format string.\n" + 
        "\n" + 
        "The buffer's size in bytes must be calcsize(format).\n" + 
        "\n" + 
        "See help(struct) for more on format strings.";

    public final static String _struct_unpack_sig = 
        "($module, format, buffer, /)";

    public final static String _struct_unpack_from_doc = 
        "Return a tuple containing values unpacked according to the format string.\n" + 
        "\n" + 
        "The buffer's size, minus offset, must be at least calcsize(format).\n" + 
        "\n" + 
        "See help(struct) for more on format strings.";

    public final static String _struct_unpack_from_sig = 
        "($module, format, /, buffer, offset=0)";

}
