/* Parser generator main program */

/* This expects a filename containing the grammar as argv[1] (UNIX)
   or asks the console for such a file name (THINK C).
   It writes its output on two files in the current directory:
   - "graminit.c" gets the grammar as a bunch of initialized data
   - "graminit.h" gets the grammar's non-terminals as #defines.
   Error messages and status info during the generation process are
   written to stdout, or sometimes to stderr. */

/* XXX TO DO:
   - check for duplicate definitions of names (instead of fatal err)
*/
package org.python.parser;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;
import java.util.stream.IntStream;

import static org.python.parser.TokenType.*;

/* pgen.c */
public class ParserGenerator {
    static final int NT_OFFSET = 256;
    static final int EMPTY = 0;

    public static void main(String[] args) throws IOException {
        String filename = args[0];
        String grammarinit = args[1];
        Grammar g = getgrammar(filename);
        File fp = new File(grammarinit);
        Writer f = new FileWriter(fp);
        printgrammar(g, f);
        printnonterminals(g, f);
        f.close();
    }

    private static Grammar getgrammar(String filename) {
        File fp = new File(filename);
        Grammar g0 = MetaGrammar.PARSER_GRAMMAR;
        Node n = Parser.ParseFile(fp, filename, g0, g0.start);

        Grammar g = pgen(n);
        return g;
    }

    private static void printnonterminals(Grammar g, Writer fp) throws IOException {
        for (Grammar.DFA d : g.dfas) {
            fp.write(String.format("static final int %s = %d;\n", d.name, d.type));
        }
    }

    private static void printgrammar(Grammar g, Writer fp) throws IOException {
        fp.write("/* Generated by Parser/pgen */\n");
        printdfas(g, fp);
        printlabels(g, fp);
        fp.write("Grammar _PyParser_Grammar = new Grammar(\n");
        fp.write(String.format("%d,\n", g.dfas.size()));
        fp.write("dfas,\n");
        fp.write(");");

    }

    private static void printdfas(Grammar g, Writer fp) throws IOException {
        printstates(g, fp);
        fp.write("static final DFA[] dfas = {\n");
    }

    private static void printlabels(Grammar g, Writer fp) throws IOException {
        fp.write("static final Label[] labels = {\n");
        for (Grammar.Label label : g.ll) {
            if (label.str == null) {
                fp.write(String.format("new Label(%d, null),", label.type));
            } else {
                fp.write(String.format("new Label(%d, \"%s\"),", label.type, label.str));
            }
        }
        fp.write("};\n");
    }

    private static void printstates(Grammar g, Writer fp) throws IOException {
        int i = 0;
        for (Grammar.DFA dfa : g.dfas) {
            printarcs(i, dfa, fp);
            fp.write(String.format("static final State[] state_%d = {\n", i++));
            for (int j = 0; j < dfa.states.size(); j++) {
                fp.write(String.format("new State(arcs_%d_%d),\n", i, j));
            }
            fp.write("};\n");
        }
    }

    private static void printarcs(int i, Grammar.DFA d, Writer fp) throws IOException {
        int j = 0;
        for (Grammar.State s : d.states) {
            fp.write(String.format("static final Arc[] arc_%d_%d = {\n", i, j));
            for (Grammar.Arc arc : s.arcs) {
                fp.write(String.format("new Arc(%d, %d),\n", arc.lbl, arc.arrow));
            }
            fp.write("};\n");
        }
    }

    private static Grammar pgen(Node n) {
        NFAGrammar gr = metacompile(n);
        Grammar g = gr.maketables();
        g.translatelabels();
        g.addfirstsets();
        return g;

    }

    /* PART ONE -- CONSTRUCT NFA */
    private static class NFAArc {
        int label;
        int arrow;

        public NFAArc(int label, int arrow) {
            this.label = label;
            this.arrow = arrow;
        }
    }

    private static class NFAState {
        final List<NFAArc> nfaArcs;

        private NFAState() {
            nfaArcs = new ArrayList<>();
        }

        void addArc(int to, int label) {
            NFAArc arc = new NFAArc(to, label);
            nfaArcs.add(arc);
        }

    }

    private static class NFA {
        int type;
        final String name;
        final List<NFAState> states;
        int start, finish;

        private NFA(String name) {
            this.name = name;
            this.start = this.finish = -1;
            this.type = NT_OFFSET+1;
            states = new ArrayList<>();
        }

        int addState() {
            states.add(new NFAState());
            return states.size() - 1;
        }

        void addNFAArc(int from, int to, int label) {
            states.get(from).addArc(to, label);
        }
    }

    private static class NFAGrammar {
        final List<NFA> nfas;
        final List<Grammar.Label> ll;

        private NFAGrammar() {
            nfas = new ArrayList<>();
            ll = new ArrayList<>();
            addLabel(ENDMARKER.ordinal(), "EMPTY");
        }

        int addLabel(int type, String str) {
            return Grammar.addLabel(ll, type, str);
        }

        NFA addNFA(String name) {
            NFA nf = new NFA(name);
            nfas.add(nf);
            addLabel(NAME.ordinal(), name);
            return nf;
        }

        void compileRule(Node n) {
            REQ(n, RULE);
            REQN(n.nch(), 4);
            int cur = 0;
            Node node = n.nchild(cur++);
            REQ(node, NAME);
            NFA nf = addNFA(node.str());
            node = n.nchild(cur++);
            REQ(node, COLON);
            node = n.nchild(cur++);
            REQ(node, RHS);
            IntTuple tuple = new IntTuple(nf.start, nf.finish);
            compileRHS(ll, nf, node, tuple);
            /* Value is modified in compileRHS */
            /* This is translated from C, hopefully we can refactor in the end */
            nf.start = tuple.a;
            nf.finish = tuple.b;
        }

        void compileRHS(List<Grammar.Label> ll, NFA nf, Node n, IntTuple p) {
            REQ(n, RHS);
            int i = n.nch();
            REQN(i, 1);
            int cur = 0;
            Node node = n.nchild(cur++);
            REQ(node, ALT);
            compileAlt(ll, nf, node, p);
            int a = p.a;
            int b = p.b;
            p.a = nf.addState();
            p.b = nf.addState();
            nf.addNFAArc(a, p.a, EMPTY);
            nf.addNFAArc(b, p.b, EMPTY);
            while (cur < nf.states.size()) {
                node = n.nchild(cur++);
                REQ(node, VBAR);

                node = n.nchild(cur++);
                REQ(node, ALT);
                IntTuple p1 = new IntTuple(a, b);
                compileAlt(ll, nf, node, p1);
                nf.addNFAArc(p.a, p1.a, EMPTY);
                nf.addNFAArc(p.b, p1.b, EMPTY);
            }
        }

        void compileAlt(List<Grammar.Label> ll, NFA nf, Node n, IntTuple p) {
            REQ(n, ALT);
            REQN(n.nch(), 1);
            int cur = 0;
            Node node = n.nchild(cur++);
            REQ(node, ITEM);
            compileItem(ll, nf, n, p);
            while (cur < nf.states.size()) {
                node = n.nchild(cur++);
                REQ(node, ITEM);
                IntTuple p1 = new IntTuple();
                compileItem(ll, nf, node, p1);
                nf.addNFAArc(p.b, p1.a, EMPTY);
                p.b = p1.b;
            }
        }

        void compileItem(List<Grammar.Label> ll, NFA nf, Node n, IntTuple p) {
            REQ(n, ITEM);
            REQN(n.nch(), 1);
            int cur = 0;
            Node node = n.nchild(cur++);
            IntTuple p1 = new IntTuple();
            if (n.type() == LSQB.ordinal()) {
                REQN(n.nch(), 3);
                node = n.nchild(cur++);
                REQ(node, RHS);
                p.a = nf.addState();;
                p.b = nf.addState();;
                nf.addNFAArc(p.a, p.b, EMPTY);
                compileRHS(ll, nf, node, p1);
                nf.addNFAArc(p.a, p1.a, EMPTY);
                nf.addNFAArc(p1.b, p.b, EMPTY);
                node = n.nchild(cur++);
                REQ(node, RSQB);
            } else {
                compileAtom(ll, nf, node, p);
                if (cur >= n.nch()) {
                    return;
                }
                node = n.nchild(cur++);
                nf.addNFAArc(p.b, p.a, EMPTY);
                if (n.type() == STAR.ordinal()) {
                    p.b = p.a;
                } else {
                    REQ(node, PLUS);
                }
            }
        }

        void compileAtom(List<Grammar.Label> ll, NFA nf, Node n, IntTuple p) {
            REQN(n.nch(), 1);
            int cur = 0;
            Node node = n.nchild(cur++);
            if (n.type() == LPAR.ordinal()) {
                REQN(n.nch(), 3);
                node = n.nchild(cur++);
                REQ(node, RHS);
                compileRHS(ll, nf, node, p);
                node = n.nchild(cur++);
                REQ(node, RPAR);
            } if (n.type() == NAME.ordinal() || n.type() == STRING.ordinal()) {
                p.a = nf.addState();
                p.b = nf.addState();
                nf.addNFAArc(p.a, p.b, addLabel(n.type(), n.str()));
            } else {
                REQ(node, NAME);
            }
        }

        static void dumpstate(List<Grammar.Label> ll, NFA nf, int istate) {
            StringBuilder sb = new StringBuilder();
            sb.append(String.format("%c%2d%c", istate == nf.start ? '*' : ' ', istate, istate == nf.finish ? '.' : ' '));
            NFAState st = nf.states.get(istate);
            int i = 0;
            for (NFAArc ar : st.nfaArcs) {
                if (i > 0) {
                    sb.append("\n    ");
                }
                sb.append(String.format("-> %2d  %s", ar.arrow, PyGrammar_LabelRepr(ll.get(ar.label))));
                i++;
            }
            System.out.println(sb);
        }

        static void dumpNFA(List<Grammar.Label> ll, NFA nf) {
            System.out.println(String.format("NFA '%s' has %d states; start %d, finish %d\n", nf.name, nf.states.size(), nf.start, nf.finish));
            IntStream.range(0, nf.states.size()).forEach(i -> dumpstate(ll, nf, i));
        }

        /* PART TWO -- CONSTRUCT DFA */

        static void addClosure(BitSet ss, NFA nf, int istate) {
            if (!ss.get(istate)) {
                ss.set(istate);
                NFAState st = nf.states.get(istate);
                for (NFAArc ar : st.nfaArcs) {
                    if (ar.label == EMPTY) {
                        addClosure(ss, nf, ar.arrow);
                    }
                }
            }
        }

        static class SSArc {
            private BitSet bitset;
            private int arrow, label;
        }

        static class SSState {
            private BitSet ss;
            List<SSArc> arcs;
            boolean deleted, finish;
            int rename;

            public SSState(BitSet ss, boolean finish) {
                this.ss = ss;
                this.arcs = new ArrayList<>();
                this.deleted = false;
                this.finish = finish;
            }
        }

        static class SSDFA {
            private List<SSState> states;
        }

        void makeDFA(NFA nf, Grammar.DFA d) {
            int nbits = nf.states.size();
            BitSet ss = new BitSet(nbits);
            addClosure(ss, nf, nf.start);
            List<SSState> ssStates = new ArrayList<>();
            SSState yy = new SSState(ss, ss.get(nf.finish));
            ssStates.add(yy);
            if (yy.finish) {
                System.out.println(String.format("Error: nonterminal '%s' may produce empty.", nf.name));
            }
            /* For each unmarked state... */
            for (int istate = 0; istate < ssStates.size(); istate++) {
                yy = ssStates.get(istate);
                ss = yy.ss;
                for (int ibit = 0; ibit < nf.states.size(); ++ibit) {
                    if (ss.get(ibit)) {
                        continue;
                    }
                    NFAState st = nf.states.get(ibit);
                    /* For all non-empty arcs from this state... */
                    for (int iarc = 0; iarc < st.nfaArcs.size(); iarc++) {
                        NFAArc ar = st.nfaArcs.get(iarc);
                        if (ar.label == EMPTY) {
                            continue;
                        }
                        /* Look up in list of arcs from this state */
                        for (int jarc = 0; jarc < yy.arcs.size(); ++jarc) {
                            SSArc zz = yy.arcs.get(jarc);
                            if (ar.label == zz.label) {
                                /* Add destination */
                                addClosure(zz.bitset, nf, ar.arrow);
                                break;
                            }
                        }
                        SSArc zz = new SSArc();
                        zz.label = ar.label;
                        zz.bitset = new BitSet(nbits);
                        zz.arrow = -1;
                        addClosure(zz.bitset, nf, ar.arrow);
                    }
                }

                /* Now look up all the arrow states */
                all_arrow:
                for (int jarc = 0; jarc < yy.arcs.size(); jarc++) {
                    SSArc zz = yy.arcs.get(jarc);
                    for (int jstate = 0; jstate < ssStates.size(); jstate++) {
                        if (zz.bitset.equals(ssStates.get(jstate).ss)) {
                            zz.arrow = jstate;
                            continue all_arrow;
                        }
                    }

                    zz.arrow = ssStates.size();
                    yy = new SSState(zz.bitset, yy.ss.get(nf.finish));
                }
            }

            // if debug: printndfa("before minimizing")
            simplify(ssStates);
            // if debug: printndfa("after minimizing")
            convert(d, ssStates);
        }

        /* PART THREE -- SIMPLITY DFA */
        /* Simplify the DFA by repeatedly eliminating states that are
           equivalent to another oner.  This is NOT Algorithm 3.3 from
           [Aho&Ullman 77].  It does not always finds the minimal DFA,
           but it does usually make a much smaller one...  (For an example
           of sub-optimal behavior, try S: x a b+ | y a b+.)
        */
        static boolean samestate(SSState s1, SSState s2) {
            if (s1.arcs.size() != s2.arcs.size() || s1.finish != s2.finish) {
                return false;
            }
            for (int i = 0; i < s1.arcs.size(); i++) {
                if (s1.arcs.get(i).arrow != s2.arcs.get(i).arrow ||
                        s1.arcs.get(i).label != s2.arcs.get(i).label) {
                    return false;
                }
            }
            return true;
        }

        static void renamestates(List<SSState> states, int from, int to) {
            for (SSState st : states) {
                if (st.deleted) {
                    continue;
                }
                for (int i = 0; i < st.arcs.size(); i++) {
                    SSArc ar = st.arcs.get(i);
                    if (ar.arrow == from) {
                        ar.arrow = to;
                    }
                }
            }
        }

        static void simplify(List<SSState> states) {
            int changes;
            do {
                changes = 0;
                for (int i = 1; i < states.size(); i++) {
                    if (states.get(i).deleted) {
                        continue;
                    }
                    for (int j = 0; j < i; j++) {
                        if (states.get(j).deleted) {
                            continue;
                        }
                        if (samestate(states.get(i), states.get(j))) {
                            states.get(i).deleted = true;
                            renamestates(states, i, j);
                            changes++;
                            break;
                        }
                    }
                }
            } while (changes > 0);
        }

        /* PART FOUR -- GENERATE PASRING TABLES */
        static void convert(Grammar.DFA d, List<SSState> states){
            SSArc zz;
            for (SSState yy : states) {
                if (yy.deleted) {
                    continue;
                }
                yy.rename = d.addstate();
            }

            for (SSState yy : states) {
                if (yy.deleted) {
                    continue;
                }
                for (int i = 0; i < yy.arcs.size(); i++) {
                    zz = yy.arcs.get(i);
                    d.addarc(yy.rename, states.get(zz.arrow).rename, zz.label);
                }
                if (yy.finish) {
                    d.addarc(yy.rename, yy.rename, 0);
                }
            }
        }

        /* PART FIVE -- GLUE IT ALL TOGETHER */

        Grammar maketables() {
            if (nfas.isEmpty()) {
                return null;
            }

            Grammar g = new Grammar(nfas.get(0).type);
            g.ll = ll;
            for (NFA nf : nfas) {
                Grammar.DFA d = g.adddfa(nf.type, nf.name);
                makeDFA(nf, d);
            }
            return g;
        }

        /** Fake C macros */
        void REQ(Node n, TokenType type) {
            assert n.type() == type.ordinal();
        }
        void REQN(int n, int count) {
            assert n > count: String.format("metacompile: less than %d children", count);
        }
    }

    /* This acts like the int *pa, int *pb in C, it passes parameter, and receives return value*/
    static class IntTuple {
        int a, b;
        public IntTuple() {
            this.a = this.b = 0;
        }

        public IntTuple(int a, int b) {
            this.a = a;
            this.b = b;
        }
    }

    static NFAGrammar metacompile(Node n) {
        NFAGrammar gr = new NFAGrammar();
        for (Node node : n.children()) {
            if (node.type() != NEWLINE.ordinal()) {
                gr.compileRule(node);
            }
        }
        return gr;
    }

    static Grammar.DFA PyGrammar_FindDFA(Grammar g, int type) {
        return g.dfas.get(NT_OFFSET - type);
    }

    // XXX
    static String PyGrammar_LabelRepr(Grammar.Label label) {
        return "";
    }

}
